<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="/css/default.css" type="text/css">
        <title>Efficient Quicksort in Haskell</title>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <a href="/">Types and Tailcalls</a>
            </div>
            <div class="navigation">
                <ul>
                    <li><a href="/">blog</a></li>
                    <!-- <li><a href="/til.html">til</a></li> -->
                    <li><a href="/archive.html">archive</a></li>
                    <li><a href="/about.html">about</a></li>
                    <!-- <li><a href="/rss.xml">rss</a></li> -->
                </ul>
            </div>
            <div class="body">

<h1 class="title">Efficient Quicksort in Haskell</h1>
<p class="date">published on September 9th, 2013</p>

<p>The Haskell wiki gives as one of the examples of the elegance of Haskell
the following as a quicksort implementation in Haskell:</p>
<pre><code class="lang-{.Haskell}">qsort :: Ord a =&gt; [a] -&gt; [a]
qsort []    = []
qsort (h:t) = qsort (filter (&lt;= h) t) ++ [h] ++ qsort (filter (&gt; h) t)
</code></pre>
<p>In terms of elegance, this solution is indeed hard to beat. It is as
close to Wikipedia&#39;s description of the essence of quicksort as code
can get:^[<a href="http://en.wikipedia.org/wiki/Quicksort">Wikipedia article on quicksort</a>.]</p>
<blockquote>
<p>Quicksort first divides a large list into two smaller sub-lists: the low elements and the high elements.
Quicksort can then recursively sort the sub-lists.</p>
</blockquote>
<p>However, <a href="http://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html">you can
argue</a>
that this is not the <em>real</em> quicksort, because the beauty of quicksort
is that it works in-place and does not require O(n) extra space as the
version given above does. Therefore, the question is sometimes raised
how the <em>real quicksort</em> would look in Haskell, given that it
generally eschews mutuability and in-place update. There are of course
various implementations floating around on the interwebs, but I wanted
to see how an implementation using unboxed vectors looks like and how
that compares in performance to a version in C++&#39;s.</p>
<h2 id="a-haskell-implementation">A Haskell Implementation</h2>
<p>An efficient Quicksort implementation consists of two parts, the
<em>partition</em> function, which rearranges the elements of an array
so that the left part is less-or-equal to the pivot and the right
part is greater and the main function which does the recursive calls
on the sub-parts. Here is my Haskell version:</p>
<pre><code class="lang-{.Haskell}">{-# LANGUAGE BangPatterns, ScopedTypeVariables #-}
module Main where
import           Control.Monad.Primitive
import           Control.Applicative ((&lt;$&gt;))
import qualified Data.Vector.Unboxed as V
import qualified Data.Vector.Unboxed.Mutable as M
import           System.Environment (getArgs)
import           System.Clock
import           System.Exit (exitFailure, exitSuccess)
import           Control.DeepSeq (deepseq)
import qualified Data.ByteString as BS
import           Data.ByteString.Char8 (readInt)

partition :: (PrimMonad m, Ord a, M.Unbox a) =&gt; Int -&gt; M.MVector (PrimState m) a -&gt; m Int
partition !pi !v = do
    pv &lt;- M.unsafeRead v pi
    M.unsafeSwap v pi lastIdx
    pi&#39; &lt;- go pv 0 0
    M.unsafeSwap v pi&#39; lastIdx
    return pi&#39;
  where
    !lastIdx = M.length v - 1

    go !pv i !si | i &lt; lastIdx =
       do iv &lt;- M.unsafeRead v i
          if iv &lt; pv
            then M.unsafeSwap v i si &gt;&gt; go pv (i+1) (si+1)
            else go pv (i+1) si
    go _   _ !si                = return si

qsort :: (PrimMonad m, Ord a, M.Unbox a) =&gt; M.MVector (PrimState m) a -&gt; m ()
qsort v | M.length v &lt; 2 = return ()
qsort v                    = do
    let !pi = M.length v `div` 2
    pi&#39; &lt;- partition pi v
    qsort (M.unsafeSlice 0 pi&#39; v)
    qsort (M.unsafeSlice (pi&#39;+1) (M.length v - (pi&#39;+1)) v)

main :: IO ()
main = do
    args &lt;- getArgs
    if length args &lt; 2
      then putStrLn &quot;Usage: qsort RUNS FILENAME&quot; &gt;&gt; exitFailure
      else return ()
    let (nRuns::Int) = read (args !! 0)
    nums &lt;- V.unfoldr (\s -&gt; readInt $ BS.dropWhile isWs s) &lt;$&gt; BS.readFile (args !! 1)
    loop nRuns (do nums&#39; &lt;- V.thaw nums
                   start &lt;- getTime ProcessCPUTime
                   qsort nums&#39;
                   time &lt;- getTime ProcessCPUTime - start
                   putStrLn $ show $ fromIntegral (sec time) +
                                     ((fromIntegral $ nsec time) / 1000000000))
    exitSuccess
  where
    loop 0 _ = return ()
    loop n a = a &gt;&gt; loop (n-1) a

    isWs !c = c == 10 || c == 20 || c == 9
</code></pre>
<p>All in all I&#39;d say this is a pretty direct translation from the imperative
version. For comparison, here is an implementation in C++:</p>
<pre><code class="lang-{.Cpp}">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;

template&lt;class T&gt;
void swap(std::vector&lt;T&gt;&amp; arr, size_t i1, size_t i2)
{
  T buff = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = buff;
}

template&lt;class T&gt;
size_t partition(std::vector&lt;T&gt;&amp; arr, size_t lo, size_t hi, size_t pi)
{
  swap(arr, pi, hi);
  T pv = arr[hi];
  size_t si=lo;
  for (size_t i=lo; i&lt;hi; ++i) {
    if (arr[i] &lt; pv) {
      swap(arr, i, si++);
    }
  }
  swap(arr, si, hi);
  return si;
}

template&lt;class T&gt;
void qsort(std::vector&lt;T&gt;&amp; arr, size_t lo, size_t hi)
{
  size_t n = hi-lo+1;
  if (n &lt; 2)
    return;
  size_t pi = partition(arr, lo, hi, lo + (hi-lo)/2);
  qsort(arr, lo,   pi-1);
  qsort(arr, pi+1, hi);
}

int main(int ac, char** av)
{
  if (ac &lt;= 2)
  {
    std::cerr &lt;&lt; &quot;Usage: qsort RUNS FILENAME&quot; &lt;&lt; std::endl;
    exit(1);
  }
  int nRuns = atoi(av[1]);

  std::ifstream infile(av[2]);
  if (!infile.good())
  {
    std::cerr &lt;&lt; &quot;Can&#39;t open file: &quot; &lt;&lt; av[2] &lt;&lt; std::endl;
    exit(1);
  }

  std::vector&lt;int&gt; input;
  while (infile.good())
  {
    int i;
    infile &gt;&gt; i;
    input.push_back(i);
  }

  for (int n=0; n &lt; nRuns; ++n)
  {
    std::vector&lt;int&gt; unsorted(input);
    auto start = clock();
    qsort(unsorted, 0, unsorted.size()-1);
    auto end = clock();
    printf(&quot;%11.9f\n&quot;, ((double) (end-start)) / CLOCKS_PER_SEC);
  }
  return 0;
}
</code></pre>
<p>Let&#39;s see how the two versions compare in terms of performance. For
the comparison I generated 10.000.000 random integers, and measured
the time it takes to sort them 50 times. The C++ version averages
about 0.87 seconds while the Haskell version takes about 1.3
seconds. Not a bad result, but of course I would like the Haskell
version to be just as fast. However, with my limited optimization
skills I wasn&#39;t able to eek out any more performance of the Haskell
version.</p>


<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
 var disqus_shortname = 'paulkoerbitz';
 (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>
            <div class="footer">
                <p>© Copyright 2013-2017 by Paul Körbitz.</p>
                <p>
                    Contact me via
                    <a href="http://twitter.com/paulkoer">twitter</a> or
                    <a href="http://github.com/paulkoerbitz">github</a>.
                </p>
                <p><a href="/impressum.html">Impressum</a></p>
            </div>
        </div>
        <script type="text/javascript">
         var _gaq = _gaq || [];
         _gaq.push(['_setAccount', 'UA-20755947-1']);
         _gaq.push(['_setDomainName', 'paulkoerbitz.de']);
         _gaq.push(['_setAllowLinker', true]);
         _gaq.push(['_trackPageview']);
         _gaq.push(['anonymizeIp']);
         (function() {
             var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
             ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
             var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();
        </script>
    </body>
</html>
