<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="/css/atelier-cave-dark.css" type="text/css">
        <link rel="stylesheet" href="/css/default.css" type="text/css">
        <title>Getting Started With Dependent Types</title>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <a href="/">Types and Tailcalls</a>
            </div>
            <div class="navigation">
                <ul>
                    <li><a href="/">blog</a></li>
                    <!-- <li><a href="/til.html">til</a></li> -->
                    <li><a href="/archive.html">archive</a></li>
                    <li><a href="/about.html">about</a></li>
                    <!-- <li><a href="/rss.xml">rss</a></li> -->
                </ul>
            </div>
            <div class="body">

<h1 class="title">Getting Started With Dependent Types</h1>
<p class="date">published on July 31st, 2013</p>

<p>Dependent types, that is type systems where types may depend on
values, are the hot new thing. Dependent types seem like a logical
succession to <a href="/posts/Why-I-love-Haskell.html">Haskell</a>, which <a href="http://stackoverflow.com/questions/12961651/why-not-be-dependently-typed/#answer-13241158">people
much smarter than me
argue</a>
is becoming a dependently typed language itself. I am interested in
learning more about dependent types and want to list some resources
here that I have used or am planing on using.</p>
<h2 id="why-dependent-types-">Why dependent types?</h2>
<p>Why bother learning languages with dependent types? Given that <a href="/posts/Why-I-love-Haskell.html#encode-your-invariants-in-the-type-system">I&#39;ve
argued</a>
that it is beneficial to encode a program&#39;s invariants in the type
system, it is only natural to want a type system that allows you to do
more of this. Dependent types give you this possibilitye, however
there is a trade off: writing programs in dependently typed languages
is more complex (you may have to write some proofs!) and we don&#39;t have
that much experience with it.</p>
<p>I can&#39;t really answer the question if the more powerful type system is
worth the additional difficulties, but it seems like things are in
motion and that now is an interesting time to find out:</p>
<ul>
<li><p>New dependently typed languages that are more or less intended to be
used as real programming languages have started to appear in recent
years. These languages include
<a href="http://wiki.portal.chalmers.se/agda/">Agda</a>,
<a href="http://idris-lang.org">Idris</a> and <a href="http://www.ats-lang.org">ATS</a>.
At least the latter two are clearly intended to be used as <em>real
programming languages</em> (as opposed to theorem provers) and they do
appear to be quite usuable to the casual observer.</p>
</li>
<li><p>New books have come out which make heavy use of the theorem prover
<a href="http://coq.inria.fr">Coq</a> and are intended to teach the use of
dependently typed languages. These books make the use of Coq
accessible to a much larger audience (including me ;).</p>
</li>
<li><p>Domain specific languages (DSLs) and specifically embedded
domain specific languages (EDSLs) are becomming more and more
important. Dependent types allow you to typecheck these languages
with the build-in type checker.</p>
</li>
<li><p>Haskell is moving towards dependent types and so the smart people
behind Haskell seem to think this is a good idea. Who am I to
disagree?</p>
</li>
</ul>
<p>It is of course quite possible that these indications mean nothing or
that it simply looks like a trend to me since I have only recently
started to look at this topic. However, if Haskell has taught me one
thing then it is that great ideas, however different, may eventually
become successful when pursued with the necessary tenacity and that
things that look like huge inconveniences (purity!) may actually turn
out to be great advantages once we get accustomed to them. Non-total
functions have always felt like a wart in Haskell, and that is why I
am willing to bet on dependently typed languages now. I think there
will be a lot of exploring and a lot of learning before these
languages will be anything near mainstream (like where Haskell is
now), but now seems like an exciting time to be part of this
development.</p>
<h2 id="resources">Resources</h2>
<h3 id="programming-languages">Programming languages</h3>
<p>There are now a number of interesting languages with dependent types.
This list makes no attempt to be exhaustive and is slanted towards the
things that interest me. </p>
<ul>
<li><p><a href="http://coq.inria.fr">Coq</a> is the 800-pound Gorilla in dependent
type land. Coq is first and foremost a theorem prover, but at its
heart sits a dependently typed language called Gallina, which itself
is an extensions of the <em>calculus of indicutive constructions</em>.</p>
</li>
<li><p><a href="http://wiki.portal.chalmers.se/agda/">Agda</a> is also a theorem
prover based on the <em>intuitionistic type theory</em> develop by
Martin-Löf. The syntax is heavily influenced by Haskell (as opposed
to Coq whose syntax closer to ML). A major difference between
Agda and Coq is that Agda has no tactics language for proving
theorems.</p>
</li>
<li><p><a href="http://idris-lang.org/">Idris</a> is the new kid on the block, having
appeared only in 2011. It is also heavily influenced by Haskell (the
<a href="http://www.cs.st-andrews.ac.uk/~eb/drafts/impldtp.pdf">introducing
paper</a> asked
the question <em>&quot;What if Haskell had full dependent types?&quot;</em> ). It
differs from Coq and Agda in that it is not described as a theorem
prover but as a general programming language. Indeed, functions must
be annotated if one wants them to be checked for totality. This is a
kind of escape hatch that will make developing regular programs
easier in Idris. While it has (appart from dependent types) a lot in
common with Haskell, it defaults to eager evaluation (with optional
lazy evaluation available with special annotations).</p>
</li>
<li><p><a href="http://www.ats-lang.org/">ATS</a> (which stands for <em>applied type
system</em>) looks like a fusion of C and ML with dependent types thrown
in for good measure. I am not really sure what to think of this
language but at first sight it feels very different from the other
ones listed here. What makes this language really interesting is
that it is intended for systems programming, i.e. for the domain
where one would usually use C or C++. I think this is great because
those two have very little competition in their fields.^[The only
other language that I am aware of that appeared during the last 10
years and does not require garbage collection is
<a href="http://www.rust-lang.org">Rust</a>.] Furthermore, when programming in
C it is so easy to make mistakes that the dependent types and linear
types that ATS has could be a real boon. That said, from my very
limited impression the language seems a bit messy and therefore
I think it is not the best place to start learning about dependent
types.     </p>
</li>
</ul>
<h3 id="books-and-papers">Books and Papers</h3>
<p>There are also a few books that have come out recently-ish that make
dependently typed languages (primarily Coq) much more accessible.
This is of course of huge importance to an autodidact like me.</p>
<ul>
<li><p><a href="http://www.cis.upenn.edu/~bcpierce/sf/">Software foundations</a> by
Benjamin Pierce teaches Coq, functional programming, basic typing
theory and the universe.  There are basically no prerequisites
(except for being able to install Emacs ;)) and lots and lots of
little excercises. It seems a bit slow at the start but working
through all of the excercises will probably give a lot of
familiarity with Coq, so that may be worth it.</p>
</li>
<li><p><a href="http://adam.chlipala.net/cpdt/">Certified programming with dependent
types</a> by Adam Chlipala. This book
seems much more advanced than software foundations. It states in the
introduction that it wants to initiate a discussion on best
practices for developing certified programs in dependently typed
languages. The author argues that every proof should be automated
so that no manual steps are required (once the right lemmata have
been developed).</p>
</li>
<li><p><a href="http://www.cis.upenn.edu/~bcpierce/tapl/">Types and programming
languages</a> by Benjamin
Pierce. This book is not really on dependent types but introduces
the foundations for programming language theory such as the typing
rules, operational semantics, the (simply typed) lambda calculus,
subtyping and a few more. I&#39;ve meant to read it completely but
I am stuck half way. It is certainly a very accessible book and
a fun read.</p>
</li>
<li><p><a href="http://people.cs.uu.nl/andres/LambdaPi/LambdaPi.pdf">A tutorial implmentation of a dependently typed lambda
calculus</a> by
Andres Löh et al. I am not sure if I can give you a better summary
than the title. Doesn&#39;t it just make you want to read the paper?</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Intuitionistic_type_theory">Martin Löf&#39;s type
theory</a> is
the foundation for Agda. I think learning the theory might not
acutally be necessary for a working understanding of dependent types
and to get an idea of what you can do with them, but it would sure
be nice to know more about the foundations.</p>
</li>
<li><p><a href="http://homotopytypetheory.org/">HoTT</a> or <em>Homotopy Type Theory</em>
refers to a new interpretation of Martin-Löf’s system of
intensional, constructive type theory into abstract homotopy theory.
The book&#39;s authors believe that univalent foundations will
eventually become a viable alternative to set theory as the
“implicit foundation” for the unformalized mathematics done by most
mathematicians.^[I&#39;ve lifted the last two sentences from the books
website for obvious reasons. See
<a href="http://homotopytypetheory.org/">here</a> and
<a href="http://homotopytypetheory.org/book/">here</a>.] I am not sure I&#39;ll
ever make it this far, but it seems like a very interesting theory.
Advanced Haskellers seem to get a lot out of category theory, maybe
the same will be said for HoTT and dependent types.</p>
</li>
</ul>
<h3 id="videos">Videos</h3>
<p>There are also a few videos and screencasts which revolve around
dependent types or some programming language that features dependent
types. First of all there is a four day course on Idris with <a href="http://www.idris-lang.org/dependently-typed-functional-programming-with-idris-course-videos-and-slides/">videos
and
excercises</a>
held by the creator of Idris Edwin Brady. I have found the video and
the excercises to be a good way to get started with Idris.  There is
also an introduction to Agda with <a href="https://www.youtube.com/playlist?list=PL44F162A8B8CB7C87">nine
lectures</a> by
Conner McBride.</p>
<h2 id="my-plan">My plan</h2>
<p>While I do appreciate some theoretical background, I am not sure that
I have the stamina to work through a huge amount of theory without
also seeing some applications. I have thus decided to try an approach
that combines theory with practice. First of all, I would like to work
through <em>Sofware Foundations</em>. While this is theoretically a book,
there are so many exercises that it nicely combines theory and
practice. Once I am done with that I would like to work my way through
<em>Certified Programming with Dependent Types</em>. At the same time I am
going to try to port some nice Haskell program to Idris and attempt to
prove the totality of as many functions as possible. Since Wouter
Swierstra has already ported <a href="http://www.staff.science.uu.nl/~swier004/Publications/XmonadInCoq.pdf">Xmonad to
Coq</a>,
this seems like an interesting candidate. Besides, I am running xmonad
and like it a lot, so what could be a better opportunity to learn more
about it?</p>


<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
 var disqus_shortname = 'paulkoerbitz';
 (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>
<div class="footer">
    <p>© Copyright 2013-2018 by Paul Körbitz.</p>
    <p>
        Contact me via
        <a href="http://twitter.com/paulkoer">twitter</a> or
        <a href="http://github.com/paulkoerbitz">github</a>.
    </p>
    <p>
        <a href="/impressum.html">Impressum</a>
    </p>
</div>
</div>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-20755947-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-20755947-1');
</script>
</body>
</html>