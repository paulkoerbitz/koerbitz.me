<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="/css/default.css" type="text/css">
        <title>Certified Red-Black Trees in Coq -- Part 0</title>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <a href="/">Types and Tailcalls</a>
            </div>
            <div class="navigation">
                <ul>
                    <li><a href="/">blog</a></li>
                    <!-- <li><a href="/til.html">til</a></li> -->
                    <li><a href="/archive.html">archive</a></li>
                    <li><a href="/about.html">about</a></li>
                    <!-- <li><a href="/rss.xml">rss</a></li> -->
                </ul>
            </div>
            <div class="body">

<h1 class="title">Certified Red-Black Trees in Coq -- Part 0</h1>
<p class="date">published on October 24th, 2013</p>

<p>Now that I&#39;ve learned about Coq <a href="/notes/Software-Foundations.html">for a while</a>,
I&#39;ve wondered if I could actually used it to prove something useful yet. One thing
I thought would be interesting but not to hard was to prove that insert and
delete operations on red-black trees are sound.</p>
<p>Alas, I&#39;ve discovered that comming up with structures and proves myself was a lot
harder than just doing the exercises in software foundations. But I&#39;ve kept
at it and I now sort-a kind-a proved that the insert operations maintains the
order of a red-black tree, one of its three defining properties (the others are
perfect black balance, and non-consequitive left-leaning red nodes).</p>
<p>The proofs are still full of holes, but they are holes that I am confident I
can fix given a little more time (they should not be complicated). It ain&#39;t pretty,
but I am glad I got this far:</p>
<pre><code class="lang-{.ocaml}">
Require Export SfLib.
Module RbTrees.

Inductive RbColor : Type :=
  | RbRed
  | RbBlack.

Definition flipColor (c:RbColor) : RbColor :=
  match c with
    | RbRed =&gt; RbBlack
    | RbBlack =&gt; RbRed
  end.

Inductive RbTree : Type :=
  | tip : RbTree
  | node : RbColor -&gt; nat -&gt; RbTree -&gt; RbTree -&gt; RbTree.

Fixpoint rotLeft (t:RbTree) : RbTree :=
  match t with
    | tip =&gt; tip
    | node c n l r =&gt;
      match r with
        | tip =&gt; node c n l r
        | node rc rn rl rr =&gt; node rc rn (node RbRed n l rl) rr
      end
  end.

Fixpoint rotRight (t:RbTree) : RbTree :=
  match t with
    | tip =&gt; tip
    | node c n l r =&gt;
      match l with
        | tip =&gt; node c n l r
        | node lc ln ll lr =&gt; node lc ln ll (node RbRed n lr r)
      end
  end.

Definition rightIsRed (t:RbTree) : bool :=
  match t with
    | node _ _ _ (node RbRed _ _ _) =&gt; true
    | _ =&gt; false
  end.

Definition twoRedsOnLeft (t:RbTree) : bool :=
  match t with
    | node _ _ (node RbRed _ (node RbRed _ _ _) _) _ =&gt; true
    | _ =&gt; false
  end.

Definition balanceR (t:RbTree) : RbTree :=
  if twoRedsOnLeft t then rotRight t else t.

Definition balanceL (t:RbTree) : RbTree :=
  if rightIsRed t then rotLeft t else t.

Definition bothLeftAndRightAreRed (t:RbTree) : bool :=
  match t with
    | node _ _ (node RbRed _ _ _) (node RbRed _ _ _) =&gt; true
    | _ =&gt; false
  end.

(* these evidence carrying booleans would be nice here *)
Definition flipColors (t:RbTree) : RbTree :=
  match t with
    | node RbBlack n (node RbRed ln ll lr) (node RbRed rn rl rr) =&gt; node RbRed n (node RbBlack ln ll lr) (node RbBlack rn rl rr)
    | _ =&gt; t
  end.

Inductive flipable : RbTree -&gt; Prop :=
  | flip_intro : forall (n ln rn:nat) (ll lr rl rr : RbTree),
                   flipable (node RbBlack n (node RbRed ln ll lr) (node RbRed rn rl rr)).

Inductive Cmp : Type :=
  | LT
  | EQ
  | GT.

Fixpoint cmp (n m:nat) : Cmp :=
  if beq_nat n m then EQ else
    if ble_nat n m then LT else GT.

Fixpoint insert (nn:nat) (t:RbTree) : RbTree :=
  match t with
    | tip =&gt; node RbBlack nn tip tip
    | node c n l r =&gt;
      match cmp nn n with
        | EQ =&gt; t
        | LT =&gt; flipColors (balanceR (node c n (insert nn l) r))
        | GT =&gt; flipColors (balanceL (node c n l (insert nn r)))
      end
  end.

Fixpoint blt_nat (n m:nat) : bool :=
  match n with
    | O      =&gt; match m with
                  | O =&gt; false
                  | S m&#39; =&gt; true
                end
    | (S n&#39;) =&gt; ble_nat n&#39; m
  end.

Definition bgt_nat (n m:nat) : bool :=
  blt_nat m n.

Fixpoint rbForall (f : nat -&gt; bool) (t : RbTree) : bool :=
  match t with
    | tip =&gt; true
    | node _ n l r =&gt; andb (andb (rbForall f l) (f n)) (rbForall f r)
  end.

Definition gtTree (t:RbTree) (m:nat)  : bool :=
  rbForall (bgt_nat m) t.

Definition ltTree (t:RbTree) (m:nat) : bool :=
  rbForall (blt_nat m) t.

Theorem excluded_middle :
  forall P:Prop, P \/ ~ P.
Proof.
Admitted.

Lemma unflipable : forall (t:RbTree),
  ~flipable t -&gt; flipColors t = t.
Proof.
  intros.
  destruct t.
  simpl. reflexivity.
  destruct r. simpl. reflexivity.
  destruct t1. simpl. reflexivity.
  destruct r.
  destruct t2. simpl. reflexivity.
  destruct r. unfold not in H.
  assert (flipable (node RbBlack n (node RbRed n0 t1_1 t1_2) (node RbRed n1 t2_1 t2_2))).
  apply flip_intro. apply H in H0. inversion H0.
  simpl. reflexivity.
  simpl. reflexivity.
Qed.

Lemma rbForall_flipColors : forall (f : nat -&gt; bool) (t:RbTree),
  rbForall f t = true -&gt; rbForall f (flipColors t) = true.
Proof.
  intros. induction t.
  Case &quot;t=tip&quot;. simpl. assumption.
  Case &quot;t=cons&quot;.  remember (node r n t1 t2) as t.
    assert (flipable t \/ ~ (flipable t)). apply excluded_middle.
    inversion H0. destruct H1. simpl. simpl in H. apply H. assert (flipColors t = t).
    apply unflipable. apply H1. rewrite H2. apply H.
Qed.

Lemma rbForall_balanceR : forall (f : nat -&gt; bool) (t:RbTree),
  rbForall f t = true -&gt; rbForall f (balanceR t) = true.
Proof.
Admitted.

Lemma rbForall_balanceL : forall (f : nat -&gt; bool) (t:RbTree),
  rbForall f t = true -&gt; rbForall f (balanceL t) = true.
Proof.
Admitted.

Lemma rbForall_insert : forall (n m:nat) (f : nat -&gt; nat -&gt; bool) (t:RbTree),
  rbForall (f n) t = true -&gt; f n m = true -&gt; rbForall (f n) (insert m t) = true.
Proof.
  intros. induction t.
  Case &quot;t=tip&quot;. simpl. unfold rbForall. unfold rbfold. rewrite H0. simpl. reflexivity.
  Case &quot;t=cons&quot;. remember (cmp m n0) as cmpEq. destruct cmpEq.
    SCase &quot;m &lt; n0&quot;. simpl. rewrite &lt;- HeqcmpEq. apply rbForall_flipColors. apply rbForall_balanceR. admit.
    SCase &quot;m = n0&quot;. simpl. rewrite &lt;- HeqcmpEq. assumption.
    SCase &quot;m &gt; n0&quot;. simpl. rewrite &lt;- HeqcmpEq. apply rbForall_flipColors. apply rbForall_balanceL. admit.
Qed.

Inductive rbOrdered : RbTree -&gt; Prop :=
  | O_Tip : rbOrdered tip
  | O_Cons : forall (n:nat) (c : RbColor) (l r : RbTree),
               rbOrdered l -&gt; rbOrdered r -&gt;
               gtTree l n = true -&gt; ltTree r n = true -&gt;
               rbOrdered (node c n l r).

Lemma flipColor_keeps_order : forall (n:nat) (c:RbColor) (l r : RbTree),
  rbOrdered (node c n l r) -&gt; rbOrdered (node (flipColor c) n l r).
Proof.
  intros. inversion H. apply O_Cons. assumption. assumption. assumption. assumption.
Qed.

Lemma flipColors_keeps_order : forall (t : RbTree),
  rbOrdered t -&gt; rbOrdered (flipColors t).
Proof.
  intros. remember t as tt. induction H.
  Case &quot;t = tip&quot;.
    simpl. apply O_Tip.
  Case &quot;t = node ...&quot;.
    assert (flipable t \/ ~ (flipable t)). apply excluded_middle.
    inversion H3. rewrite &lt;- Heqtt in H4. inversion H4. simpl.
    constructor.
    rewrite &lt;- H8 in H. apply flipColor_keeps_order in H. simpl in H. apply H.
    rewrite &lt;- H9 in H0. apply flipColor_keeps_order in H0. simpl in H0. apply H0.
    rewrite &lt;- H8 in H1. unfold gtTree in H1. simpl in H1. unfold gtTree. simpl. apply H1.
    rewrite &lt;- H9 in H2. unfold ltTree in H2. simpl in H2. unfold ltTree. simpl. apply H2.
    assert (flipColors t = t). apply unflipable. apply H4.
    rewrite Heqtt. rewrite H5. rewrite &lt;- Heqtt. constructor; assumption.
Qed.

Lemma balanceL_keeps_order : forall (t : RbTree),
  rbOrdered t -&gt; rbOrdered (balanceL t).
Proof.
Admitted.

Lemma balanceR_keeps_order : forall (t : RbTree),
  rbOrdered t -&gt; rbOrdered (balanceR t).
Proof.
Admitted.

Theorem insert_keeps_order : forall (n:nat) (t : RbTree),
  rbOrdered t -&gt; rbOrdered (insert n t).
Proof.
  intros. induction H.
  Case &quot;O_Tip&quot;. simpl. repeat constructor.
  Case &quot;O_Cons&quot;.
    remember (cmp n n0) as Hcmp.
    destruct Hcmp.
    SCase &quot;n &lt; n0&quot;.
      simpl. rewrite &lt;- HeqHcmp.
      apply flipColors_keeps_order. apply balanceR_keeps_order. constructor. assumption. assumption.
      unfold gtTree.
      (*   rbForall (f n) t = true -&gt; f n m = true -&gt; rbForall (f n) (insert m t) = true. *)
      apply rbForall_insert. apply H1.
      (* cmp n n0 = LT -&gt; bgt_nat n0 n = true *) admit.
      assumption.
    SCase &quot;n = n0&quot;. simpl. rewrite &lt;- HeqHcmp. apply O_Cons; assumption.
    SCase &quot;n &gt; n0&quot;.
      simpl. rewrite &lt;- HeqHcmp.
      apply flipColors_keeps_order. apply balanceL_keeps_order. apply O_Cons. assumption. assumption. assumption.
      unfold ltTree. apply rbForall_insert. apply H2.
      (* cmp n n0 = GT -&gt; blt_nat n0 n = true *) admit.
Qed.
</code></pre>
<p>This is all quite rough of course, I think I can learn a lot but iterating upon it until I have
a nice solution. Dependent types are not easy!</p>


<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
 var disqus_shortname = 'paulkoerbitz';
 (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>
            <div class="footer">
                <p>© Copyright 2013-2017 by Paul Körbitz.</p>
                <p>
                    Contact me via
                    <a href="http://twitter.com/paulkoer">twitter</a> or
                    <a href="http://github.com/paulkoerbitz">github</a>.
                </p>
                <p><a href="/impressum.html">Impressum</a></p>
            </div>
        </div>
        <script type="text/javascript">
         var _gaq = _gaq || [];
         _gaq.push(['_setAccount', 'UA-20755947-1']);
         _gaq.push(['_setDomainName', 'paulkoerbitz.de']);
         _gaq.push(['_setAllowLinker', true]);
         _gaq.push(['_trackPageview']);
         _gaq.push(['anonymizeIp']);
         (function() {
             var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
             ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
             var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();
        </script>
    </body>
</html>
