<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Types and Tailcalls - Understanding Pointers, Ownership, and Lifetimes in Rust</title>
    <link rel="stylesheet" href="../css/default.css" type="text/css">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <a href="../">Types and Tailcalls</a>
      </div>
      <div class="navigation">
        <ul>
          <li><a href="../">blog</a></li>
          <li><a href="../archive.html">archive</a></li>
          <li><a href="../notes.html">notes</a></li>
          <!-- 
          <li><a href="/projects.html">projects</a></li>
          -->
          <li><a href="../about.html">about</a></li>
        </ul>
      </div>
      <div class="body">
        <h1 class="title">Understanding Pointers, Ownership, and Lifetimes in Rust</h1>

<p class="date">written on December 21, 2013</p>

<p>In the last couple of weeks I have been looking into <a href="http://www.rust-lang.org">Rust</a>, a new language developed by the good folks at Mozilla. Rust is fairly unique in that it is aimed at the same space as C++: A (real) systems programming language that gives you full control over memory usage but offers high level language features at the same time. In the past few years a few languages have come out that claim to target this space, for example <a href="http://www.go-lang.org">Go</a>, <a href="http://www.dlang.org">D</a>, and <a href="http://www.nimrod.org">Nimrod</a>, but I think none of them can truly compete with C++. For startes, basically all of these languages depend on garbage collection and are thus ill-fitted for the type of low-level where C++ shines.</p>
<p>At the same time I think that C++ badly needs some real competition. Even among C++ fans, few will deny that compatibility with C, decades of evolution, and accidental language features have created a very complex language that is extremely difficult to master. I think it is quite sad that for a lot of applications, C++ is still the sanest choice. We need a simpler language that offers more modern language features while targeting the same space. Rust could just be that language.</p>
<p>Ok now, the point of this post is not to argue the case for <a href="http://www.rust-lang.org">Rust</a> nor to heap (well deserved) praise onto the Rust designers and implementers. I want to talk about the ownership semantics in Rust and how they interact with pointers and closures.</p>
<h2 id="rusts-guiding-principles">Rust’s Guiding Principles</h2>
<p>When I try to understand something I want to discover the guiding principles from which I can quickly derive how certain things must be. To me the guiding principles of memory managemend in Rust are the following:</p>
<ol style="list-style-type: decimal">
<li><p><strong><strong>Manual memory management</strong></strong>: There must be some way for the programmer to control when an object on the heap will be deleted.</p></li>
<li><p><strong><strong>Memory safety</strong></strong>: Pointers must never point to areas of memory that have been changed or deleted without their knowledge.</p></li>
<li><p><strong><strong>Safe Concurrency</strong></strong>: There should be no dataraces between threads, i.e. multiple threads must not read and modify the same part of memory at the same time.</p></li>
<li><p><strong><strong>Compile time checks</strong></strong>: Finally, Rust strives to ensure things are correct at compile time whenever possible. There are two key benefits: performance and correctness.</p></li>
</ol>
<p>This, in conjunction with the features that Rust provides, this will give us a very good idea why certain things must be the way they are in Rust.</p>
<h2 id="three-types-of-pointers">Three Types of Pointers</h2>
<h3 id="owned-pointers">Owned Pointers</h3>
<p>An <em>owned pointer</em> in Rust has ownership over a certain part of the heap. When it goes out of scope it deletes that part of the heap. This achieves <em>manual memory management</em>: the programmer has control over when memory will be released by controlling when an owned pointer will go out of scope.</p>
<h3 id="borrowed-pointers">Borrowed Pointers</h3>
<p>Having only owned pointers would make writing many programs difficult: there could only ever be one reference to every <em>thing</em>. Fortunately, Rust offers another type of pointer called a <em>borrowed pointer</em>. Borrowed pointers do not imply ownership and they can point to objects both in the heap and the stack, so they are quite flexible.</p>
<h3 id="managed-pointers">Managed Pointers</h3>
<p>Owned and borrowed pointers fit a lot of use cases, but sometimes they are not enough. Each piece of memory must have an ultimate owner, this means that the ownership of all objects on the heap must be representable as a directed acyclic graph. When this is not possible or inconvenient Rust offers <strong><strong>managed pointers</strong></strong>, which are garbage collected pointers<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> and thus allow shared ownership.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<h2 id="move-semantics">Move Semantics</h2>
<p><em>Memory safety</em> implies that owned pointers <em>cannot be copied or cloned</em>. Otherwise, two such pointers could point to the same block of memory and that memory would be deleted twice. Therefore, owned pointers have move semantics:<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> when owned pointer <code>o2</code> is initialized from owned pointer <code>o1</code>, <code>o1</code> is no longer valid. This could be ensured either at run time or compile time, fortunately the Rust compiler ensures this at compile time.<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup></p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
   <span class="kw">let</span> o1 = ~<span class="st">&quot;world&quot;</span>;
   <span class="kw">let</span> o2 = o1;                <span class="co">// &lt;-- o1 is 'moved' into o2 and now invalid</span>
   println!(<span class="st">&quot;Hello, {}!&quot;</span>, o1); <span class="co">// &lt;-- this is a compile time error</span>
}</code></pre>
<p>Indeed the Rust compiler reports:</p>
<pre><code>move.rs:4:26: 4:28 error: use of moved value: `o1`
move.rs:4    println!(&quot;Hello, {}!&quot;, o1); // &lt;-- this is a compile time error
                                    ^~</code></pre>
<h3 id="structs-and-enums">Structs and Enums</h3>
<p>In general Rust has what we might call <em>shallow copy semantics</em>: When an object is initialized via assignment or call-by-value then its memory is a bitwise copy of the object used to assign it. However, this is changed when an object contains an owned pointer: because the owned pointer has move semantics, the object containing it must also have move semantics, otherwise we would again incur two independent owning copies.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Pod {x: <span class="kw">int</span>, y: <span class="kw">uint</span>, z: [<span class="dv">3.</span>.. <span class="kw">int</span>]}
<span class="kw">struct</span> WithOptr {x: <span class="kw">int</span>, p: ~<span class="kw">int</span>}

<span class="kw">fn</span> main() {
   <span class="kw">let</span> a1 = Pod {x: <span class="dv">3</span>, y: <span class="dv">4u</span>, z: [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]};
   <span class="kw">let</span> a2 = a1;
   println!(<span class="st">&quot;{:?}&quot;</span>, a1);                   <span class="co">// &lt;-- OK, a1 has been copied</span>
   <span class="kw">let</span> b1 = WithOptr {x: <span class="dv">3</span>, p: ~<span class="dv">4</span>};
   <span class="kw">let</span> b2 = b1;
   println!(<span class="st">&quot;{:?}&quot;</span>, b1);                   <span class="co">// &lt;-- Compile time error, b1 has been moved</span>
}</code></pre>
<p>The same rules apply to enums, but here the error messages can be a bit more confusing.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> MyEnum {
     X(<span class="kw">int</span>),
     Y(~<span class="kw">int</span>)
}

<span class="kw">fn</span> match_and_print(e: &amp;MyEnum) {
    <span class="kw">match</span> *e {
        X(x) =&gt; println!(<span class="st">&quot;{}&quot;</span>, x),  <span class="co">// &lt;-- OK, x can be copied</span>
        Y(y) =&gt; println!(<span class="st">&quot;{}&quot;</span>, *y)  <span class="co">// &lt;-- Error, y cannot be moved out of a reference</span>
    }
}

<span class="kw">fn</span> main() {
   <span class="kw">let</span> x = &amp;X(<span class="dv">3</span>);
   <span class="kw">let</span> y = &amp;Y(~<span class="dv">4</span>);
   match_and_print(x);
   match_and_print(y);
}</code></pre>
<p>In this case the compiler reports</p>
<pre><code>move.rs:33:8: 33:12 error: cannot move out of dereference of &amp; pointer
move.rs:33         Y(y) =&gt; println!(&quot;{}&quot;, *y)
                   ^~~~</code></pre>
<p>Standard pattern matches are pass-by-value, meaning that the contents of the enum is either copied or moved. However, this can only be done when we have ownership over the values to be moved. When we apply <code>match</code> to a dreferenced borrowed pointer, we cannot move because we don’t have ownership. Changing the <code>match_and_print</code> function to take a copy would work again:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> match_and_print(e: MyEnum) {
    <span class="kw">match</span> e {
        X(x) =&gt; println!(<span class="st">&quot;{}&quot;</span>, x),
        Y(y) =&gt; println!(<span class="st">&quot;{}&quot;</span>, *y)
    }
}</code></pre>
<h3 id="the-ref-keyword">The <code>ref</code> Keyword</h3>
<p>Copying or moving values in pattern matches is not always what we want. Sometimes we just want to take a reference. This way we can pattern match on values which we have obtained via borrowed pointers or we can simply avoid a move or copy. This is where the <code>ref</code> keyword comes into play: It changes the call-by-value semantics of a pattern match to call-by-borrowed-pointer semantics:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> match_and_print(e: &amp;MyEnum) {
    <span class="kw">match</span> *e {
        X(x) =&gt; println!(<span class="st">&quot;{}&quot;</span>, x),
        Y(<span class="kw">ref</span> y) =&gt;                 <span class="co">// OK, y is a borrowed ptr to ~int</span>
            println!(<span class="st">&quot;{}&quot;</span>, **y)     <span class="co">// y has type &amp;~int and must be dereferenced twice</span>
    }
}</code></pre>
<p>To bind mutable references there is also the <code>ref mut</code> version which allows modifying:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> match_and_print(e: &amp;<span class="kw">mut</span> MyEnum) {
    <span class="kw">match</span> *e {
        X(x) =&gt; println!(<span class="st">&quot;{}&quot;</span>, x),
        Y(<span class="kw">ref</span> <span class="kw">mut</span> y) =&gt; {
            **y = <span class="dv">5</span>;
            println!(<span class="st">&quot;{}&quot;</span>, **y)
        }
    }
}

<span class="kw">fn</span> main() {
   <span class="kw">let</span> x = &amp;<span class="kw">mut</span> X(<span class="dv">3</span>);
   <span class="kw">let</span> y = &amp;<span class="kw">mut</span> Y(~<span class="dv">4</span>);
   match_and_print(x);
   match_and_print(y);
}</code></pre>
<p>The <code>ref</code> keyword and its <code>ref mut</code> variant also work in <code>let</code> bindings:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
   <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">3</span>;
   <span class="kw">let</span> <span class="kw">ref</span> <span class="kw">mut</span> y = x;
   *y = <span class="dv">4</span>;
   println!(<span class="st">&quot;{}&quot;</span>, *y);
}</code></pre>
<h2 id="lifetimes">Lifetimes</h2>
<p>The difficulty with borrowed pointers is that they themselves cannot ensure that they point to valid memory. What if the thing that owns the memory they point to goes out of scope or is reassigned? Since the borrowed pointer has no ownership that memory would be deleted and possibly reassigned. The borrowed pointer would become a <em>dangling reference</em>, which is precisely what we wanted to avoid per guiding principle number 2: <strong>memory safety</strong>.</p>
<p>Therefore Rust must take a number of precautions to ensure these scenarios do not happen. First, the memory that a borrowed pointer points to must not be freed during that borrowed pointers <strong><strong>lifetime</strong></strong>. Second, this memory <strong><strong>must not change</strong></strong> while it is borrowed.</p>
<p>The first requirement leads us to the concept of <strong><strong>lifetimes</strong></strong>, the amount of time that some object is guaranteed to exist.</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> lifetimes1() {
    <span class="kw">let</span> name = ~<span class="st">&quot;world&quot;</span>;               <span class="co">//                 &lt;--+</span>
    <span class="kw">if</span> (<span class="dv">3</span> &lt; <span class="dv">5</span>) {                       <span class="co">//                    |</span>
        <span class="kw">let</span> bname = &amp;name;             <span class="co">// &lt;--+               | name's</span>
        println!(<span class="st">&quot;Hello, {}!&quot;</span>, name);  <span class="co">//    | bname's       | lifetime</span>
        println!(<span class="st">&quot;Hello, {}!&quot;</span>, bname); <span class="co">//    | lifetime      |</span>
    }                                  <span class="co">// &lt;--+               |</span>
}                                      <span class="co">//                 &lt;--+</span></code></pre>
<p>In this example, it is quite clear that the lifetime of <code>bname</code> will be shorter than that of <code>name</code> and thus the compile needs no help in figuring this out. However, things need not always be this simple, consider the following example:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> lifetimes2() {
    <span class="kw">let</span> <span class="kw">mut</span> x_ref = &amp;<span class="dv">3</span>;       <span class="co">//                 &lt;--+</span>
    <span class="kw">if</span> <span class="kw">true</span> {                 <span class="co">//                    |</span>
        <span class="kw">let</span> <span class="kw">mut</span> y_ref = &amp;<span class="dv">4</span>;   <span class="co">// &lt;--+ y_ref's       | x_ref's</span>
        x_ref = y_ref;        <span class="co">//    | lifetime      | lifetime</span>
    }                         <span class="co">// &lt;--+               |</span>
}                             <span class="co">//                 &lt;--+</span></code></pre>
<p>Here we have a problem: <code>x_ref</code> is reassigned to point to the same memory location as <code>y_ref</code>, but <code>y_ref</code>’s lifetime is shorter than <code>x_ref</code>’s. To ensure memory safety, the compiler must rejetct this program, which it does:</p>
<pre><code>lifetimes.rs:21:24: 21:26 error: borrowed value does not live long enough
lifetimes.rs:18:16: 24:1 note: borrowed pointer must be valid for the block at 18:16...
lifetimes.rs:20:12: 23:5 note: ...but borrowed value is only valid for the block at 20:12</code></pre>
<p>Things become even more interesting when we work with borrowed pointers inside of a function:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> minLife(x: &amp;<span class="kw">int</span>, y: &amp;<span class="kw">int</span>) -&gt; &amp;<span class="kw">int</span> {
    <span class="kw">if</span> (*x &lt; *y) {
        x
    } <span class="kw">else</span> {
        y
    }
}</code></pre>
<p>Here the lifetime of the result depends on the condition evaluated in the if statement: depending on it the lifetime will either be that of x or that of y. Clearly, the compiler can’t resolve this automatically, it would need to know the values to which x and y point, which may only be known at runtime:</p>
<pre><code>lifetimes.rs:11:4: 15:5 error: cannot infer an appropriate lifetime due to conflicting requirements
lifetimes.rs:10:37: 16:1 note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the block at 10:37...
lifetimes.rs:11:4: 15:5 note: ...so that if and else have compatible types (expected `&amp;int` but found `&amp;int`)
lifetimes.rs:10:37: 16:1 note: but, the lifetime must be valid for the anonymous lifetime #3 defined on the block at 10:37...
lifetimes.rs:11:4: 15:5 note: ...so that types are compatible (expected `&amp;int` but found `&amp;int`)</code></pre>
<p>Since the compiler can’t infer the lifetimes we must annotate them. Alas, we too would be hard pressed to give the exact lifetime in this example. However, there is a trick by which we can manage this</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> minLife&lt;<span class="ch">'a&gt;(x: &amp;'</span>a <span class="kw">int</span>, y: &amp;<span class="ch">'a int) -&gt; &amp;'</span>a <span class="kw">int</span> {
    <span class="kw">if</span> (*x &lt; *y) {
        x
    } <span class="kw">else</span> {
        y
    }
}</code></pre>
<p>Here we explictly annotate the lifetime of the parameters and the return value. Lifetime parameters are introduced by a single tick <code>'</code> followed by an identifier. In functions these must be the first template parameters. As you can see we use the same parameter for the lifetime everywhere. If the compiler would take this information too literally, then this function whould be less flexible than we might wish: In this case we could only use it on borrowed pointers which have the exact same lifetime. Fortunately, the compiler interprets the provided lifetimes as a lower bound. Thus <code>'a</code> is the minimum of the lifetimes of <code>x</code> and <code>y</code>.</p>
<p>There is one special lifetime, which is called <code>'static</code> and is for objects which are allocated for the entire life of the program. For methods, the lifetime <code>'self</code> has a special meaning, but this is considered a bug and will probably be soon removed from the language.</p>
<h2 id="freezing">Freezing</h2>
<p>Another problem with borrowed pointers is that the memory must not be modified while it has been borrowed out. This is achieved by freezing the original object when a borrowed pointer to it exists:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> freeze() {
    <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">3</span>;
    {
        <span class="kw">let</span> <span class="kw">mut</span> y = &amp;x;
        x = <span class="dv">4</span>;       <span class="co">// &lt;-- Error: x has been borrowed and is thus `frozen`</span>
    }
    x = <span class="dv">4</span>;           <span class="co">// OK</span>
}</code></pre>
<p>In the block we cannot modify <code>x</code> because it is borrowed:</p>
<pre><code>lifetimes.rs:22:8: 22:9 error: cannot assign to `x` because it is borrowed
lifetimes.rs:22         x = 4;       // &lt;-- Error: x has been borrowed and is thus `frozen`
                        ^
lifetimes.rs:21:20: 21:22 note: borrow of `x` occurs here
lifetimes.rs:21         let mut y = &amp;x;
                                    ^~</code></pre>
<p>Note that this restriction is irrespective of whether the borrowed pointer is mutable or not.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Currently, these are implemented as reference counted pointers with cycle detection.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>There are thoughts to remove these pointers from the language and delegate them to the standard library (allowing different types of garbage collection), but this has not happened yet.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The other alternative would be that owned pointers can never be reassigned, they would be non-copiable and non-moveable. This seems pretty cumbersome, fortunately Rust’s owned pointers have move semantics.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>This is actually a major achievement of the Rust language: Tracking such moves at compile time requires an advanced type-system feature called <a href="http://en.wikipedia.org/wiki/Type_system#Linear_types">linear types</a>. As far as I know Rust is the only mainstreamy language which has such a feature.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

      </div>
      <div class="footer">
        <p>© Copyright 2013 by Paul Körbitz.</p>
        <p>
          Contact me via
          <a href="http://twitter.com/paulkoer">twitter</a> or
          <a href="http://github.com/paulkoerbitz">github</a>.
        </p>
        <p>Site generated by the great static site generator <a href="http://jaspervdj.be/hakyll">Hakyll</a>.</p>
      </div>
    </div>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-20755947-1']);
      _gaq.push(['_setDomainName', 'paulkoerbitz.de']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>  
