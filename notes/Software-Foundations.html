<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Types and Tailcalls - Online Book: Software Foundations</title>
    <link rel="stylesheet" href="../css/default.css" type="text/css">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <a href="../">Types and Tailcalls</a>
      </div>
      <div class="navigation">
        <ul>
          <li><a href="../">blog</a></li>
          <li><a href="../archive.html">archive</a></li>
          <li><a href="../notes.html">notes</a></li>
          <!-- 
          <li><a href="/projects.html">projects</a></li>
          -->
          <li><a href="../about.html">about</a></li>
        </ul>
      </div>
      <div class="body">
        <h1 class="title">Online Book: Software Foundations</h1>

<p class="date">written on August 14, 2013</p>

<h1 id="polymorphisim-and-higher-order-functions">Polymorphisim and Higher-Order Functions</h1>
<h3 id="polymorphic-lists">Polymorphic Lists</h3>
<p>Functions and types can be made (parametrically) polymorphic by passing the type as an argument. For example:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> <span class="dt">list</span> (<span class="dt">X:Type</span>) : <span class="dt">Type</span> :=
  | nil : <span class="dt">list</span> <span class="dt">X</span>
  | cons : <span class="dt">X</span> -&gt; <span class="dt">list</span> <span class="dt">X</span> -&gt; <span class="dt">list</span> X<span class="kw">.</span></code></pre>
<p>However, it is of course quite cumbersome to do this manually all the time. Arguments can be declared implicit as follows:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Implicit</span> <span class="dt">Arguments</span> nil [[X]]<span class="kw">.</span>
<span class="dt">Implicit</span> <span class="dt">Arguments</span> cons [[X]]<span class="kw">.</span></code></pre>
<p>Alternatively one can declare arguments as implicit when defining a function or type by surrounding them with curly braces:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Fixpoint</span> length {<span class="dt">X:Type</span>} (l:list <span class="dt">X</span>) : nat :=
  <span class="kw">match</span> l <span class="kw">with</span>
  | nil =&gt; 0
  | cons h t =&gt; <span class="dt">S</span> (length t)
  end.</code></pre>
<p>When arguments are defined implicitly, sometimes the type needs to be specified when using them</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> emptyList : <span class="dt">list</span> nat := nil.</code></pre>
<p>Or we can force implicit arguments by prefixing the function name with <code>@</code>:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> emptyList2 := @nil nat.</code></pre>
<p>With these implicit arguments in place one can define more convenient syntax:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Notation</span> <span class="st">&quot;x :: y&quot;</span> := (cons x y)
                     (at level 60, right associativity).
<span class="dt">Notation</span> <span class="st">&quot;[ ]&quot;</span> := nil.
<span class="dt">Notation</span> <span class="st">&quot;[x , .. , y ]&quot;</span> := (cons x .. (cons y []) ..).</code></pre>
<p>allowing</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> myList := [1, 2, 3].</code></pre>
<h3 id="polymorphic-pairs">Polymorphic Pairs</h3>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> prod (<span class="dt">X</span> <span class="dt">Y</span> : <span class="dt">Type</span>) : <span class="dt">Type</span> :=
  pair : <span class="dt">X</span> -&gt; <span class="dt">Y</span> -&gt; prod <span class="dt">X</span> Y<span class="kw">.</span>
<span class="dt">Implicit</span> <span class="dt">Arguments</span> pair [[<span class="dt">X]</span> [Y]]<span class="kw">.</span></code></pre>
<p>Again we can define notation to make this more convenient</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Notation</span> <span class="st">&quot;( x , y )&quot;</span> := (pair x y).
<span class="dt">Notation</span> <span class="st">&quot;X * Y&quot;</span> := (prod <span class="dt">X</span> <span class="dt">Y</span>) : type_scope.</code></pre>
<p><code>: type_scope</code> tells Coq that this notation should be applied when parsing types, not code.</p>
<h3 id="polymorphic-options">Polymorphic Options</h3>
<p>These can be defined much like expected</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> <span class="dt">option</span> (<span class="dt">X:Type</span>) : <span class="dt">Type</span> :=
  | <span class="dt">Some</span> : <span class="dt">X</span> -&gt; <span class="dt">option</span> <span class="dt">X</span>
  | <span class="dt">None</span> : <span class="dt">option</span> X<span class="kw">.</span>

<span class="dt">Implicit</span> <span class="dt">Arguments</span> <span class="dt">Some</span> [[X]]<span class="kw">.</span>
<span class="dt">Implicit</span> <span class="dt">Arguments</span> <span class="dt">None</span> [[X]]<span class="kw">.</span></code></pre>
<h3 id="functions-as-data">Functions as Data</h3>
<p>Functions can be passed to other functions like so:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> thrice {<span class="dt">X:Type</span>} (f:X-&gt;X) (n:X) : <span class="dt">X</span> :=
  f (f (f n)).</code></pre>
<h3 id="partial-application">Partial application</h3>
<p>Currying seems to work like in Haskell:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> plus3 := plus 3.</code></pre>
<h3 id="anonymous-functions">Anonymous functions</h3>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Fixpoint</span> filter {<span class="dt">X:Type</span>} (f:X-&gt;bool) (l:list <span class="dt">X</span>) : <span class="dt">list</span> <span class="dt">X</span> :=
  <span class="kw">match</span> l <span class="kw">with</span>
  | []    =&gt; []
  | x::xs =&gt; <span class="kw">if</span> (f x) <span class="kw">then</span> x :: (filter f xs)
                      <span class="kw">else</span> (filter f xs)
  end.

<span class="dt">Example</span> test_filter :
  filter (<span class="kw">fun</span> x =&gt; evenb x) [1,2,3,4,5,6] = [2,4,6].
Proof<span class="kw">.</span> reflexivity. Qed<span class="kw">.</span></code></pre>
<p>This excercise gave me a hard time. I think mostly it was because I believed that induction on <em>snoc</em> would be hard and that I went about it the wrong way at first. The key was to define the extra lemma <em>map_snoc</em>, which was actually quite easy in the end.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** Show that [map] and [rev] commute.  You may need to define an</span>
<span class="co">    auxiliary lemma. *)</span>
<span class="dt">Lemma</span> map_snoc : forall (<span class="dt">X</span> <span class="dt">Y</span> : <span class="dt">Type</span>) (f : <span class="dt">X</span> -&gt; <span class="dt">Y</span>) (x : <span class="dt">X</span>) (l : <span class="dt">list</span> <span class="dt">X</span>),
  map f (snoc l x) = snoc (map f l) (f x).
Proof<span class="kw">.</span>
  intros.
  induction l <span class="kw">as</span> [|h t]. reflexivity.
  simpl. rewrite -&gt; IHt<span class="kw">.</span> reflexivity.
Qed<span class="kw">.</span>

<span class="dt">Theorem</span> map_rev : forall (<span class="dt">X</span> <span class="dt">Y</span> : <span class="dt">Type</span>) (f : <span class="dt">X</span> -&gt; <span class="dt">Y</span>) (l : <span class="dt">list</span> <span class="dt">X</span>),
  map f (rev l) = rev (map f l).
Proof<span class="kw">.</span>
  intros.
  induction l <span class="kw">as</span> [|h t]. reflexivity.
  simpl. rewrite -&gt; map_snoc. rewrite -&gt; IHt<span class="kw">.</span> reflexivity.
Qed<span class="kw">.</span></code></pre>
<h3 id="non-uniform-inductive-families-gadts">Non-Uniform Inductive Families (GADTs)</h3>
<p>Length-indexed lists.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> llist (<span class="dt">X:Type</span>) : nat -&gt; <span class="dt">Type</span> :=
  lnil  : llist <span class="dt">X</span> <span class="dt">O</span>
| lcons : forall n, <span class="dt">X</span> -&gt; llist <span class="dt">X</span> n -&gt; llist <span class="dt">X</span> (<span class="dt">S</span> n).

<span class="dt">Implicit</span> <span class="dt">Arguments</span> lnil [[X]]<span class="kw">.</span>
<span class="dt">Implicit</span> <span class="dt">Arguments</span> lcons [[<span class="dt">X]</span> [n]].</code></pre>
<hr />
<h1 id="more-about-coq">More about Coq</h1>
<h2 id="the-rewrite-tactic">The rewrite tactic</h2>
<p>The <code>rewrite</code> tactic uses one side of an equality to replace part of a goal with the other side of the equality. The arrow indicates in which way it operates. So <code>rewrite -&gt; H.</code> uses the lhs of the equality <code>H</code> to replace a part of the goal with the rhs of <code>H</code>.</p>
<h2 id="the-apply-tactic">The apply tactic</h2>
<p><code>apply</code> allows applying equations, much like rewriting would. For exmple if we have the following goal</p>
<pre><code>n : nat
m : nat
o : nat
p : nat
eq1 : n = m
eq2 : [n, o] = [n, p]
============================
 [n, o] = [n, p]</code></pre>
<p>we could use <code>rewrite -&gt; eq2. reflexivity.</code>, but we can also just do <code>apply eq2</code>.</p>
<p><code>apply</code> can also be used with <em>conditional</em> hypothesis, i.e.Â statements that are themselves implications. For example:</p>
<pre><code>n : nat
m : nat
o : nat
p : nat
eq1 : n = m
eq2 : forall q r : nat, q = r -&gt; [q, o] = [r, p]
============================
 [n, o] = [m, p]</code></pre>
<p>Now we can do <code>apply eq2.</code> and Coq will match <code>q</code> to <code>n</code>, <code>r</code> to <code>m</code> and add <code>n = m</code> to the goals.</p>
<p>When using <code>apply</code> the fact must match the goal exactly. For example, <code>apply</code> will not work if lhs and rhs are swapped.</p>
<pre><code>n : nat
H : true = beq_nat n 5
============================
 beq_nat n 5 = true</code></pre>
<p><code>apply H</code> will not work in the example above. (We can use the <code>symmetry</code> tactic to switch lhs and rhs of a goal.)</p>
<p>In contrast to <code>rewrite</code> <code>apply</code> works with whole equations (both lhs and rhs) and also works with facts that are implications (like eq2 in the example above). The fact that is <code>apply</code>ied must match the goal exactly. In situations where these two restrictions do not apply both tactics can be used. <code>apply</code> has <code>simpl</code> built in, so can save an additional call to <code>simpl</code> and also to <code>reflexivity</code>.</p>
<h2 id="the-unfold-tactic">The unfold tactic</h2>
<p>Sometimes Coq doesnât expand a function call into its definition. This is a feature (if it always would, then the goals would become too big and cumbersome. <code>unfold functionname</code> expands the definition of the function in the proof goal.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Theorem</span> override_neq : forall {<span class="dt">X:Type</span>} x1 x2 k1 k2 (f : nat-&gt;X),
  f k1 = x1 -&gt;
  beq_nat k2 k1 = <span class="kw">false</span> -&gt;
  (override f k2 x2) k1 = x1.
Proof<span class="kw">.</span>
  intros.
  unfold override.
  rewrite -&gt; H0<span class="kw">.</span>
  rewrite -&gt; H<span class="kw">.</span>
  reflexivity.
Qed<span class="kw">.</span></code></pre>
<p>There is also the inverse, <code>fold</code> which can be used to unexpand a definition.</p>
<h2 id="inversion">Inversion</h2>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> nat : <span class="dt">Type</span> :=
  | <span class="dt">O</span> : nat
  | <span class="dt">S</span> : nat -&gt; nat</code></pre>
<p>Every number has exactly one of two possible forms, either <code>O</code> or <code>S n</code>. Futhermore, it is implicitly clear that if <code>S n = S m</code> then <code>n = m</code> (this is injectivity) and that <code>S n /= O</code> for all <code>n</code> (disjointness). These principles apply to all inductively defined datatypes: They are injective and things built from distinct constructors are never equal.</p>
<p>Coqâs <code>inversion</code> tactic allows us to exploit this. Suppose we have a hypothesis <em>H</em> of the form</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">c a1 a2 ... an = d b1 b2 .. bm</code></pre>
<p><code>inversion</code> works as follows: When <code>c</code> and <code>d</code> are the same constructor then <code>a1 = b1</code> and so forth and Coq will replace the hypothesis with these and try to rewrite the goal accordingly. If <code>c</code> and <code>d</code> are different constructors then the hypothesis is a contraction and any goal is provable, thus Coq pops the current goal of the goal stack.</p>
<p>An example of a contradiction:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Theorem</span> silly6 : forall (n : nat),
     <span class="dt">S</span> n = <span class="dt">O</span> -&gt;
     2 + 2 = 5.
Proof<span class="kw">.</span>
  intros n contra. inversion contra.
Qed<span class="kw">.</span></code></pre>
<h2 id="varying-the-induction-hypothesis">Varying the Induction Hypothesis</h2>
<p>Sometimes it is better not to use <code>intro</code> too much to obtain stronger induction hypothesis. If a variable is free (not introâed) when an induction hypothesis is obtained it will have a âforallâ quantifier.</p>
<h2 id="using-tactics-in-hypothesis">Using tactics in Hypothesis</h2>
<p>A lot of tactics can also be applied to hypothesis (to get them into a form where they can be applied on the goal). This is achieved by apending an <code class="sourceCode ocaml"><span class="kw">in</span></code>. This works for <code>simpl</code>, <code>apply</code>, <code>rewrite</code> <code>symmetry</code>, and <code>unfold</code>.</p>
<h2 id="using-destruct-on-compound-expressions">Using <strong><em>destruct</em></strong> on compound expressions</h2>
<p>The <code>destruct</code> tactic can also be used to perform case analysis on compound expressions, not just a single variable. To this end we supply the compound expression as the argument to distruct, for example <code>destruct (beq_nat 3 n).</code></p>
<h2 id="the-remember-tactic">The <strong><em>remember</em></strong> Tactic</h2>
<p>Allows to remember certain expressions in a proof. This can be useful when applying other tacitcs. Coq may be a bit brutal here at times and throw away information that we still need. In that case we can use remember to keep this information around.</p>
<h2 id="the-apply-with-tactic">The <strong><em>apply â¦ with â¦</em></strong> Tactic</h2>
<p>Sometimes Coq may not be able to pattern-match certain variables when we want to apply and implication or equality. This can be achieved for example with <code>apply lemma with (m:=[c,d])</code>.</p>
<h2 id="review">Review</h2>
<p>A short overview over the tactics weâve seen so far. The ones with * have a variante with <em>in</em> which works on hypothesis.</p>
<dl>
<dt>intros</dt>
<dd><p>Moves hypothesis and variables from the goal into the proof context.</p>
</dd>
<dt>reflexivity</dt>
<dd><p>Finish a proof by recognizing equality.</p>
</dd>
<dt>simpl*</dt>
<dd><p>Apply a function definition in the goal or hypothesis.</p>
</dd>
<dt>compute*</dt>
<dd><p>Similar to simpl, but more powerful (how exactly?)</p>
</dd>
<dt>destruct</dt>
<dd><p>Do case analysis for a simple or compound expression.</p>
</dd>
<dt>induction</dt>
<dd><p>Do induction over an inductive datatype.</p>
</dd>
<dt>rewrite*</dt>
<dd><p>Uses an equality from a hypothesis or previously proven theorem to replace part of the goal (or hypothesis). <code>rewrite ... -&gt; ...</code> replaces the LHS of a theorem with its RHS, <code>rewrite ... &lt;- ...</code> works the other way around.</p>
</dd>
<dt>apply*</dt>
<dd><p>Prove a goal with an hypothesis, theorem or constructor.</p>
</dd>
<dt>apply â¦ with â¦</dt>
<dd><p>Similar to <em>apply</em> but specifies the variables that cannot be determined by pattern matching explicitly.</p>
</dd>
<dt>symmetry*</dt>
<dd><p>Flip LHS and RHS of an equality in the goal or an hypothesis.</p>
</dd>
<dt>remember (e) as x</dt>
<dd><p>Give a term another name (moves this to the hypothesis).</p>
</dd>
<dt>unfold*</dt>
<dd><p>Replace a defined constant by its right hand side (for example a function definition).</p>
</dd>
<dt>inversion</dt>
<dd><p>Use the injectivity and disjointness of inductive datatypes. For <code>c a1 ... an = d b1 ... bm</code>, if <code>c</code> and <code>d</code> are equal it moves <code>a1 = b1</code>, â¦, <code>an = bm</code> to the hypothesis. If not then a contradiction is found (=&gt; anything could be proven) and the current goal is popped of the stack.</p>
</dd>
<dt>assert (e) as H</dt>
<dd><p>introduce <em>e</em> as hypothesis <em>H</em> and adds it as additional goal.</p>
</dd>
</dl>
<h2 id="exercises">Exercises</h2>
<ul>
<li>If the type parameter is not marked as implicit, it must be provided to all constructors.</li>
</ul>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Fixpoint</span> forallb {<span class="dt">X:Type</span>} (f:X-&gt;bool) (l:list <span class="dt">X</span>) : <span class="dt">bool</span> :=
  <span class="kw">match</span> l <span class="kw">with</span>
    | [] =&gt; <span class="kw">true</span>
    | h::t =&gt; andb (f h) (forallb f t)
  end.

<span class="dt">Fixpoint</span> existsb {<span class="dt">X:Type</span>} (f:X-&gt;bool) (l:list <span class="dt">X</span>) : <span class="dt">bool</span> :=
  <span class="kw">match</span> l <span class="kw">with</span>
    | [] =&gt; <span class="kw">false</span>
    | h::t =&gt; orb (f h) (existsb f t)
  end.

<span class="dt">Definition</span> existsb' {<span class="dt">X:Type</span>} (f:X-&gt;bool) (l:list <span class="dt">X</span>) : <span class="dt">bool</span> :=
  negb (forallb (<span class="kw">fun</span> x =&gt; negb (f x)) l).

<span class="dt">Example</span> existb_alt_test : existsb' oddb [2,4,5] = <span class="kw">true</span>.
Proof<span class="kw">.</span> compute. reflexivity. Qed<span class="kw">.</span>

<span class="dt">Example</span> existb_alt_test2 : existsb' oddb [2,4,6] = <span class="kw">false</span>.
Proof<span class="kw">.</span> compute. reflexivity. Qed<span class="kw">.</span>

<span class="dt">Example</span> existb_alt_test3 : existsb' oddb [] = <span class="kw">false</span>.
Proof<span class="kw">.</span> compute. reflexivity. Qed<span class="kw">.</span>

<span class="dt">Theorem</span> andb_orb_negb: forall (x y:bool),
  orb x y = negb (andb (negb x) (negb y)).
Proof<span class="kw">.</span>
  destruct x. destruct y. simpl. reflexivity. simpl. reflexivity.
  destruct y. simpl. reflexivity. simpl. reflexivity.
Qed<span class="kw">.</span>

<span class="dt">Theorem</span> negb_involutive: forall (x:bool),
  negb (negb x) = x.
Proof<span class="kw">.</span>
  destruct x. simpl. reflexivity. simpl. reflexivity.
Qed<span class="kw">.</span>

<span class="dt">Theorem</span> existsb_eq: forall (<span class="dt">X:Type</span>) (f:X-&gt;bool) (l:list <span class="dt">X</span>),
  existsb' f l = existsb f l.
Proof<span class="kw">.</span>
  intros <span class="dt">X</span> f l.
  induction l <span class="kw">as</span> [|h t].
  <span class="dt">Case</span> <span class="st">&quot;l = []&quot;</span>. compute. reflexivity.
  <span class="dt">Case</span> <span class="st">&quot;l = h::t&quot;</span>. simpl. unfold existsb'. simpl.
    replace (forallb (<span class="kw">fun</span> x : <span class="dt">X</span> =&gt; negb (f x)) t) <span class="kw">with</span> (negb (existsb' f t)).
    rewrite &lt;- andb_orb_negb. rewrite -&gt; IHt<span class="kw">.</span> reflexivity.
    <span class="co">(* now proof what was 'replaced' *)</span>
    unfold existsb'. rewrite -&gt; negb_involutive. reflexivity.
Qed<span class="kw">.</span></code></pre>
<hr />
<h1 id="propositions-and-evidence">Propositions and Evidence</h1>
<h2 id="inductively-defined-propositions">Inductively Defined Propositions</h2>
<p>Running example: <em>beautiful numbers</em>. A number is <em>beautiful</em> if it is either 0, 3, 5, or the sum of two beautiful numbers.</p>
<p>This is also described with inference rules. In these the <em>premises</em> are put above a line and the <em>conclusion</em> is put below a line.</p>
<p>In Coq such properties can be defined as follows:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> beautiful : nat -&gt; <span class="dt">Prop</span> :=
  b_0   : beautiful 0
| b_3   : beautiful 3
| b_5   : beautiful 5
| b_sum : forall n m, beautiful n -&gt; beautiful m -&gt; beautiful (n+m).</code></pre>
<p>These rules can be <strong><em>applied</em></strong> to prove properties. The application of these rules is called <strong><em>evidence</em></strong>. For example:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Theorem</span> eight_is_beautiful: beautiful 8.
Proof<span class="kw">.</span>
  apply b_sum <span class="kw">with</span> (n:=3) (m:=5).
  apply b_3.
  apply b_5.
Qed<span class="kw">.</span></code></pre>
<h2 id="induction-over-evidence">Induction Over Evidence</h2>
<p>Since <strong><em>beautiful</em></strong> is defined inductively, we can also reason about it inductively. In an induction all the possible cases given in an inductive definition must be proven.</p>
<h2 id="from-boolean-functions-to-propositions">From Boolean Functions to Propositions</h2>
<p>We can define propositions based on boolean functions like so:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> even (n:nat) : <span class="dt">Prop</span> :=
  evenb = <span class="kw">true</span>.</code></pre>
<p>Alternatively the same property could be defined inductively:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> ev : nat -&gt; <span class="dt">Prop</span> :=
  | ev_0 : ev <span class="dt">O</span>
  | ev_SS : forall n:nat, ev n -&gt; ev (<span class="dt">S</span> (<span class="dt">S</span> n)).</code></pre>
<p>In the case of evenness, both definitions donât differ too much in how hard it is to work with them. However, it is often much easier to work with <code>Inductive</code> definitions. In some cases it might be hard or even impossible to come up with a computational (function based) definition for something that is easily defined inductively. For example for <strong>beautiful</strong> it is much easier to give an inductive definition than one based on a function.</p>
<h2 id="inversion-on-evidence">Inversion on Evidence</h2>
<p>One can also use the <code>inversion</code> tactic on evidence. The inversion tactic destructs a hypothesis (say <em>n is even</em>) and matches it against all the constructors of an inductive definition. Each of these constructors then becomes a subgoal which must be proven. Some constructors may lead to contradictory subgoals, these are discarded by inversion. In the following example inversion determines that the first constructor <em>(ev 0)</em> is impossible and discards it immediately.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Theorem</span> <span class="dt">SSev__even</span> : forall n,
  ev (<span class="dt">S</span> (<span class="dt">S</span> n)) -&gt; ev n.
Proof<span class="kw">.</span>
  intros n E<span class="kw">.</span>
  inversion <span class="dt">E</span> <span class="kw">as</span> [| n' E']<span class="kw">.</span>
  apply E'<span class="kw">.</span>
Qed<span class="kw">.</span></code></pre>
<p>I wrote my first inductive property and proved things about it ;)</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> pal {<span class="dt">X:Type</span>} : <span class="dt">list</span> <span class="dt">X</span> -&gt; <span class="dt">Prop</span> :=
  | pal_nil : pal []
  | pal_single : forall x:X, pal [x]
  | pal_cons : forall (x:X) (l:list <span class="dt">X</span>) , pal l -&gt; pal (x :: snoc l x).

<span class="dt">Theorem</span> pal_mirror : forall (<span class="dt">X:Type</span>) (l:list <span class="dt">X</span>),
  pal (l ++ rev l).
Proof<span class="kw">.</span>
  intros <span class="dt">X</span> l. induction l <span class="kw">as</span> [|h t]. simpl. apply pal_nil.
  simpl. rewrite &lt;- snoc_with_append. apply pal_cons. apply IHt<span class="kw">.</span>
Qed<span class="kw">.</span>

<span class="dt">Theorem</span> pal_rev : forall (<span class="dt">X:Type</span>) (l:list <span class="dt">X</span>),
  pal l -&gt; l = rev l.
Proof<span class="kw">.</span>
  intros <span class="dt">X</span> l H<span class="kw">.</span> induction H<span class="kw">.</span> simpl. reflexivity. simpl. reflexivity.
  simpl. rewrite -&gt; rev_snoc. simpl. rewrite &lt;- IHpal<span class="kw">.</span> reflexivity.
Qed<span class="kw">.</span></code></pre>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

      </div>
      <div class="footer">
        <p>Â© Copyright 2013 by Paul KÃ¶rbitz.</p>
        <p>
          Contact me via
          <a href="http://twitter.com/paulkoer">twitter</a> or
          <a href="http://github.com/paulkoerbitz">github</a>.
        </p>
        <p>Site generated by the great static site generator <a href="http://jaspervdj.be/hakyll">Hakyll</a>.</p>
      </div>
    </div>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-20755947-1']);
      _gaq.push(['_setDomainName', 'paulkoerbitz.de']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>  
