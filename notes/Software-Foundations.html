<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Types and Tailcalls - Online Book: Sofware Foundations</title>
    <link rel="stylesheet" href="../css/default.css" type="text/css">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <a href="../">Types and Tailcalls</a>
      </div>
      <div class="navigation">
        <ul>
          <li><a href="../">blog</a></li>
          <li><a href="../archive.html">archive</a></li>
          <li><a href="../notes.html">notes</a></li>
          <!-- 
          <li><a href="/projects.html">projects</a></li>
          -->
          <li><a href="../about.html">about</a></li>
        </ul>
      </div>
      <div class="body">
        <h1 class="title">Online Book: Sofware Foundations</h1>

<p class="date">written on August  5, 2013</p>

<h2 id="polymorphisim-and-higher-order-functions">Polymorphisim and Higher-Order Functions</h2>
<h3 id="polymorphic-lists">Polymorphic Lists</h3>
<p>Functions and types can be made (parametrically) polymorphic by passing the type as an argument. For example:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> <span class="dt">list</span> (<span class="dt">X:Type</span>) : <span class="dt">Type</span> :=
  | nil : <span class="dt">list</span> <span class="dt">X</span>
  | cons : <span class="dt">X</span> -&gt; <span class="dt">list</span> <span class="dt">X</span> -&gt; <span class="dt">list</span> X<span class="kw">.</span></code></pre>
<p>However, it is of course quite cumbersome to do this manually all the time. Arguments can be declared implicit as follows:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Implicit</span> <span class="dt">Arguments</span> nil [[X]]<span class="kw">.</span>
<span class="dt">Implicit</span> <span class="dt">Arguments</span> cons [[X]]<span class="kw">.</span></code></pre>
<p>Alternatively one can declare arguments as implicit when defining a function or type by surrounding them with curly braces:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Fixpoint</span> length {<span class="dt">X:Type</span>} (l:list <span class="dt">X</span>) : nat :=
  <span class="kw">match</span> l <span class="kw">with</span>
  | nil =&gt; 0
  | cons h t =&gt; <span class="dt">S</span> (length t)
  end.</code></pre>
<p>When arguments are defined implicitly, sometimes the type needs to be specified when using them</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> emptyList : <span class="dt">list</span> nat := nil.</code></pre>
<p>Or we can force implicit arguments by prefixing the function name with <code>@</code>:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> emptyList2 := @nil nat.</code></pre>
<p>With these implicit arguments in place one can define more convenient syntax:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Notation</span> <span class="st">&quot;x :: y&quot;</span> := (cons x y)
                     (at level 60, right associativity).
<span class="dt">Notation</span> <span class="st">&quot;[ ]&quot;</span> := nil.
<span class="dt">Notation</span> <span class="st">&quot;[x , .. , y ]&quot;</span> := (cons x .. (cons y []) ..).</code></pre>
<p>allowing</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> myList := [1, 2, 3].</code></pre>
<h3 id="polymorphic-pairs">Polymorphic Pairs</h3>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> prod (<span class="dt">X</span> <span class="dt">Y</span> : <span class="dt">Type</span>) : <span class="dt">Type</span> :=
  pair : <span class="dt">X</span> -&gt; <span class="dt">Y</span> -&gt; prod <span class="dt">X</span> Y<span class="kw">.</span>
<span class="dt">Implicit</span> <span class="dt">Arguments</span> pair [[<span class="dt">X]</span> [Y]]<span class="kw">.</span></code></pre>
<p>Again we can define notation to make this more convenient</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Notation</span> <span class="st">&quot;( x , y )&quot;</span> := (pair x y).
<span class="dt">Notation</span> <span class="st">&quot;X * Y&quot;</span> := (prod <span class="dt">X</span> <span class="dt">Y</span>) : type_scope.</code></pre>
<p><code>: type_scope</code> tells Coq that this notation should be applied when parsing types, not code.</p>
<h3 id="polymorphic-options">Polymorphic Options</h3>
<p>These can be defined much like expected</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> <span class="dt">option</span> (<span class="dt">X:Type</span>) : <span class="dt">Type</span> :=
  | <span class="dt">Some</span> : <span class="dt">X</span> -&gt; <span class="dt">option</span> <span class="dt">X</span>
  | <span class="dt">None</span> : <span class="dt">option</span> X<span class="kw">.</span>

<span class="dt">Implicit</span> <span class="dt">Arguments</span> <span class="dt">Some</span> [[X]]<span class="kw">.</span>
<span class="dt">Implicit</span> <span class="dt">Arguments</span> <span class="dt">None</span> [[X]]<span class="kw">.</span></code></pre>
<h3 id="functions-as-data">Functions as Data</h3>
<p>Functions can be passed to other functions like so:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> thrice {<span class="dt">X:Type</span>} (f:X-&gt;X) (n:X) : <span class="dt">X</span> :=
  f (f (f n)).</code></pre>
<h3 id="partial-application">Partial application</h3>
<p>Currying seems to work like in Haskell:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Definition</span> plus3 := plus 3.</code></pre>
<h3 id="anonymous-functions">Anonymous functions</h3>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Fixpoint</span> filter {<span class="dt">X:Type</span>} (f:X-&gt;bool) (l:list <span class="dt">X</span>) : <span class="dt">list</span> <span class="dt">X</span> :=
  <span class="kw">match</span> l <span class="kw">with</span>
  | []    =&gt; []
  | x::xs =&gt; <span class="kw">if</span> (f x) <span class="kw">then</span> x :: (filter f xs)
                      <span class="kw">else</span> (filter f xs)
  end.

<span class="dt">Example</span> test_filter :
  filter (<span class="kw">fun</span> x =&gt; evenb x) [1,2,3,4,5,6] = [2,4,6].
Proof<span class="kw">.</span> reflexivity. Qed<span class="kw">.</span></code></pre>
<p>This excercise gave me a hard time. I think mostly it was because I believed that induction on <em>snoc</em> would be hard and that I went about it the wrong way at first. The key was to define the extra lemma <em>map_snoc</em>, which was actually quite easy in the end.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** Show that [map] and [rev] commute.  You may need to define an</span>
<span class="co">    auxiliary lemma. *)</span>
<span class="dt">Lemma</span> map_snoc : forall (<span class="dt">X</span> <span class="dt">Y</span> : <span class="dt">Type</span>) (f : <span class="dt">X</span> -&gt; <span class="dt">Y</span>) (x : <span class="dt">X</span>) (l : <span class="dt">list</span> <span class="dt">X</span>),
  map f (snoc l x) = snoc (map f l) (f x).
Proof<span class="kw">.</span>
  intros.
  induction l <span class="kw">as</span> [|h t]. reflexivity.
  simpl. rewrite -&gt; IHt<span class="kw">.</span> reflexivity.
Qed<span class="kw">.</span>

<span class="dt">Theorem</span> map_rev : forall (<span class="dt">X</span> <span class="dt">Y</span> : <span class="dt">Type</span>) (f : <span class="dt">X</span> -&gt; <span class="dt">Y</span>) (l : <span class="dt">list</span> <span class="dt">X</span>),
  map f (rev l) = rev (map f l).
Proof<span class="kw">.</span>
  intros.
  induction l <span class="kw">as</span> [|h t]. reflexivity.
  simpl. rewrite -&gt; map_snoc. rewrite -&gt; IHt<span class="kw">.</span> reflexivity.
Qed<span class="kw">.</span></code></pre>
<h3 id="non-uniform-inductive-families-gadts">Non-Uniform Inductive Families (GADTs)</h3>
<p>Length-indexed lists.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Inductive</span> llist (<span class="dt">X:Type</span>) : nat -&gt; <span class="dt">Type</span> :=
  lnil  : llist <span class="dt">X</span> <span class="dt">O</span>
| lcons : forall n, <span class="dt">X</span> -&gt; llist <span class="dt">X</span> n -&gt; llist <span class="dt">X</span> (<span class="dt">S</span> n).

<span class="dt">Implicit</span> <span class="dt">Arguments</span> lnil [[X]]<span class="kw">.</span>
<span class="dt">Implicit</span> <span class="dt">Arguments</span> lcons [[<span class="dt">X]</span> [n]].</code></pre>
<h3 id="more-about-coq">More about Coq</h3>
<h4 id="the-rewrite-tactic">The rewrite tactic</h4>
<p>The <code>rewrite</code> tactic uses one side of an equality to replace part of a goal with the other side of the equality. The arrow indicates in which way it operates. So <code>rewrite -&gt; H.</code> uses the lhs of the equality <code>H</code> to replace a part of the goal with the rhs of <code>H</code>.</p>
<h4 id="the-apply-tactic">The apply tactic</h4>
<p><code>apply</code> allows applying equations, much like rewriting would. For exmple if we have the following goal</p>
<pre><code>n : nat
m : nat
o : nat
p : nat
eq1 : n = m
eq2 : [n, o] = [n, p]
============================
 [n, o] = [n, p]</code></pre>
<p>we could use <code>rewrite -&gt; eq2. reflexivity.</code>, but we can also just do <code>apply eq2</code>.</p>
<p><code>apply</code> can also be used with <em>conditional</em> hypothesis, i.e. statements that are themselves implications. For example:</p>
<pre><code>n : nat
m : nat
o : nat
p : nat
eq1 : n = m
eq2 : forall q r : nat, q = r -&gt; [q, o] = [r, p]
============================
 [n, o] = [m, p]</code></pre>
<p>Now we can do <code>apply eq2.</code> and Coq will match <code>q</code> to <code>n</code>, <code>r</code> to <code>m</code> and add <code>n = m</code> to the goals.</p>
<p>When using <code>apply</code> the fact must match the goal exactly. For example, <code>apply</code> will not work if lhs and rhs are swapped.</p>
<pre><code>n : nat
H : true = beq_nat n 5
============================
 beq_nat n 5 = true</code></pre>
<p><code>apply H</code> will not work in the example above. (We can use the <code>symmetry</code> tactic to switch lhs and rhs of a goal.)</p>
<p>In contrast to <code>rewrite</code> <code>apply</code> works with whole equations (both lhs and rhs) and also works with facts that are implications (like eq2 in the example above). The fact that is <code>apply</code>ied must match the goal exactly. In situations where these two restrictions do not apply both tactics can be used. <code>apply</code> has <code>simpl</code> built in, so can save an additional call to <code>simpl</code> and also to <code>reflexivity</code>.</p>
<h4 id="the-unfold-tactic">The unfold tactic</h4>

<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

      </div>
      <div class="footer">
        <p>© Copyright 2013 by Paul Körbitz.</p>
        <p>
          Contact me via
          <a href="http://twitter.com/paulkoer">twitter</a> or
          <a href="http://github.com/paulkoerbitz">github</a>.
        </p>
        <p>Site generated by the great static site generator <a href="http://jaspervdj.be/hakyll">Hakyll</a>.</p>
      </div>
    </div>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-20755947-1']);
      _gaq.push(['_setDomainName', 'paulkoerbitz.de']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>  
