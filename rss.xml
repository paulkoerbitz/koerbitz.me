<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Types and Tailcalls: Yet Another Programmer's Blog by Paul Koerbitz</title>
        <link>http://koerbitz.me</link>
        <description><![CDATA[Thoughts and ideas about programming, with an eye towards functional programming techniques]]></description>
        <atom:link href="http://koerbitz.me/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 01 Dec 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Understanding the react-redux connection function</title>
    <link>http://koerbitz.me/posts/Understanding-the-react-redux-connect-function.html</link>
    <description><![CDATA[<h1 class="title">Understanding the react-redux connection function</h1>

<p class="date">published on December  1, 2016</p>

<p>As described in the <a href="http://koerbitz.me/posts/Trying-and-failing-to-make-redux-connect-type-safe.html">last post</a>, I tried and failed to write a type safe wrapper for the <a href="https://github.com/reactjs/react-redux/blob/master/src/components/connect.js">react-redux</a> connect function. In this post, I want to examine this function with a view towards writing a type safe replacement in the future. To do so I’m examining the <code>connect.js</code> module of react-redux version 4.4.32.</p>
<p>The first 33 lines are prelude, defining some helper functions and objects, nothing too special. I’m not really sure how <code>nextVersion</code> helps with code reloading, we’ll hopefully figure this out as we’ll move along.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span> Component<span class="op">,</span> createElement <span class="op">}</span> <span class="im">from</span> <span class="st">&#39;react&#39;</span>
<span class="im">import</span> storeShape <span class="im">from</span> <span class="st">&#39;../utils/storeShape&#39;</span>
<span class="im">import</span> shallowEqual <span class="im">from</span> <span class="st">&#39;../utils/shallowEqual&#39;</span>
<span class="im">import</span> wrapActionCreators <span class="im">from</span> <span class="st">&#39;../utils/wrapActionCreators&#39;</span>
<span class="im">import</span> warning <span class="im">from</span> <span class="st">&#39;../utils/warning&#39;</span>
<span class="im">import</span> isPlainObject <span class="im">from</span> <span class="st">&#39;lodash/isPlainObject&#39;</span>
<span class="im">import</span> hoistStatics <span class="im">from</span> <span class="st">&#39;hoist-non-react-statics&#39;</span>
<span class="im">import</span> invariant <span class="im">from</span> <span class="st">&#39;invariant&#39;</span>

<span class="kw">const</span> defaultMapStateToProps <span class="op">=</span> state <span class="op">=&gt;</span> (<span class="op">{}</span>) <span class="co">// eslint-disable-line no-unused-vars</span>
<span class="kw">const</span> defaultMapDispatchToProps <span class="op">=</span> dispatch <span class="op">=&gt;</span> (<span class="op">{</span> dispatch <span class="op">}</span>)
<span class="kw">const</span> defaultMergeProps <span class="op">=</span> (stateProps<span class="op">,</span> dispatchProps<span class="op">,</span> parentProps) <span class="op">=&gt;</span> (<span class="op">{</span>
  ...<span class="at">parentProps</span><span class="op">,</span>
  ...<span class="at">stateProps</span><span class="op">,</span>
  ...<span class="at">dispatchProps</span>
<span class="op">}</span>)

<span class="kw">function</span> <span class="at">getDisplayName</span>(WrappedComponent) <span class="op">{</span>
  <span class="cf">return</span> <span class="va">WrappedComponent</span>.<span class="at">displayName</span> <span class="op">||</span> <span class="va">WrappedComponent</span>.<span class="at">name</span> <span class="op">||</span> <span class="st">&#39;Component&#39;</span>
<span class="op">}</span>

<span class="kw">let</span> errorObject <span class="op">=</span> <span class="op">{</span> <span class="dt">value</span><span class="op">:</span> <span class="kw">null</span> <span class="op">}</span>
<span class="kw">function</span> <span class="at">tryCatch</span>(fn<span class="op">,</span> ctx) <span class="op">{</span>
  <span class="cf">try</span> <span class="op">{</span>
    <span class="cf">return</span> <span class="va">fn</span>.<span class="at">apply</span>(ctx)
  <span class="op">}</span> <span class="cf">catch</span> (e) <span class="op">{</span>
    <span class="va">errorObject</span>.<span class="at">value</span> <span class="op">=</span> e
    <span class="cf">return</span> errorObject
  <span class="op">}</span>
<span class="op">}</span>

<span class="co">// Helps track hot reloading.</span>
<span class="kw">let</span> nextVersion <span class="op">=</span> <span class="dv">0</span></code></pre></div>
<p>Next, we’ll move on to define the <code>connect</code> function, which is obviously the heart of this module. The start of this function is again some prelude, where we figure out which parameters are passed and assign default values for the ones not present. One interesting part is maybe that the presence of <code>mapStateToProps</code> determines (via <code>shouldSubscribe</code>) if the new component subscribes to store changes or not.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="at">connect</span>(mapStateToProps<span class="op">,</span> mapDispatchToProps<span class="op">,</span> mergeProps<span class="op">,</span> options <span class="op">=</span> <span class="op">{}</span>) <span class="op">{</span>
  <span class="kw">const</span> shouldSubscribe <span class="op">=</span> <span class="at">Boolean</span>(mapStateToProps)
  <span class="kw">const</span> mapState <span class="op">=</span> mapStateToProps <span class="op">||</span> defaultMapStateToProps

  <span class="kw">let</span> mapDispatch
  <span class="cf">if</span> (<span class="kw">typeof</span> mapDispatchToProps <span class="op">===</span> <span class="st">&#39;function&#39;</span>) <span class="op">{</span>
    mapDispatch <span class="op">=</span> mapDispatchToProps
  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="op">!</span>mapDispatchToProps) <span class="op">{</span>
    mapDispatch <span class="op">=</span> defaultMapDispatchToProps
  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
    mapDispatch <span class="op">=</span> <span class="at">wrapActionCreators</span>(mapDispatchToProps)
  <span class="op">}</span>

  <span class="kw">const</span> finalMergeProps <span class="op">=</span> mergeProps <span class="op">||</span> defaultMergeProps
  <span class="kw">const</span> <span class="op">{</span> pure <span class="op">=</span> <span class="kw">true</span><span class="op">,</span> withRef <span class="op">=</span> <span class="kw">false</span> <span class="op">}</span> <span class="op">=</span> options
  <span class="kw">const</span> checkMergedEquals <span class="op">=</span> pure <span class="op">&amp;&amp;</span> finalMergeProps <span class="op">!==</span> defaultMergeProps

  <span class="co">// Helps track hot reloading.</span>
  <span class="kw">const</span> version <span class="op">=</span> nextVersion<span class="op">++</span></code></pre></div>
<p>The way the <code>connect</code> function should be called is <code>connect(mapStateToProps, mapDispatchToProps)(Component)</code>, so it must return a function which receives the component which we want to wrap. This is what happens on line 55. <code>connectDisplayName</code> and <code>checkStateShape</code> are helper variables / functions for error messages.</p>
<p>The <code>computeMergedProps</code> function is basically a wrapper around the mergeProps function which is the user defined merged props or a default version. The only difference is that it checks in non-production environments if the final props object has the right shape.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">  <span class="cf">return</span> <span class="kw">function</span> <span class="at">wrapWithConnect</span>(WrappedComponent) <span class="op">{</span>
    <span class="kw">const</span> connectDisplayName <span class="op">=</span> <span class="vs">`Connect(</span><span class="sc">${</span><span class="at">getDisplayName</span>(WrappedComponent)<span class="sc">}</span><span class="vs">)`</span>

    <span class="kw">function</span> <span class="at">checkStateShape</span>(props<span class="op">,</span> methodName) <span class="op">{</span>
      <span class="cf">if</span> (<span class="op">!</span><span class="at">isPlainObject</span>(props)) <span class="op">{</span>
        <span class="at">warning</span>(
          <span class="vs">`</span><span class="sc">${</span>methodName<span class="sc">}</span><span class="vs">() in </span><span class="sc">${</span>connectDisplayName<span class="sc">}</span><span class="vs"> must return a plain object. `</span> <span class="op">+</span>
          <span class="vs">`Instead received </span><span class="sc">${</span>props<span class="sc">}</span><span class="vs">.`</span>
        )
      <span class="op">}</span>
    <span class="op">}</span>

    <span class="kw">function</span> <span class="at">computeMergedProps</span>(stateProps<span class="op">,</span> dispatchProps<span class="op">,</span> parentProps) <span class="op">{</span>
      <span class="kw">const</span> mergedProps <span class="op">=</span> <span class="at">finalMergeProps</span>(stateProps<span class="op">,</span> dispatchProps<span class="op">,</span> parentProps)
      <span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&#39;production&#39;</span>) <span class="op">{</span>
        <span class="at">checkStateShape</span>(mergedProps<span class="op">,</span> <span class="st">&#39;mergeProps&#39;</span>)
      <span class="op">}</span>
      <span class="cf">return</span> mergedProps
    <span class="op">}</span></code></pre></div>
<p>Now we get into the heart of the matter - creating the new react component which we’ll return from the <code>wrapWithConnect</code> function. The <code>shouldComponentUpdate</code> method already reveals some key information about the optimizations that this container performs - we’ll update if we’re either not pure, some of our properties have changed or if the store state has changed. Looks sensible ;)</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">class</span> Connect <span class="kw">extends</span> Component <span class="op">{</span>
      <span class="at">shouldComponentUpdate</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="op">!</span>pure <span class="op">||</span> <span class="kw">this</span>.<span class="at">haveOwnPropsChanged</span> <span class="op">||</span> <span class="kw">this</span>.<span class="at">hasStoreStateChanged</span>
      <span class="op">}</span>

      <span class="at">constructor</span>(props<span class="op">,</span> context) <span class="op">{</span>
        <span class="kw">super</span>(props<span class="op">,</span> context)
        <span class="kw">this</span>.<span class="at">version</span> <span class="op">=</span> version
        <span class="kw">this</span>.<span class="at">store</span> <span class="op">=</span> <span class="va">props</span>.<span class="at">store</span> <span class="op">||</span> <span class="va">context</span>.<span class="at">store</span>

        <span class="at">invariant</span>(<span class="kw">this</span>.<span class="at">store</span><span class="op">,</span>
          <span class="vs">`Could not find &quot;store&quot; in either the context or `</span> <span class="op">+</span>
          <span class="vs">`props of &quot;</span><span class="sc">${</span>connectDisplayName<span class="sc">}</span><span class="vs">&quot;. `</span> <span class="op">+</span>
          <span class="vs">`Either wrap the root component in a &lt;Provider&gt;, `</span> <span class="op">+</span>
          <span class="vs">`or explicitly pass &quot;store&quot; as a prop to &quot;</span><span class="sc">${</span>connectDisplayName<span class="sc">}</span><span class="vs">&quot;.`</span>
        )

        <span class="kw">const</span> storeState <span class="op">=</span> <span class="kw">this</span>.<span class="va">store</span>.<span class="at">getState</span>()
        <span class="kw">this</span>.<span class="at">state</span> <span class="op">=</span> <span class="op">{</span> storeState <span class="op">}</span>
        <span class="kw">this</span>.<span class="at">clearCache</span>()
      <span class="op">}</span></code></pre></div>
<p>This class contains a lot of methods which are concerned with figuring out how to compute the right state from the <code>mapStateToProps</code> and <code>mapDispatchToProps</code> methods. Let’s first take a look at <code>computeStateProps</code> and <code>configureFinalMapState</code> as there seems to be a lot going on here.</p>
<p>The <code>configureFinalMapState</code> method is used to install the <code>finalMapStateToProps</code> method and is called from <code>computeStateProps</code> if it is not already present. It calls <code>mapState</code> on the state and the props, if this returns a function<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> that function is set as <code>finalMapStateToProps</code> and <code>computeStateProps</code> is called, otherwise <code>mapState</code> is used as the <code>finalMapStateToProps</code> and the result of the first call to <code>mapStateToProps</code> is returned. It helps that <code>configureFinalMapState</code> is only ever called from <code>computeStateProps</code>, so it is really an initialization method that should run at most once. I am not sure if the <em>optimization</em> of only installing the <code>finalMapStateToProps</code> property in the <code>computeStateProps</code> method, or the different magic cases are really needed, but that’s what we have.</p>
<p>The only place where <code>computeStateProps</code> is called from is the <code>updateStatePropsIfNeeded</code> method, we will look at this functions purpose in a minute.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      <span class="at">computeStateProps</span>(store<span class="op">,</span> props) <span class="op">{</span>
        <span class="cf">if</span> (<span class="op">!</span><span class="kw">this</span>.<span class="at">finalMapStateToProps</span>) <span class="op">{</span>
          <span class="cf">return</span> <span class="kw">this</span>.<span class="at">configureFinalMapState</span>(store<span class="op">,</span> props)
        <span class="op">}</span>

        <span class="kw">const</span> state <span class="op">=</span> <span class="va">store</span>.<span class="at">getState</span>()
        <span class="kw">const</span> stateProps <span class="op">=</span> <span class="kw">this</span>.<span class="at">doStatePropsDependOnOwnProps</span> <span class="op">?</span>
          <span class="kw">this</span>.<span class="at">finalMapStateToProps</span>(state<span class="op">,</span> props) :
          <span class="kw">this</span>.<span class="at">finalMapStateToProps</span>(state)

        <span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&#39;production&#39;</span>) <span class="op">{</span>
          <span class="at">checkStateShape</span>(stateProps<span class="op">,</span> <span class="st">&#39;mapStateToProps&#39;</span>)
        <span class="op">}</span>
        <span class="cf">return</span> stateProps
      <span class="op">}</span>

      <span class="at">configureFinalMapState</span>(store<span class="op">,</span> props) <span class="op">{</span>
        <span class="kw">const</span> mappedState <span class="op">=</span> <span class="at">mapState</span>(<span class="va">store</span>.<span class="at">getState</span>()<span class="op">,</span> props)
        <span class="kw">const</span> isFactory <span class="op">=</span> <span class="kw">typeof</span> mappedState <span class="op">===</span> <span class="st">&#39;function&#39;</span>

        <span class="kw">this</span>.<span class="at">finalMapStateToProps</span> <span class="op">=</span> isFactory <span class="op">?</span> mappedState : mapState
        <span class="kw">this</span>.<span class="at">doStatePropsDependOnOwnProps</span> <span class="op">=</span> <span class="kw">this</span>.<span class="va">finalMapStateToProps</span>.<span class="at">length</span> <span class="op">!==</span> <span class="dv">1</span>

        <span class="cf">if</span> (isFactory) <span class="op">{</span>
          <span class="cf">return</span> <span class="kw">this</span>.<span class="at">computeStateProps</span>(store<span class="op">,</span> props)
        <span class="op">}</span>

        <span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&#39;production&#39;</span>) <span class="op">{</span>
          <span class="at">checkStateShape</span>(mappedState<span class="op">,</span> <span class="st">&#39;mapStateToProps&#39;</span>)
        <span class="op">}</span>
        <span class="cf">return</span> mappedState
      <span class="op">}</span></code></pre></div>
<p>The <code>computeDispatchProps</code> and <code>configureFinalMapDispatch</code> methods follow the same pattern as the <code>computeStateProps</code> and <code>configureFinalMapStat</code> methods above. In fact, they could almost be copied-and-pasted. <code>computeDispatchProps</code> first installs the <code>finalMapDispatchToProps</code> property by calling <code>configureFinalMapDispatch</code> method, if it is not already present. Analogously to the case above, the <code>configureFinalMapDispatch</code> method checks if <code>mapDispatch</code> returns a function and in this case installs that or <code>mapDispatch</code> as the <code>finalMapDispatchToProps</code> property. Again, <code>computeDispatchProps</code> is only ever called from the <code>updateDispatchPropsIfNeeded</code> method.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      <span class="at">computeDispatchProps</span>(store<span class="op">,</span> props) <span class="op">{</span>
        <span class="cf">if</span> (<span class="op">!</span><span class="kw">this</span>.<span class="at">finalMapDispatchToProps</span>) <span class="op">{</span>
          <span class="cf">return</span> <span class="kw">this</span>.<span class="at">configureFinalMapDispatch</span>(store<span class="op">,</span> props)
        <span class="op">}</span>

        <span class="kw">const</span> <span class="op">{</span> dispatch <span class="op">}</span> <span class="op">=</span> store
        <span class="kw">const</span> dispatchProps <span class="op">=</span> <span class="kw">this</span>.<span class="at">doDispatchPropsDependOnOwnProps</span> <span class="op">?</span>
          <span class="kw">this</span>.<span class="at">finalMapDispatchToProps</span>(dispatch<span class="op">,</span> props) :
          <span class="kw">this</span>.<span class="at">finalMapDispatchToProps</span>(dispatch)

        <span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&#39;production&#39;</span>) <span class="op">{</span>
          <span class="at">checkStateShape</span>(dispatchProps<span class="op">,</span> <span class="st">&#39;mapDispatchToProps&#39;</span>)
        <span class="op">}</span>
        <span class="cf">return</span> dispatchProps
      <span class="op">}</span>

      <span class="at">configureFinalMapDispatch</span>(store<span class="op">,</span> props) <span class="op">{</span>
        <span class="kw">const</span> mappedDispatch <span class="op">=</span> <span class="at">mapDispatch</span>(<span class="va">store</span>.<span class="at">dispatch</span><span class="op">,</span> props)
        <span class="kw">const</span> isFactory <span class="op">=</span> <span class="kw">typeof</span> mappedDispatch <span class="op">===</span> <span class="st">&#39;function&#39;</span>

        <span class="kw">this</span>.<span class="at">finalMapDispatchToProps</span> <span class="op">=</span> isFactory <span class="op">?</span> mappedDispatch : mapDispatch
        <span class="kw">this</span>.<span class="at">doDispatchPropsDependOnOwnProps</span> <span class="op">=</span> <span class="kw">this</span>.<span class="va">finalMapDispatchToProps</span>.<span class="at">length</span> <span class="op">!==</span> <span class="dv">1</span>

        <span class="cf">if</span> (isFactory) <span class="op">{</span>
          <span class="cf">return</span> <span class="kw">this</span>.<span class="at">computeDispatchProps</span>(store<span class="op">,</span> props)
        <span class="op">}</span>

        <span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&#39;production&#39;</span>) <span class="op">{</span>
          <span class="at">checkStateShape</span>(mappedDispatch<span class="op">,</span> <span class="st">&#39;mapDispatchToProps&#39;</span>)
        <span class="op">}</span>
        <span class="cf">return</span> mappedDispatch
      <span class="op">}</span></code></pre></div>
<p>Next up are three <code>updateXYZPropsIfNeeded</code> methods, where <code>XYZ</code> is either <code>State</code>, <code>Dispatch</code> or <code>Merge</code>. These always compute the new part of the properties, but only update the cached version on the object, if they are not <code>shallowEqual</code> to the currently cached version. If no update is performed, they return false, otherwise they return true.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      <span class="at">updateStatePropsIfNeeded</span>() <span class="op">{</span>
        <span class="kw">const</span> nextStateProps <span class="op">=</span> <span class="kw">this</span>.<span class="at">computeStateProps</span>(<span class="kw">this</span>.<span class="at">store</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">props</span>)
        <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">stateProps</span> <span class="op">&amp;&amp;</span> <span class="at">shallowEqual</span>(nextStateProps<span class="op">,</span> <span class="kw">this</span>.<span class="at">stateProps</span>)) <span class="op">{</span>
          <span class="cf">return</span> <span class="kw">false</span>
        <span class="op">}</span>

        <span class="kw">this</span>.<span class="at">stateProps</span> <span class="op">=</span> nextStateProps
        <span class="cf">return</span> <span class="kw">true</span>
      <span class="op">}</span>

      <span class="at">updateDispatchPropsIfNeeded</span>() <span class="op">{</span>
        <span class="kw">const</span> nextDispatchProps <span class="op">=</span> <span class="kw">this</span>.<span class="at">computeDispatchProps</span>(<span class="kw">this</span>.<span class="at">store</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">props</span>)
        <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">dispatchProps</span> <span class="op">&amp;&amp;</span> <span class="at">shallowEqual</span>(nextDispatchProps<span class="op">,</span> <span class="kw">this</span>.<span class="at">dispatchProps</span>)) <span class="op">{</span>
          <span class="cf">return</span> <span class="kw">false</span>
        <span class="op">}</span>

        <span class="kw">this</span>.<span class="at">dispatchProps</span> <span class="op">=</span> nextDispatchProps
        <span class="cf">return</span> <span class="kw">true</span>
      <span class="op">}</span>

      <span class="at">updateMergedPropsIfNeeded</span>() <span class="op">{</span>
        <span class="kw">const</span> nextMergedProps <span class="op">=</span> <span class="at">computeMergedProps</span>(<span class="kw">this</span>.<span class="at">stateProps</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">dispatchProps</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">props</span>)
        <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">mergedProps</span> <span class="op">&amp;&amp;</span> checkMergedEquals <span class="op">&amp;&amp;</span> <span class="at">shallowEqual</span>(nextMergedProps<span class="op">,</span> <span class="kw">this</span>.<span class="at">mergedProps</span>)) <span class="op">{</span>
          <span class="cf">return</span> <span class="kw">false</span>
        <span class="op">}</span>

        <span class="kw">this</span>.<span class="at">mergedProps</span> <span class="op">=</span> nextMergedProps
        <span class="cf">return</span> <span class="kw">true</span>
      <span class="op">}</span></code></pre></div>
<p>The other large block of methods are methods for managing subscriptions and the lifecycle <code>componentDidMount</code>, <code>componentWillUnmount</code> and <code>componentWillReceiveProps</code> methods. In the later <code>haveOwnPropsChanged</code> is set to true if the component is either marked as not pure of if the new props are not shallow equal to the old ones.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      <span class="at">isSubscribed</span>() <span class="op">{</span>
        <span class="cf">return</span> <span class="kw">typeof</span> <span class="kw">this</span>.<span class="at">unsubscribe</span> <span class="op">===</span> <span class="st">&#39;function&#39;</span>
      <span class="op">}</span>

      <span class="at">trySubscribe</span>() <span class="op">{</span>
        <span class="cf">if</span> (shouldSubscribe <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="kw">this</span>.<span class="at">unsubscribe</span>) <span class="op">{</span>
          <span class="kw">this</span>.<span class="at">unsubscribe</span> <span class="op">=</span> <span class="kw">this</span>.<span class="va">store</span>.<span class="at">subscribe</span>(<span class="kw">this</span>.<span class="va">handleChange</span>.<span class="at">bind</span>(<span class="kw">this</span>))
          <span class="kw">this</span>.<span class="at">handleChange</span>()
        <span class="op">}</span>
      <span class="op">}</span>

      <span class="at">tryUnsubscribe</span>() <span class="op">{</span>
        <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">unsubscribe</span>) <span class="op">{</span>
          <span class="kw">this</span>.<span class="at">unsubscribe</span>()
          <span class="kw">this</span>.<span class="at">unsubscribe</span> <span class="op">=</span> <span class="kw">null</span>
        <span class="op">}</span>
      <span class="op">}</span>

      <span class="at">componentDidMount</span>() <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">trySubscribe</span>()
      <span class="op">}</span>

      <span class="at">componentWillReceiveProps</span>(nextProps) <span class="op">{</span>
        <span class="cf">if</span> (<span class="op">!</span>pure <span class="op">||</span> <span class="op">!</span><span class="at">shallowEqual</span>(nextProps<span class="op">,</span> <span class="kw">this</span>.<span class="at">props</span>)) <span class="op">{</span>
          <span class="kw">this</span>.<span class="at">haveOwnPropsChanged</span> <span class="op">=</span> <span class="kw">true</span>
        <span class="op">}</span>
      <span class="op">}</span>

      <span class="at">componentWillUnmount</span>() <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">tryUnsubscribe</span>()
        <span class="kw">this</span>.<span class="at">clearCache</span>()
      <span class="op">}</span></code></pre></div>
<p>Net up is the clear cache method, which shows us what is all cached on the new component, there are the three prop types (state, dispatch and merge), the final methods to compute them (<code>finalMapDispatchToProps</code>, <code>finalMapStateToProps</code>), the rendered wrapped element (<code>renderedElement</code>) and flags indicating if the stateProps or the storeProps have changed. I don’t quite understand what <code>haveStatePropsBeenPrecalculated</code> and <code>statePropsPrecalculationError</code> do quite yet.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      <span class="at">clearCache</span>() <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">dispatchProps</span> <span class="op">=</span> <span class="kw">null</span>
        <span class="kw">this</span>.<span class="at">stateProps</span> <span class="op">=</span> <span class="kw">null</span>
        <span class="kw">this</span>.<span class="at">mergedProps</span> <span class="op">=</span> <span class="kw">null</span>
        <span class="kw">this</span>.<span class="at">haveOwnPropsChanged</span> <span class="op">=</span> <span class="kw">true</span>
        <span class="kw">this</span>.<span class="at">hasStoreStateChanged</span> <span class="op">=</span> <span class="kw">true</span>
        <span class="kw">this</span>.<span class="at">haveStatePropsBeenPrecalculated</span> <span class="op">=</span> <span class="kw">false</span>
        <span class="kw">this</span>.<span class="at">statePropsPrecalculationError</span> <span class="op">=</span> <span class="kw">null</span>
        <span class="kw">this</span>.<span class="at">renderedElement</span> <span class="op">=</span> <span class="kw">null</span>
        <span class="kw">this</span>.<span class="at">finalMapDispatchToProps</span> <span class="op">=</span> <span class="kw">null</span>
        <span class="kw">this</span>.<span class="at">finalMapStateToProps</span> <span class="op">=</span> <span class="kw">null</span>
      <span class="op">}</span></code></pre></div>
<p>The handleChange method is the one that is subscribed to the store, thus it is being called when the store has changed. When there is not <code>this.unsubscribe</code> method, we’re not yet subscribed, so we just return. If the component is <code>pure</code> and the new store state is shallowEqual to the old one, we also return. Otherwise, there is another optimization if the <code>stateProps</code> do not depend on the <code>ownProps</code>, we try to pre-compute the <code>stateProps</code>, store an error if there is an exception thrown and remember that the state props have been precalculated. In any case we set the <code>hasStoreStateChanged</code> flag to true and store the new state.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      <span class="at">handleChange</span>() <span class="op">{</span>
        <span class="cf">if</span> (<span class="op">!</span><span class="kw">this</span>.<span class="at">unsubscribe</span>) <span class="op">{</span>
          <span class="cf">return</span>
        <span class="op">}</span>

        <span class="kw">const</span> storeState <span class="op">=</span> <span class="kw">this</span>.<span class="va">store</span>.<span class="at">getState</span>()
        <span class="kw">const</span> prevStoreState <span class="op">=</span> <span class="kw">this</span>.<span class="va">state</span>.<span class="at">storeState</span>
        <span class="cf">if</span> (pure <span class="op">&amp;&amp;</span> prevStoreState <span class="op">===</span> storeState) <span class="op">{</span>
          <span class="cf">return</span>
        <span class="op">}</span>

        <span class="cf">if</span> (pure <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="kw">this</span>.<span class="at">doStatePropsDependOnOwnProps</span>) <span class="op">{</span>
          <span class="kw">const</span> haveStatePropsChanged <span class="op">=</span> <span class="at">tryCatch</span>(<span class="kw">this</span>.<span class="at">updateStatePropsIfNeeded</span><span class="op">,</span> <span class="kw">this</span>)
          <span class="cf">if</span> (<span class="op">!</span>haveStatePropsChanged) <span class="op">{</span>
            <span class="cf">return</span>
          <span class="op">}</span>
          <span class="cf">if</span> (haveStatePropsChanged <span class="op">===</span> errorObject) <span class="op">{</span>
            <span class="kw">this</span>.<span class="at">statePropsPrecalculationError</span> <span class="op">=</span> <span class="va">errorObject</span>.<span class="at">value</span>
          <span class="op">}</span>
          <span class="kw">this</span>.<span class="at">haveStatePropsBeenPrecalculated</span> <span class="op">=</span> <span class="kw">true</span>
        <span class="op">}</span>

        <span class="kw">this</span>.<span class="at">hasStoreStateChanged</span> <span class="op">=</span> <span class="kw">true</span>
        <span class="kw">this</span>.<span class="at">setState</span>(<span class="op">{</span> storeState <span class="op">}</span>)
      <span class="op">}</span></code></pre></div>
<p>Finally, there is a <code>getWrappedInstance</code> convenience method.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      <span class="at">getWrappedInstance</span>() <span class="op">{</span>
        <span class="at">invariant</span>(withRef<span class="op">,</span>
          <span class="vs">`To access the wrapped instance, you need to specify `</span> <span class="op">+</span>
          <span class="vs">`{ withRef: true } as the fourth argument of the connect() call.`</span>
        )

        <span class="cf">return</span> <span class="kw">this</span>.<span class="va">refs</span>.<span class="at">wrappedInstance</span>
      <span class="op">}</span></code></pre></div>
<h3 id="the-render-method">The render method</h3>
<p>Finally the <code>render</code> method is pretty involved, it does far more than just rendering the wrapped compoent, it is where all the caching and precomputing mechanisms come into play.</p>
<p>There is a bit (too much(?)) logic in this function, fortunately the variable names are really good. I’ve found it the easiest to work my way from the bottom up. At the very end, the <code>this.renderedElement</code> is returned, which is an instance of the wrapped element (with or without a ref).</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="cf">if</span> (withRef) <span class="op">{</span>
          <span class="kw">this</span>.<span class="at">renderedElement</span> <span class="op">=</span> <span class="at">createElement</span>(WrappedComponent<span class="op">,</span> <span class="op">{</span>
            ...<span class="va">this</span>.<span class="at">mergedProps</span><span class="op">,</span>
            <span class="dt">ref</span><span class="op">:</span> <span class="st">&#39;wrappedInstance&#39;</span>
          <span class="op">}</span>)
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
          <span class="kw">this</span>.<span class="at">renderedElement</span> <span class="op">=</span> <span class="at">createElement</span>(WrappedComponent<span class="op">,</span>
            <span class="kw">this</span>.<span class="at">mergedProps</span>
          )
        <span class="op">}</span>

        <span class="cf">return</span> <span class="kw">this</span>.<span class="at">renderedElement</span></code></pre></div>
<p>However, <code>this.renderedElement</code> is only computed if (a) <code>haveMergedPropsChanged</code> is true or (b) <code>renderedElement</code> is falsy (so probably undefined).</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="cf">if</span> (<span class="op">!</span>haveMergedPropsChanged <span class="op">&amp;&amp;</span> renderedElement) <span class="op">{</span>
          <span class="cf">return</span> renderedElement
        <span class="op">}</span></code></pre></div>
<p>Now <code>haveMergedPropsChanged</code> is either false if all of <code>haveStatePropsChanged</code>, <code>haveDispatchPropsChanged</code> and<code>haveOwnPropsChanged</code> are false (so no props have changed), or the result of the <code>this.updateMergedPropsIfNeeded()</code> method.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="kw">let</span> haveMergedPropsChanged <span class="op">=</span> <span class="kw">true</span>
        <span class="cf">if</span> (
          haveStatePropsChanged <span class="op">||</span>
          haveDispatchPropsChanged <span class="op">||</span>
          haveOwnPropsChanged
        ) <span class="op">{</span>
          haveMergedPropsChanged <span class="op">=</span> <span class="kw">this</span>.<span class="at">updateMergedPropsIfNeeded</span>()
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
          haveMergedPropsChanged <span class="op">=</span> <span class="kw">false</span>
        <span class="op">}</span></code></pre></div>
<p><code>haveStatePropsChanged</code> is true if either <code>haveStatePropsBeenPrecalculated</code> is true or if <code>shouldUpdateStateProps</code> is true and <code>this.updateStatePropsIfNeeded()</code> returns true. <code>shouldUpdateStateProps</code> is true if either (a) the component is not pure or there is not rendered element yet, (b) <code>hasStoreStateChanged</code> is true or (c) <code>haveOwnPropsChanged</code> is true and <code>this.doStatePropsDependOnOwnProps</code> is. Similar conditions apply to <code>shouldUpdateDispatchProps</code>, except that the <code>hasStoreStateChanged</code> condition is not checked.</p>
<p>Now, another interesting thing that is going on in the render method is that it sets a number of instance variables which control the caching behavior, namely <code>haveOwnPropsChanged</code>, <code>hasStoreStateChanged</code>, <code>haveStatePropsBeenPrecalculated</code>. After render has run, these are set to <code>false</code>, so that the respective components would not be recalculated on a second run of <code>render</code>. Other life cycle methods turn these instance variables to true again, this is essential for only recomputing the parts of the properties which are acutally needed.</p>
<p>Now that we have examined the full render method, let’s see it once more from top to bottom in all of its glory:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">      <span class="at">render</span>() <span class="op">{</span>
        <span class="kw">const</span> <span class="op">{</span>
          haveOwnPropsChanged<span class="op">,</span>
          hasStoreStateChanged<span class="op">,</span>
          haveStatePropsBeenPrecalculated<span class="op">,</span>
          statePropsPrecalculationError<span class="op">,</span>
          renderedElement
        <span class="op">}</span> <span class="op">=</span> <span class="kw">this</span>

        <span class="kw">this</span>.<span class="at">haveOwnPropsChanged</span> <span class="op">=</span> <span class="kw">false</span>
        <span class="kw">this</span>.<span class="at">hasStoreStateChanged</span> <span class="op">=</span> <span class="kw">false</span>
        <span class="kw">this</span>.<span class="at">haveStatePropsBeenPrecalculated</span> <span class="op">=</span> <span class="kw">false</span>
        <span class="kw">this</span>.<span class="at">statePropsPrecalculationError</span> <span class="op">=</span> <span class="kw">null</span>

        <span class="cf">if</span> (statePropsPrecalculationError) <span class="op">{</span>
          <span class="cf">throw</span> statePropsPrecalculationError
        <span class="op">}</span>

        <span class="kw">let</span> shouldUpdateStateProps <span class="op">=</span> <span class="kw">true</span>
        <span class="kw">let</span> shouldUpdateDispatchProps <span class="op">=</span> <span class="kw">true</span>
        <span class="cf">if</span> (pure <span class="op">&amp;&amp;</span> renderedElement) <span class="op">{</span>
          shouldUpdateStateProps <span class="op">=</span> hasStoreStateChanged <span class="op">||</span> (
            haveOwnPropsChanged <span class="op">&amp;&amp;</span> <span class="kw">this</span>.<span class="at">doStatePropsDependOnOwnProps</span>
          )
          shouldUpdateDispatchProps <span class="op">=</span>
            haveOwnPropsChanged <span class="op">&amp;&amp;</span> <span class="kw">this</span>.<span class="at">doDispatchPropsDependOnOwnProps</span>
        <span class="op">}</span>

        <span class="kw">let</span> haveStatePropsChanged <span class="op">=</span> <span class="kw">false</span>
        <span class="kw">let</span> haveDispatchPropsChanged <span class="op">=</span> <span class="kw">false</span>
        <span class="cf">if</span> (haveStatePropsBeenPrecalculated) <span class="op">{</span>
          haveStatePropsChanged <span class="op">=</span> <span class="kw">true</span>
        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (shouldUpdateStateProps) <span class="op">{</span>
          haveStatePropsChanged <span class="op">=</span> <span class="kw">this</span>.<span class="at">updateStatePropsIfNeeded</span>()
        <span class="op">}</span>
        <span class="cf">if</span> (shouldUpdateDispatchProps) <span class="op">{</span>
          haveDispatchPropsChanged <span class="op">=</span> <span class="kw">this</span>.<span class="at">updateDispatchPropsIfNeeded</span>()
        <span class="op">}</span>

        <span class="kw">let</span> haveMergedPropsChanged <span class="op">=</span> <span class="kw">true</span>
        <span class="cf">if</span> (
          haveStatePropsChanged <span class="op">||</span>
          haveDispatchPropsChanged <span class="op">||</span>
          haveOwnPropsChanged
        ) <span class="op">{</span>
          haveMergedPropsChanged <span class="op">=</span> <span class="kw">this</span>.<span class="at">updateMergedPropsIfNeeded</span>()
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
          haveMergedPropsChanged <span class="op">=</span> <span class="kw">false</span>
        <span class="op">}</span>

        <span class="cf">if</span> (<span class="op">!</span>haveMergedPropsChanged <span class="op">&amp;&amp;</span> renderedElement) <span class="op">{</span>
          <span class="cf">return</span> renderedElement
        <span class="op">}</span>

        <span class="cf">if</span> (withRef) <span class="op">{</span>
          <span class="kw">this</span>.<span class="at">renderedElement</span> <span class="op">=</span> <span class="at">createElement</span>(WrappedComponent<span class="op">,</span> <span class="op">{</span>
            ...<span class="va">this</span>.<span class="at">mergedProps</span><span class="op">,</span>
            <span class="dt">ref</span><span class="op">:</span> <span class="st">&#39;wrappedInstance&#39;</span>
          <span class="op">}</span>)
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
          <span class="kw">this</span>.<span class="at">renderedElement</span> <span class="op">=</span> <span class="at">createElement</span>(WrappedComponent<span class="op">,</span>
            <span class="kw">this</span>.<span class="at">mergedProps</span>
          )
        <span class="op">}</span>

        <span class="cf">return</span> <span class="kw">this</span>.<span class="at">renderedElement</span>
      <span class="op">}</span>
    }</code></pre></div>
<p>Finally, we have some additional properties installed on the Connect class (<code>static</code> properties in OO terms)</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="va">Connect</span>.<span class="at">displayName</span> <span class="op">=</span> connectDisplayName
    <span class="va">Connect</span>.<span class="at">WrappedComponent</span> <span class="op">=</span> WrappedComponent
    <span class="va">Connect</span>.<span class="at">contextTypes</span> <span class="op">=</span> <span class="op">{</span>
      <span class="dt">store</span><span class="op">:</span> storeShape
    <span class="op">}</span>
    <span class="va">Connect</span>.<span class="at">propTypes</span> <span class="op">=</span> <span class="op">{</span>
      <span class="dt">store</span><span class="op">:</span> storeShape
    <span class="op">}</span>

    <span class="cf">if</span> (<span class="va">process</span>.<span class="va">env</span>.<span class="at">NODE_ENV</span> <span class="op">!==</span> <span class="st">&#39;production&#39;</span>) <span class="op">{</span>
      <span class="va">Connect</span>.<span class="va">prototype</span>.<span class="at">componentWillUpdate</span> <span class="op">=</span> <span class="kw">function</span> <span class="at">componentWillUpdate</span>() <span class="op">{</span>
        <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">version</span> <span class="op">===</span> version) <span class="op">{</span>
          <span class="cf">return</span>
        <span class="op">}</span>

        <span class="co">// We are hot reloading!</span>
        <span class="kw">this</span>.<span class="at">version</span> <span class="op">=</span> version
        <span class="kw">this</span>.<span class="at">trySubscribe</span>()
        <span class="kw">this</span>.<span class="at">clearCache</span>()
      <span class="op">}</span>
    <span class="op">}</span>

    <span class="cf">return</span> <span class="at">hoistStatics</span>(Connect<span class="op">,</span> WrappedComponent)
  }</code></pre></div>
<h2 id="conclusion-next-steps">Conclusion &amp; next steps</h2>
<p>OK, we’ve seen that the generated component is somewhat involved and has some fancy optimizations going on. Splitting the creation of the properties of the wrapped component into external props, properties computed from the state and properties computed from the dispatch method allows deciding precisely which part has been updated and if the wrapped component should be rendered again or not. The caching mechanisms employed are also fancy, with a fairly precise control over what needs to be recomputed when and only recomputing the parts needed. All in all, the connect function is very simple apart from these optimizations.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This is where I would prefer the constraints of a static type system - why do we need the case where <code>mapState</code> does not return a final result? To me this seems like a bit too much unneeded (=hard to understand) flexiblity, which dynamic languages tend to gravitate to.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Thu, 01 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Understanding-the-react-redux-connect-function.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Trying and failing to make a type safe react-redux connect wrapper</title>
    <link>http://koerbitz.me/posts/Trying-and-failing-to-make-redux-connect-type-safe.html</link>
    <description><![CDATA[<h1 class="title">Trying and failing to make a type safe react-redux connect wrapper</h1>

<p class="date">published on November 16, 2016</p>

<p>One of the challenges when trying to use redux with TypeScript in a type safe way is to use the <a href="https://redux.js.org/docs/basics/UsageWithReact.html">react-redux</a> <code>connect</code> function in a type safe manner. At the time of writing, the type definition at <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/react-redux/react-redux.d.ts">DefinitelyTyped</a> does not ensure type safety. This blog post tries to develop a more limited<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> wrapper around this function which ensures type safety, but sadly fails to come up with a full solution.</p>
<p>The <code>connect</code> function from react redux has a simple purpose: To turn a presentation focused component requiring properties A and to automatically generate a logic focused container<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> requiring properties B. It does this via two functions, <code>mapStateToProps</code> and <code>mapDispatchToProps</code> which take the current state from the store or its dispatch function, respectively and properties B. The <code>connect</code> function then returns a generated container requiring properties B to instantiate and uses the passed functions to convert this into property A and instantiate the initially passed component.</p>
<h3 id="solving-the-first-problem-type-parameter-inference">Solving the first problem: type parameter inference</h3>
<p>If we simplify things a bit more by munging <code>mapStateToProps</code> and <code>mapDispatchToProps</code> into a single function <code>convertProps</code><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> and only handeling React StatelessFunctionalComponents for now<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> we need something like the following:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// one.ts</span>
<span class="kw">import * as _ from &#39;lodash&#39;;</span>
<span class="kw">import * as React from &#39;react&#39;;</span>
<span class="kw">import { render } from &#39;react-dom&#39;;</span>

<span class="dt">const</span> { div } = React.<span class="fu">DOM</span>;

<span class="co">// Goal: getting to a type safe connect function.</span>

<span class="co">// The connect function takes an existing react comonent class with</span>
<span class="co">// properties A, a function transforming properties B to properties A</span>
<span class="co">// and returns a new react component expecting properties B.</span>

<span class="co">// essentially, we need something like the following:</span>
function connect&lt;NEW_PROPS, OLD_PROPS&gt;(convertProps: (p: NEW_PROPS) =&gt; OLD_PROPS,
                                       componentClass: React.<span class="fu">SFC</span>&lt;OLD_PROPS&gt;{
                                      ): React.<span class="fu">SFC</span>&lt;NEW_PROPS&gt; {
    <span class="kw">return</span> props =&gt; React.<span class="fu">createElement</span>(componentClass, <span class="fu">convertProps</span>(props));
}

<span class="kw">interface</span> OldProps {
    oldName: string;
}

<span class="dt">const</span> OldComp: React.<span class="fu">SFC</span>&lt;OldProps&gt; = props =&gt; {
    <span class="kw">return</span> <span class="fu">div</span>(undefined, <span class="st">&quot;Hello, &quot;</span> + props.<span class="fu">oldName</span> + <span class="st">&quot;!&quot;</span>);
};

<span class="kw">interface</span> NewProps {
    newName: string;
}

function <span class="fu">convertProps</span>(newProps: NewProps): OldProps {
    <span class="kw">return</span> { oldName: newProps.<span class="fu">newName</span> };
}

<span class="dt">const</span> NewComp = <span class="fu">connect</span>(convertProps, OldComp);

<span class="fu">NewComp</span>({ newName: <span class="st">&quot;connect&quot;</span> }); <span class="co">/* works */</span></code></pre></div>
<p>This is a simple approach, unfortunately it is not very type safe. To see this we’ll change the <code>convertProps</code> function to not return the OldProps but something not containing these properties:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// two.ts</span>
function <span class="fu">convertProps</span>(newProps: NewProps): {} {
    <span class="kw">return</span> {};
}

<span class="co">// no type error</span>
<span class="dt">const</span> NewComp = <span class="fu">connect</span>(convertProps, OldComp);

<span class="co">// runtime error, &#39;oldName&#39; is not passed to</span>
<span class="fu">NewComp</span>({ newName: <span class="st">&quot;connect&quot;</span> });</code></pre></div>
<p>The problem here is that the inferred type for the <code>OLD_PROPS</code> type parameter is <code>{}</code>, the return type of the changed <code>convertProps</code> function and that <code>OldComp</code> of type <code>React.SFC&lt;OldProps&gt;</code> is accepted (type compatible) with as a parameter of type <code>React.SFC&lt;{}&gt;</code>. This is a known, by design unsoundness of the TypeScript type system as noted under <a href="https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Type%20Compatibility.md">type compatibility</a> in the TypeScript wiki. The issue here is that <code>React.SFC&lt;OldProps&gt; extends React.SFC&lt;{}&gt;</code> holds, however, <code>SFC</code> should be contravariant in its type parameter.</p>
<p>Can we work around this issue? It turns that we can fix the <code>OLD_PROPS</code> type parameter of the connect function if we pass the arguments <em>one by one</em> in reverse order:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// three.ts</span>
function connect&lt;NEW_PROPS, OLD_PROPS&gt;(
     componentClass: React.<span class="fu">SFC</span>&lt;OLD_PROPS&gt;
    ): (convertProps: (p: NEW_PROPS) =&gt; OLD_PROPS) =&gt; React.<span class="fu">SFC</span>&lt;NEW_PROPS&gt;
{
    <span class="kw">return</span> convertProps =&gt; props =&gt; React.<span class="fu">createElement</span>(componentClass, <span class="fu">convertProps</span>(props));
}</code></pre></div>
<p>This might look a little complicated at first, but all we’re doing is to pass the component class first, and then we’re passing the <code>convertProps</code> function. In functional programming terms, we’re <em>currying</em> the connect function. This is enough to make TypeScript infer the type arguments from the component. Thus the type of <code>connect(OldComp)</code> is <code>(convertProps: (p: NEW_PROPS) =&gt; OldProps) =&gt; React.SFC&lt;NEW_PROPS&gt;</code>, thus</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// still in three.ts</span>
function <span class="fu">convertProps</span>(newProps: NewProps): {} {
    <span class="kw">return</span> {};
}

<span class="co">// now a type error, as it should be</span>
<span class="dt">const</span> NewComp = <span class="fu">connect</span>(OldComp)(convertProps);</code></pre></div>
<p>now gives a type error as it should. Since the type parameter <code>NEW_PROPS</code> will be inferred to be the type of the parameter passed to <code>convertProps</code>, this will not be a problem for type safety.</p>
<h3 id="failing-to-solve-the-second-problem-constraining-a-type-intersection">Failing to solve the second problem: constraining a type intersection</h3>
<p>Now the <em>real</em> react connect function is a bit more complicated, it takes two functions to create the new props and handles different react components, not just SFCs. At the time of writing, the <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/react-redux/react-redux.d.ts">DefinitelyTyped</a> definition available through npm via <code>@types/react-redux</code> gives the following type definitions:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">interface</span> ComponentDecorator&lt;TOriginalProps, TOwnProps&gt; {
    (component: ComponentClass&lt;TOriginalProps&gt; | StatelessComponent&lt;TOriginalProps&gt;):
        ComponentClass&lt;TOwnProps&gt;;
}

type FuncOrSelf&lt;T&gt; = T | (() =&gt; T);

<span class="kw">interface</span> MapStateToProps&lt;TStateProps, TOwnProps&gt; {
    (state: any, ownProps?: TOwnProps): TStateProps;
}

<span class="kw">interface</span> MapDispatchToPropsFunction&lt;TDispatchProps, TOwnProps&gt; {
    (dispatch: Dispatch&lt;any&gt;, ownProps?: TOwnProps): TDispatchProps;
}

export declare function connect&lt;TStateProps, TDispatchProps, TOwnProps&gt;(
    mapStateToProps: FuncOrSelf&lt;MapStateToProps&lt;TStateProps, TOwnProps&gt;&gt;,
    mapDispatchToProps?: FuncOrSelf&lt;MapDispatchToPropsFunction&lt;TDispatchProps, TOwnProps&gt;
                                    | MapDispatchToPropsObject&gt;
): ComponentDecorator&lt;TStateProps &amp; TDispatchProps, TOwnProps&gt;;</code></pre></div>
<p>There is a lot of stuff here that I assume is there to handle all the flexible ways in which the connect function could be used (there is even a more complicated second signature, which I am completely ignoring here). Being a static typing enthusiast, I obviously think this is misguided, I just want one definition that checks as much as possible at compile time. I also have a few gripes with this definition, as it doesn’t do any type checking on the store or the dispatch function, but this is not really the place to get into that.</p>
<p>The main practical difference between the simplified version illustrated in the first part of this post is that this version takes two functions, one from the current state (<code>mapStateToProps</code>) and one using the dispatch function (<code>mapDispatchToProps</code>) (the first is supposed to provide input properties, the second callbacks) and mixes their results to create the old properties for the input component.</p>
<p>The problem which I haven’t been able to solve is that these two functions both provide some subset of the properties required by the input component which we want to wrap. In order to ensure type safety, we would like to guarantee that together, these properties cover all properties required for the original component (B). In terms of the type system, the intersection of both properties should extend the properties required by the original component, thus</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">PropsFromMapStateToProps &amp; PropsFromMapDispatchToProps <span class="kw">extends</span> PropsForB</code></pre></div>
<p>Unfortunately, I haven’t found a way to do this in the TypeScript type system. Given this limitation, I currently don’t see a way of creating a wrapper of this connect function which ensures type safety.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>In the sense that our function will not cover all the use cases that the <a href="https://redux.js.org/docs/basics/UsageWithReact.html">react-redux</a> <code>connect</code> function covers.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>The distinction between presentation focused <em>‘components’</em> and logic focused <em>‘containers’</em> is a widespread one and is for example explained in this <a href="https://medium.com/@dan_abramov/smart-and-dump-components-7ca2f9a7c7d0">blog post</a>.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The idea is that this function will only receive the properties of the new container and that the store is contained in these. React redux offers a way to pass the store as a context object, but I want to forgo this possibility, as it cannot be made type safe either.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>We can easily use other React components here as well, this is only a simplification for presentation purposes.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Wed, 16 Nov 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Trying-and-failing-to-make-redux-connect-type-safe.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Some Personal Rules for Effective and Efficient Meetings</title>
    <link>http://koerbitz.me/posts/Some-Personal-Rules-for-Effective-and-Efficient-Meetings.html</link>
    <description><![CDATA[<h1 class="title">Some Personal Rules for Effective and Efficient Meetings</h1>

<p class="date">published on November  7, 2016</p>

<p>I am in a situation where I spent more time in meetings now (o_O), so naturally I have started to look for ways to get more out of these meetings and spend less time in them. This information is nothing new, it is a personal proposition that I want to strive for and making it public just makes that a bit more effective.</p>
<h2 id="make-a-plan-and-stick-to-it">Make a plan and stick to it</h2>
<p>All of the points I am trying to stick to come from answering some common sense questions (e.g. why are we having this meeting) and a good preparation of the meeting. Failing to prepare is preparing to fail as they say.</p>
<ol style="list-style-type: decimal">
<li><p>Have a clear objective for the meeting and let everyone know it.</p>
<p>It is amazing how many meetings are held without having a clear objective. I try to get a clear statement what the objective is (or formulate it) and have that all the attendees know. This alone often gives a great focus to the meeting.</p></li>
<li><p>Communicate an agenda before hand.</p>
<p>Similarly, having an agenda before the meeting allows everyone to prepare or have additional points scheduled. Having a clear agenda also allows to have a schedule during the meeting so that the allotted time does not run out while only 20% of the topics have been discussed.</p></li>
<li><p>Stay on topic, follow up on other points later.</p>
<p>Invariably, while discussing things more topics and questions come up, which are not directly related to the objective of the meeting. Cutting these off and moving them to follow on discussions while not being rude is always a big challenge, but meetings can meander very aimlessly if it is not done.</p></li>
<li><p>Make it short and stick to the schedule.</p>
<p>Scheduling a short but realistic time is key to not having the meeting be too long. I often find this to be a challenge. There is always one more thing to discuss and staying on schedule often requires a hard step on the break. Having another committment directly after the scheduled meeting time helps me in having the necessary motivation for keeping the meeting on schedule.</p></li>
<li><p>Sent a follow up of the results.</p>
<p>Sending out an email with the key points discussed and agreed upon is very helpful in keeping everyone on the same page and to create some documentation of discussions and decisions made. Ironically, it often feels like a waste of time to do this when one has already spent what seems like too much time in a meeting, but if it was worth having the meeting (and why have, it if not), then shouldn’t it be worth to document the main outcome? Follow ups are also great for defining next steps for points that where deferred during the meeting (see 3) and make doing so more credible.</p></li>
</ol>
<h2 id="getting-things-done-when-youre-only-a-grunt">Getting things done when you’re only a grunt</h2>
<p>It might seem like you can do most of these things only if you’re high up in the hierarchy or running the meeting. However, while this will certainly make things easier, often you can get quite far with a few tricks. Asking questions like “what is our objective for this meeting?” or “is it possible to get an agenda before hand?” will usually be answered positively. Cutting your higher ups off when they go off topic is a bit more risky of course, but politely asking if this discussion can be continued afterwards is often still OK. In the same vein, annoucing “I really have to leave on time b/c of XYZ” when the meeting starts can also help to keep things on schedule. In the end most people have been in too many meetings that have taken up too much time that there is usually strong support for such measures.</p>
<h2 id="some-first-experiences">Some first experiences</h2>
<p>I’ve only started these practices recently, but so far the results are very encouraging. First, some meetings are not necessary: sending an upfront email with the objective and a thought out first attempt at a solution is often enough to render a meeting unnecessary. Sending out a follow up is also great for keeping everyone on the same page of what was discussed, to be able to look things up later and to create follow ups if necessary. The biggest challenge so far is to keep things short and to avoid off topic discussions. My best plan so far is to schedule things with short but realistic time slots back-to-back so that overrunning is not an option.</p>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Mon, 07 Nov 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Some-Personal-Rules-for-Effective-and-Efficient-Meetings.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>A Look at the Idris Internals, Part IV: From TT Onward</title>
    <link>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-IV-From-TT-Onward.html</link>
    <description><![CDATA[<h1 class="title">A Look at the Idris Internals, Part IV: From TT Onward</h1>

<p class="date">published on July 19, 2016</p>

<p>So after looking at the invocation of the elaborator in the <a href="/posts/A-Look-at-the-Idris-Internals-Part-III-From-Parsing-to-Elaboration.html">last post</a>, I now want to look into how the resulting TT terms are further processed and simplified into the other intermediary languages. The <a href="https://eb.host.cs.st-andrews.ac.uk/drafts/compile-idris.pdf">cross-platform compilers</a> paper by Edwin Brady gives a high level description of the later stage intermediate languages of Idris. This post will take a look at where the intermediate languages are located in the code and what functions are invoked to simplify TT further.</p>
<h2 id="idriss-later-stage-intermediate-languages">Idris’s later stage intermediate languages</h2>
<p>After converting Idris to <code>TT</code>, there are a number of additional intermediate languages, which get produced in subsequent steps. The idea is that these languages are progressively simpler and that each code generator can pick a lanugage which it is easiest to generate the desired code from. The <a href="https://eb.host.cs.st-andrews.ac.uk/drafts/compile-idris.pdf">cross-platform compilers</a> paper by Edwin Brady ilustrates the intermediate languages used in Idris. After Idris and TT, the paper lists the following:</p>
<ul>
<li><p>TT_case in which pattern matching is converted to simple case trees via a pattern match compiler.</p></li>
<li><p>IR_case in which all types are erased, as well as any values which are provably not used at run-time.</p></li>
<li><p>IR_lift in which there are no lambda bindings other than at the top level.</p></li>
<li><p>IR_defunc in which all functions are fully applied. All functions are first-order, by defunctionalisation.</p></li>
<li><p>IR_ANF in which all functions are in Applicative Normal Form (ANF), that is all arguments to functions are trivial. By “trivial”, we mean that evaluation of an argument must terminate immediately, that is arguments are either constant or variables.</p></li>
</ul>
<h2 id="where-are-the-intermediate-languages-produced">Where are the intermediate languages produced?</h2>
<p>Looking at the <code>idrisMain</code> function in <code>Idris/REPL.hs</code> again, we first <code>loadInputs</code> (which ends up calling either <code>loadSource</code> or reloading the equivalent from ibc files). As discussed in the <a href="/posts/A-Look-at-the-Idris-Internals-Part-III-From-Parsing-to-Elaboration.html">last post</a>, the <code>loadSource</code> function from <code>Idris/Parser.hs</code> does a lot of work, namely parsing source files, invoking the elaborator via the <code>elabDecls</code> function from <code>Idris/ElabDecls.hs</code>, simplifying case definitions via the <code>simplifyCasedef</code> function (this converts <code>TT</code> to <code>TT_case</code>), totality checking (first building a size change graph via <code>buildSCG</code>, then <code>checkDeclTotality</code> and <code>verifyTotality</code>), and finally writing out the ibc file.</p>
<p>Next we call the <code>process</code> function with a <code>Compile</code> command. <code>process</code> (also in <code>REPL.hs</code>) calls the <code>compile</code> function in <code>IRTS/Compiler.hs</code>, so this seems to be the main entry point for further processing of the TT code.</p>
<p><code>compile</code> does some usage analysis to find reachable names, then calls <code>mkDecls</code> on a list of these names. <code>mkDecls</code> has a type of <code>[Name] -&gt; Idris [(Name, LDecl)]</code>, so outputs a list of declarations of type <code>LDecl</code>. <code>LDecl</code> is the first post-TT intermediate language, it is defined in <code>IRTS/Lang.hs</code>. If I am not mistaken, this should correspond to <code>IR_case</code> in the above list (<code>TT_case</code> is a special case of TT which is represented in the same data structure as <code>TT</code>). <code>LDecl</code> just has two constructors, <code>LFun</code> and <code>LConstructor</code>. The latter just has a <code>Name</code>, an <code>Int</code> (tag) and another <code>Int</code> (arity), the former has options, names (name and argument names) and an expression of type <code>LExp</code>, which is the actual definition of the function (defined in the same file).</p>
<p><code>mkLDecls</code> is basically a wrapper around the <code>build</code> function, which creates a <code>(Name, LDecl)</code> pair for each <code>(Name, Def)</code> declaration that it gets, so <code>LDecls</code> seem to correspond directly to <code>Defs</code>. If the provided name is a primitive operation <code>build</code> directly constructs an <code>LFun</code> which contains an <code>LOp</code> with some machine generated names for the arguments, otherwise it calls <code>mkLDecl</code> to do this.</p>
<p><code>mkLDecl</code> handles the constructors <code>Function</code>, <code>CaseOp</code>, <code>TyDecl DCon</code> and <code>TyDecl TCon</code> explicitly, for everything else it creates an <code>LFun [Inline] name [] LNothing</code> construction, this seems to be a function which does a no-op. For the <code>Function</code> and the <code>CaseOp</code> constructors, the <code>irTerm</code> and <code>irTree</code> seem to be the real work horses, we’ll check these out next.</p>
<p>Of the two <code>irTree</code> itself is short, handing of its work to <code>irSC</code>, which pattern matches on a variable of type <code>SC</code>, this seems to be the case tree representation of the TT terms generated by <code>simplifyCasedef</code> earlier. <code>irSC</code> is pretty involved and looks like it is handeling a lot of special cases. A better understanding of the case trees is probably necessary to understand what is happening in <code>irSC</code> and why.</p>
<p><code>irTerm</code> on the other hand handles conversions of TT terms, handling <code>App</code>, <code>P</code>, <code>V</code>, <code>Bind</code>, <code>Proj</code>, <code>Constant</code>, <code>TType</code>, <code>Erased</code> and <code>Impossible</code> constructors. The latter three are mapped directly to <code>LNothing</code>, transformations for <code>P</code>, <code>V</code>, <code>Bind</code>, <code>Proj</code> and <code>Constant</code> seem pretty straight-forward, however, the <code>App</code> case is very involved, it <code>unApply</code>s the application and has about 20 different pattern matches on the <code>P</code> constructor alone.</p>
<p>Nevertheless <code>mkDecls</code> and the functions it calls handle the transformation from <code>TT</code> to <code>LDecl</code> - some complications along these lines should have been expected ;).</p>
<h2 id="further-processing">Further processing</h2>
<p>Returning to the <code>compile</code> function, the <code>inlineAll</code> function from <code>IRTS/LangOpts.hs</code> is invoked on our <code>LDecls</code>, which, for all <code>LDecls</code> basically searches for <code>LApp</code> constructs (so function applications), checks a number of conditions to see that these are inlineable, invents fresh names for the variables and replaces the application with the function body.</p>
<p>Next <code>allocUnique</code> and <code>addTags</code> make some tranforms to maintain unique names (?) and tag constructors(?). In there <code>liftAll</code> does lambda lifting for all LDecls, the work horse here seems to be the <code>lift</code> function in <code>IRTS/Lang.hs</code>. So this innocent looking step does the transformation from <code>IR_case</code> to <code>IR_lift</code>, all the while the data type is still <code>LDecl</code>.</p>
<p>Next up is a call to <code>defunctionalise</code> which turns <code>LDefs</code> into <code>DDefs</code>, this is the representation of <code>IR_defunc</code> where all function applications are fully applied and first order. <code>DDefs</code> is a <code>Ctxt</code> around <code>DDecl</code>, which looks pretty similar to <code>LDecl</code> (some cases have been simplified, I suppose). Next, <code>DDefs</code> are <code>inline</code>ed, as far as I can tell this does not do anything at the moment.</p>
<p>The next call is to <code>simplifyDefs</code> which turns the <code>DDefs</code> into <code>SDefs</code>, where <code>SDefs</code> are definitions in the simplified language defined in <code>IRTS/Simplified.hs</code>, I think this corresponds to <code>IR_ANF</code>, xthe simplest of the intermediate languages.</p>
<p>With this we’re pretty much through the intermediate language generation and return a <code>CodegenInfo</code>, which contains the simplified (<code>c</code>, IR_ANF), defunctionalized (<code>defuns</code> IR_defun) and lifted (<code>tagged</code>, IR_lift) representations.</p>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Tue, 19 Jul 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-IV-From-TT-Onward.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>A Look at the Idris Internals, Part III: From Parsing to Elaboration</title>
    <link>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-III-From-Parsing-to-Elaboration.html</link>
    <description><![CDATA[<h1 class="title">A Look at the Idris Internals, Part III: From Parsing to Elaboration</h1>

<p class="date">published on March 15, 2016</p>

<p>So after looking at the parser in the <a href="/posts/A-Look-at-the-Idris-Internals-Part-II-Taking-the-Parser-for-a-Spin.html">last post</a>, this post will explore what happens after an Idris has been parsed, namely how it is desugared and elaborated to a TT program.</p>
<p>Looking throught the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L1635"><code>idrisMain</code></a> method in <code>REPL.hs</code>, it seems that code is actually loaded by either the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L1535"><code>loadInputs</code></a> function (also in <code>REPL.hs</code>) or the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L1583"><code>loadModule</code></a> from <code>Parser.hs</code>.</p>
<p><a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L1535"><code>loadInputs</code></a> <em>loads</em> a list of Idris files, meaning that it tries to completely process these files (reading, parsing, elaborating, saving the state in the <code>IState</code>) and all their dependencies. It uses the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Chaser.hs#L116"><code>buildTree</code></a> function from <code>Chaser.hs</code> to retrieve the actual files along with modification times and indicating if a file needs to be re-loaded. It uses the locally defined <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L1599"><code>tryLoad</code></a> function, which uses <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1615"><code>loadFromIFile</code></a> from <code>Parser.hs</code> which either re-loads an existing IBC file or processes a file via the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1639"><code>loadSource</code></a> function. Similarly, the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L1583"><code>loadModule</code></a> function also checks if a module is already loaded, if not either loads it from an up-to-date IBC file or ends up loading it from source via <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1639"><code>loadSource</code></a>. So either way <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1639"><code>loadSource</code></a> seems like an important part of processing and loading source files in Idris ;).</p>
<p><a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1639"><code>loadSource</code></a> does <em>a lot of things</em><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, such as loading all required IBC files for modules required by that file (which presumably must exist at this point), clears the current IBC cache, parses the file with the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1554"><code>parseProg</code></a> function and then (dam, dam, dam), goes on to elaborate and typecheck the loaded program by calling <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ElabDecls.hs#L148"><code>elabDecls</code></a> on the parsed declarations.</p>
<p>So looking at Idris as a compiler (as opposed to say the REPL functionality), the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ElabDecls.hs#L148"><code>elabDecls</code></a> seems to be the most important entry point into the elaborator. The <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L815"><code>process</code></a> function which seems to be processing REPL commands is also an interesting entry point, as it is processing pieces of Idris code in smaller chunks. It ends up making a few calls to the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Elab/Value.hs#L92"><code>elabVal</code></a> and <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Elab/Value.hs#L135"><code>elabREPL</code></a> (which is a wrapper with a catch around <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Elab/Value.hs#L92"><code>elabVal</code></a>) functions.</p>
<!--
In keeping with the spirit of the [last post], let's try to run the
elaborator on a small piece of Idris code to see what it
does. Spinning up a `cabal repl` as in the last post,
-->
<p>All in all, we’ve basically looked a bit more at how the elaborator ends up being invoked, but not at how it really works. Unfortunately, the latter is really a bit beyond of the scope of these blog posts (at least for now), where I try to familiarize myself with the Idris code base bit by bit. The <a href="https://eb.host.cs.st-andrews.ac.uk/drafts/impldtp.pdf"><em>design and implementation paper</em> (PDF)</a> by Edwin Brady goes into some details of how elaboration works, I am not yet confident to explore this topic here.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I must admit I am a bit unhappy with the plethora of 150+ line monadic functions in the Idris source code, but that’s just a newbie complaining….<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Tue, 15 Mar 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-III-From-Parsing-to-Elaboration.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>A Look at the Idris Internals, Part II: Taking the Parser for a Spin</title>
    <link>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-II-Taking-the-Parser-for-a-Spin.html</link>
    <description><![CDATA[<h1 class="title">A Look at the Idris Internals, Part II: Taking the Parser for a Spin</h1>

<p class="date">published on January 17, 2016</p>

<p>After we’ve looked at how the parser ends up being called in the <a href="/posts/A-look-at-the-Idris-Internals-Part-I-Overview-and-Parsing.html">last post</a>, I thought it would be a fun little exercise to spin up the Idris parser on the GHCi REPL to see if we can get some expressions parsed and what kind of AST they produce.</p>
<p>To spin up ghci, we need to go throught the usual <code>cabal configure &amp;&amp; cabal install</code> dance and then run <code>cabal repl</code>. Calling <code>ghci</code> with the desired target file directly (e.g. <code>Parser.hs</code>) won’t work, as Idris generates some files during build time which won’t be available in this case.</p>
<p>As briefly mentioned in the previous post, we can use the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ParseHelpers.hs#L77"><code>runparser</code></a> function to actually run a specific parser, but how do we call it? The type signature looks a bit hairy at first:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">runparser ::</span> <span class="dt">StateT</span> st <span class="dt">IdrisInnerParser</span> res <span class="ot">-&gt;</span> st <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> res</code></pre></div>
<p>but it’s actually quite simple: The <code>StateT st IdrisInnerParser res</code> is the type in which the different building blocks for the parser are defined. In fact, most of the parser building blocks have a type of <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ParseHelpers.hs#L46"><code>IdrisParser</code></a> and this is just defined by <code>type IdrisParser = StateT IState IdrisInnerParser</code>, so <code>st</code> is specialized to <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L178"><code>IState</code></a>, the big state record in Idris. There is an <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L343"><code>idrisInit</code></a> binding, which defines an empty IState, and we’ll just use that for our experiments at the REPL. All that is left is to pick an appropriate parser for us to start the experiments. Looking at the different building blocks of the parsers, we notice that many take an argument of type <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1443"><code>SyntaxInfo</code></a>. Idris parses some parts of its syntax things differently depending on the context (for example if a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1325"><code>DSL</code></a> binding has been defined). We will not burden ourselves with such details right now and use the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1463"><code>defaultSyntax</code></a> defined in <code>AbsSyntaxTree.hs</code> to keep things simple.</p>
<p>Let’s start with a powerful parser which allows us to parse a siginficant part of the source code. The <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L153"><code>prog</code></a> is easily missed, but it actually allows us to parse full Idris programs. Here is a very simple one:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Idris.Parser</span>
ghci<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Idris.AbsSyntaxTree</span>
ghci<span class="fu">&gt;</span> <span class="kw">let</span> myProgram <span class="fu">=</span> <span class="st">&quot;id : a -&gt; a\nid x = x&quot;</span>;
ghci<span class="fu">&gt;</span> putStrLn myProgram
id <span class="fu">:</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t runparser (prog defaultSyntax) idrisInit <span class="st">&quot;(test)&quot;</span> myProgram
runparser (prog defaultSyntax) idrisInit <span class="st">&quot;(test)&quot;</span> myProgram
<span class="ot">  ::</span> <span class="dt">Text.Trifecta.Result.Result</span> [<span class="dt">PDecl</span>]
ghci<span class="fu">&gt;</span> runparser (prog defaultSyntax) idrisInit <span class="st">&quot;(test)&quot;</span> myProgram
<span class="dt">Success</span> [tydecl id <span class="fu">:</span> a <span class="ot">-&gt;</span> a,pat {_2}       id x  <span class="fu">=</span> x <span class="kw">where</span> []]</code></pre></div>
<p>So we see that the result from the parse is wrapped in a <a href="http://hackage.haskell.org/package/trifecta-1.5.2/docs/Text-Trifecta-Result.html"><code>Result</code></a> datatype from the Trifecta library (this can basically be a <code>Success</code> with the result or a <code>Failure</code> with some information on where the parse went wrong and why) and returns a list of <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L637"><code>PDecl</code></a>, which is the datastructure that represents top-level declarations of the idris language. These are defined in <code>AbsSyntaxTree.hs</code>.</p>
<p>We can see that the actual <code>PDecl</code>s are pretty printed, which is too bad, since we wanted to figure out how the parsing result was exactly represented in the datastructure. My standard hacky way to work around this<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> is to simply comment out the existing show instance for these datatypes and derive them instead. To do this we have to comment out the <code>Show</code> instances on lines 1582 to 1592 in <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1582"><code>AbsSyntaxTree.hs</code></a> and add <code>deriving Show</code> clauses to <code>PDecl'</code>, <code>Directive</code>, <code>PClause</code>, <code>PData'</code>, <code>PTerm</code>, <code>PAltTerm</code>, <code>PDo'</code> and <code>PTactic'</code> in the same file. Doing so and running the above commands at the REPL again gives us (slightly reformatted)</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> runparser (prog defaultSyntax) idrisInit <span class="st">&quot;(test)&quot;</span> myProgram
<span class="dt">Success</span> [
    <span class="dt">PTy</span> (<span class="dt">DocString</span> (<span class="dt">Options</span> { sanitize <span class="fu">=</span> <span class="dt">True</span>, allowRawHtml <span class="fu">=</span> <span class="dt">False</span>
                            , preserveHardBreaks <span class="fu">=</span> <span class="dt">True</span>, debug <span class="fu">=</span> <span class="dt">False</span>})
                   (fromList []))
        []
        (<span class="dt">Syn</span> { using <span class="fu">=</span> [], syn_params <span class="fu">=</span> [], syn_namespace <span class="fu">=</span> [], no_imp <span class="fu">=</span> [], imp_methods <span class="fu">=</span> []
             , decoration <span class="fu">=</span> <span class="fu">&lt;&lt;</span>fn<span class="fu">&gt;&gt;</span>, inPattern <span class="fu">=</span> <span class="dt">False</span>, implicitAllowed <span class="fu">=</span> <span class="dt">False</span>
             , maxline <span class="fu">=</span> <span class="dt">Nothing</span>, mut_nesting <span class="fu">=</span> <span class="dv">0</span>
             , dsl_info <span class="fu">=</span> <span class="dt">DSL</span> { dsl_bind <span class="fu">=</span> <span class="dt">PRef</span> (builtin) [] <span class="fu">&gt;&gt;=</span>
                              , dsl_return <span class="fu">=</span> <span class="dt">PRef</span> (builtin) [] return
                              , dsl_apply <span class="fu">=</span> <span class="dt">PRef</span> (builtin) [] <span class="fu">&lt;*&gt;</span>
                              , dsl_pure <span class="fu">=</span> <span class="dt">PRef</span> (builtin) [] pure
                              , dsl_var <span class="fu">=</span> <span class="dt">Nothing</span>
                              , index_first <span class="fu">=</span> <span class="dt">Nothing</span>
                              , index_next <span class="fu">=</span> <span class="dt">Nothing</span>
                              , dsl_lambda <span class="fu">=</span> <span class="dt">Nothing</span>
                              , dsl_let <span class="fu">=</span> <span class="dt">Nothing</span>
                              , dsl_pi <span class="fu">=</span> <span class="dt">Nothing</span>
                              }
             , syn_in_quasiquote <span class="fu">=</span> <span class="dv">0</span>
             })
        (test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">4</span>
        []
        id
        (test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">3</span>
        (<span class="dt">PPi</span> (<span class="dt">Exp</span> {pargopts <span class="fu">=</span> [], pstatic <span class="fu">=</span> <span class="dt">Dynamic</span>, pparam <span class="fu">=</span> <span class="dt">False</span>})
             __pi_arg
             <span class="dt">No</span> location
             (<span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">6</span><span class="fu">-</span><span class="dv">7</span> [(test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">6</span><span class="fu">-</span><span class="dv">7</span>] a)
             (<span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">11</span><span class="fu">-</span><span class="dv">12</span> [(test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">11</span><span class="fu">-</span><span class="dv">12</span>] a))
  , <span class="dt">PClauses</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span>
             []
             {_2}
             [ <span class="dt">PClause</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">4</span>
                       id
                       (<span class="dt">PApp</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">4</span> (<span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">3</span> [(test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">3</span>] id)
                                              [<span class="dt">PExp</span> { priority <span class="fu">=</span> <span class="dv">1</span>, argopts <span class="fu">=</span> []
                                                    , pname <span class="fu">=</span> {arg0}
                                                    , getTm <span class="fu">=</span> <span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">4</span><span class="fu">-</span><span class="dv">5</span>
                                                                   [(test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">4</span><span class="fu">-</span><span class="dv">5</span>]
                                                                   x
                                                    }])
                       []
                       (<span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">8</span><span class="fu">-</span><span class="dv">9</span> [(test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">8</span><span class="fu">-</span><span class="dv">9</span>] x)
                       []
             ]
]</code></pre></div>
<p>This is a bit long, but going through it bit by bit and ignoring some parts, we can hopefully make sense of it. First, there are two top-level declarations <code>PTy</code> and <code>PClauses</code>, which are constructors of the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L637"><code>PDecl'</code></a> datatype. The <code>PTy</code> is a type declaration which consists of a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Docstrings.hs#L48"><code>Docstring</code></a>, a list of <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Core/TT.hs#L452"><code>Name</code></a>-<a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Docstrings.hs#L48"><code>Docstring</code></a> tuples (presumably for the parameters), a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1443"><code>SyntaxInfo</code></a> (briefly touched on before), a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Core/TT.hs#L83"><code>FC</code></a> (which is a source location and here pretty-printed to <code>(test):1:4</code>, I think this is the position of the <code>:</code>), a list of <code>FnOpt</code> (extra info such as if a function is inlinable, total, etc.), a <code>Name</code>, another <code>FC</code> (source location, this is the position of the name) and finally a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L945"><code>PTerm</code></a>, which is here a <code>PPi</code>, a dependently-typed function type.</p>
<p>The <code>PClauses</code> is a pattern clause, so really the list of pattern matching definitions. It features a source location (<code>FC</code>), a list of function options (<code>FnOpts</code>), a name (this seems to be the <code>{_2}</code> here, indicating that this name was implicitly generated) and a list of <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L751"><code>PClause' PTerm</code></a>, which are the actual clause definitions.</p>
<p>We could drill down further on each of these, and of course there is a ton of details which I blissfully ignore, but I feel like that going this far has given me a fairly good superficial understanding of how parsing works in Idris in the sense that if I needed to find out how something works in detail, I would know where to look and find it fairly quickly. The next post will take a brief look at how the initial parse result is processed further.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If there is a better way, please let me know<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Sun, 17 Jan 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-II-Taking-the-Parser-for-a-Spin.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>A Look at the Idris Internals, Part I: Overview and Parsing</title>
    <link>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-I-Overview-and-Parsing.html</link>
    <description><![CDATA[<h1 class="title">A Look at the Idris Internals, Part I: Overview and Parsing</h1>

<p class="date">published on January 10, 2016</p>

<p><a href="http://idris-lang.org">Idris</a> is a purely functional programming language with full dependent types that I have been interested in for some time. Idris makes some choices that I find very appealing, and so I have been following it and poking around with it every so often. Unfortunately, this interest has so far only resulted in very minor contributions, but that’s not a reason to give up and not try again ;). I have been interested in compilers and code generation in general, and in the Idris backend in particular, so I’m using this new year as an excuse to take another look at the Idris internals. My intention is to write a few posts exploring the Idris compilation process in general and its backend in particular to gain a better understanding of it and hopefully to find a good place to contribute to it.</p>
<p>The goal of this post is to get a fairly high-level overview over how the compilation process works in general and how parsing works in a bit more detail. Future posts will explore the other parts a little deeper. There is a <a href="http://eb.host.cs.st-andrews.ac.uk/drafts/compile-idris.pdf" title="Edwin Brady: Cross-platform compilers for functional languages (PDF)">recent paper</a> by Edwin Brady, the creator of Idris, that explains some aspects of the Idris compilation process. This <a href="http://www.cs.st-andrews.ac.uk/~eb/drafts/impldtp.pdf" title="Edwin Brady: Idris, a General Purpose Dependently Typed Programming Language: Design and Implementation (PDF)">earlier paper</a> focuses more on TT and the type theory, but is of course also very interesting. In comparison to these papers, my goal is to give a more detailed look at the code and possibly also dive a bit deeper into some details that are left out of these papers as they are fairly standard from a research perspective and not that interesting to academics well versed in this topic.</p>
<h2 id="a-high-level-view-of-the-idris-compilation-process">A high-level view of the Idris compilation process</h2>
<p>On a very high level, the Idris compilation process consists of the following steps: First the source code is parsed and an abstract syntax tree (AST) for the high-level Idris language is produced. This language is then slightly desugared, for example by replacing do notation and so on. Then the so-called elaboration process starts, where implicit arguments are infered and the desugared Idris language is converted to the main core language, called TT. In TT all arguments are explicit, yet TT is still a fully dependently typed language. Typechecking occurs at this level. TT is then simplified by converting (possibly dependently-typed) pattern matching into simple case trees, this simplified form of TT is called <em>TT_case</em>. A number of further simplification processes produce successively simpler intermediate languages: <em>IR_case</em> (a first untyped intermediate language), <em>IR_lift</em> where all lambdas have been lifted to the top level, <em>IR_defunc</em> where partially applied functions have been converted to constructors and finally <em>IR_ANF</em> where all function arguments are either constants or variables. These intermediate languages (and some other data) are written to Idris <em>ibc</em> files. Code generators process these files and compile the intermediate languages further to executables.</p>
<h2 id="parsing-and-producing-the-idris-ast">Parsing and producing the Idris AST</h2>
<p>The first step of the compiler is to parse the source code and to produce an AST representing this code. The main file for the <code>idris</code> executable lives in <code>main/Main.hs</code>. This ends up calling the function <code>idrisMain</code> in <code>src/Idris/REPL.hs</code>. This and other functions in that module load code either with the <code>loadFromIFile</code> or <code>loadModule</code> functions, both defined in <code>src/Idris/Parser.hs</code>. This is the main file of the parser, which defines the aformentioned top-level functions for loading code. Other files of interest for the parsing process are <code>ParserExpr.hs</code>, <code>ParserData.hs</code>, <code>ParserOps.hs</code> and <code>ParserHelpers.hs</code>, all of which define different parts of the parser, and, importantly, <code>AbsSyntaxTree.hs</code>, which contains the datatypes for the syntax tree, as well as other important datatypes used in the parsing process.</p>
<p>The function in <code>Parser.hs</code> which actually starts parsing code from is <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L1594"><code>loadSource</code></a>. Interestingly, this function parses a file in two parts, it first parses the imported modules (<a href=""><code>parseImports</code></a>), then proceeds to load these modules and only parses the program afterwards with the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L1509"><code>parseProg</code></a> function.</p>
<p>These functions run in the Idris monad and modify its state, so they’re not just pure parsing functions. The Idris monad is used fairly extensively throughout the compliation process and is a <code>StateT IState</code> on top of <code>ExceptT</code> and <code>IO</code>. <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L178"><code>IState</code></a> is a large record defined in <code>AbsSyntaxTree.hs</code> which mostly lists the known top-level definitions as well as some current state related to elaboration and proving.</p>
<p>Running the parser is accomplished by the aptly-named <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ParseHelpers.hs#L77"><code>runparser</code></a> function from <code>ParseHelpers.hs</code>. This function takes a <code>StateT st IdrisInnerParser res</code> as input, where <code>IdrisInnerParser</code> is just a <code>newtype</code> around a <code>Parser</code> from the <a href="http://hackage.haskell.org/package/trifecta">Trifecta</a> library. Much of the <code>Parse*.hs</code> files define items for the trifecta parser combinators, and are thus relatively straight forward.</p>
<p>The datatypes that represent the high-level language are defined in defined in <code>src/Idris/AbsSyntaxTree.hs</code>. The datatype for top-level declarations is <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L637"><code>PDecl'</code></a>, which is usually parameterized over <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L944"><code>PTerm</code></a>, the main datastructure defining the high-level language terms.</p>
<p>That’s it for the current post, in the next part I’ll take a very brief look at where desugaring, elaboration and TT, Idris’ core language, live.</p>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Sun, 10 Jan 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-I-Overview-and-Parsing.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Release It - Summary and Review</title>
    <link>http://koerbitz.me/posts/Release-It-Summary-And-Review.html</link>
    <description><![CDATA[<h1 class="title">Release It - Summary and Review</h1>

<p class="date">published on January 13, 2015</p>

<p>So I have finally finished reading Michael Nygard’s terribly named but quite interesting book <em>Release It</em>. It covers stability patterns and anti-patterns and offers some interesting ideas and concepts for improving stability.</p>
<h2 id="part-i-stability">Part I: Stability</h2>
<p>The part on stability starts out with an interesting case study that describes how an uncaught exception in a connection pool caused the flight search application of an airline to hang which in turn caused a failure in all check-in systems. The uncaught exception was a programming error, but some errors will inevitably occur. However, these errors must not bring down the entire IT infrastructure of a company! It is thus critical to identify how small errors can cause entire applications to fail and what can be done to mitigate the spread of such failures. The former is examined in ‘Stability Antipatterns’, the latter in ‘Stability Patterns’.</p>
<h3 id="stability-antipatterns">Stability Antipatterns</h3>
<ol style="list-style-type: decimal">
<li><p>Integration Points</p>
<p>Problems are often caused at integration points b/c the remote application may not always act as specified. There is a huge number of failure modes simply connected to TCP connections that an application must protect against if it integrates other applications.</p>
<ul>
<li><p>Every integration point will eventually fail in some way.</p></li>
<li><p>There are many forms of failure</p></li>
<li><p>Peel back abstractions to discover failure modes</p></li>
<li><p>Failures can propagate quickly - stop them!</p></li>
<li><p>Use stability patterns to mitigate: Timeouts, Circuit Breaker, Decoupling Middleware, Handshaking</p></li>
</ul></li>
<li><p>Chain Reactions</p>
<p>Occur when a failure somewhere makes failures somewhere else more likely, but do not causes this directly. For example when one server dies due to a memory leak and other servers must pick up the extra traffic these servers will be more likely to go down due to the same leak because they now must deal with more traffic.</p>
<ul>
<li><p>One server down jeopardizes the rest</p></li>
<li><p>Hunt for resource leaks &amp; timing bugs</p></li>
<li><p>Defend with bulkheads</p></li>
</ul></li>
<li><p>Cascading Failures</p>
<p>Cascading failures happen when failures are one system can jump to the next system. For example, if a hung server somewhere causes client applications to hang because they wait for responses that never come (While they clearly cannot display a response then they should deal with not receiving one in time).</p>
<ul>
<li><p>Deal with failures in remote systems</p></li>
<li><p>Scrutinize resource pools</p></li>
<li><p>Defend with Timeout and Circuit Breaker</p></li>
</ul></li>
<li><p>Users</p>
<p>This deals with te resources that users use. For example memory used up for a user session.</p>
<ul>
<li><p>Users consume memory</p></li>
<li><p>Users do weird things</p></li>
<li><p>Malicious users are out there</p></li>
<li><p>Users will gang up on you</p></li>
</ul></li>
<li><p>Blocked Threads</p>
<p>Threads waiting for responses or resources to free up which never or are very slow to come or free up can cause the application to hang.</p>
<p>Blocked threads can also be caused by deadlocks resulting from concurrency errors. This is obviously a large and complicated topic.</p>
<ul>
<li><p>Blocked threads are the proximate cause of most system failures</p></li>
<li><p>Scrutinize resource pools</p></li>
<li><p>Use proven concurrency primitives (FP!!!)</p></li>
<li><p>Use Timeouts</p></li>
<li><p>Beware of vendor libraries.</p></li>
</ul></li>
<li><p>Attacks of Self-Denial</p>
<p>E.g. deep-links which require sessions and a lot of internal requests of extremely attractive offers on shopping sites. Educate the marketing department.</p>
<ul>
<li><p>Keep lines of communication open</p></li>
<li><p>Expect rapid redistribution of any valuable offer</p></li>
</ul></li>
<li><p>Scaling Effects</p>
<p>Communication patterns that may have been fine with two servers might not scale (e.g. O(n) or worse connections required).</p>
<ul>
<li><p>Examine production vs QA and dev environment to spot scaling effects.</p></li>
<li><p>Watch out for point-to-point communcation</p></li>
<li><p>Watch out for shared resources</p></li>
</ul></li>
<li><p>Unbalanced Capacities</p>
<p>E.g. larger front-end capacities can overwhelm smaller back-end capacities</p>
<ul>
<li><p>Examine server and thread counts</p></li>
<li><p>Stress both sides of the interface</p></li>
</ul></li>
<li><p>Slow Responses</p>
<p>Extremely slow responses cna prevent timeouts from working yet have much the same effect as not receiving a response.</p>
<ul>
<li><p>Slow responses trigger <em>Cascading Failures</em>: upstream systems also slow down.</p></li>
<li><p>Users will hit the reload button -&gt; more traffic.</p></li>
<li><p>Consider to <em>Fail Fast</em>.</p></li>
<li><p>Hunt for memory leaks and resource contention.</p></li>
</ul></li>
<li><p>SLA Inversion</p>
<p>The availability of a set of system is the product of their availabilities. Thus a system depending on five other systems which each provide a 99% guarantee can only guarantee 99%^5=95.1% availability.</p>
<ul>
<li><p>Examine every dependency: DNS, Email, network equipment, database, …</p></li>
<li><p>Decouple dependencies: Make sure you can maintain service even when dependencies go down.</p></li>
</ul></li>
<li><p>Unbounded Result Sets</p>
<p>Applications should also be more sceptical of their databases and e.g. limit the number of results that they are willing to process.</p>
<ul>
<li><p>Limit to realistic data volumes.</p></li>
<li><p>Don’t rely on the producer, enforce limits yourself.</p></li>
<li><p>Put limits into other application level protocols.</p></li>
</ul></li>
</ol>
<h3 id="stability-patterns">Stability Patterns</h3>
<ol style="list-style-type: decimal">
<li><p>Use Timeouts</p>
<p>Hung threads waiting for responses that may never come or come slowly can lead the entire application to block (all threads in a pool are hung). Use timeouts to report an error when this happens.</p>
<ul>
<li><p>Apply to <em>Integration Points</em>, <em>Blocked Threads</em>, <em>Slow Responses</em>.</p></li>
<li><p>Give up and keep moving: it may not matter if we ge a response eventually, time is of the essence.</p></li>
<li><p>Delay retries: Most timeouts are caused by things that don’t resolve imediately, wait a little before trying again.</p></li>
</ul></li>
<li><p>Circuit Breaker</p>
<p>A circuit breaker detects when there is a problem at an integration point and acts accordingly. A circuit breaker counts the number of failures, if these exceed a sensible threshold it triggers and prevents subsequent calls to talk to the integration point. After a timeout a single / few call(s) may be retried, if they work the circuit breaker goes back to its normal state, if not it stays open.</p>
<ul>
<li><p>If there is a problem with an integration point stop calling it!</p></li>
<li><p>Use together with <em>Timeouts</em>: A <em>Timeout</em> detects the problem, a <em>Circuit Breaker</em> keeps us from retrying too often too soon.</p></li>
<li><p>Make it visible to operations: popping a <em>Circuit Breaker</em> usually indicates a serious problem.</p></li>
</ul></li>
<li><p>Bulkheads</p>
<p>Bulkheads partition the system into independent units. When one unit fails the other units are still operational. There are trade-offs with efficient resource usage.</p>
<ul>
<li>Very important when other applications depend on your system: the largest part should keep functioning when there is some problem.</li>
</ul></li>
<li><p>Steady State</p>
<p>Applications should be able to run indefintely without requireing human interventions. The latter leads to fiddeling, which causes errors. This inlcudes cleaning up log-files and disk space at the same rate that they are produced.</p>
<ul>
<li><p>Avoid human interaction, it causes problems.</p></li>
<li><p>Purge data with application logic (e.g. DB entries).</p></li>
<li><p>Limit caching.</p></li>
<li><p>Roll logs.</p></li>
</ul></li>
<li><p>Fail Fast</p>
<p>This pattern deals with the problems caused by ‘slow responses’. An application should determine as soon as possbile if it can service a request and if not it should fail as quickly as possible. There are some trade offs with maintaining encapsulation here.</p>
<ul>
<li><p>Verify integration points early: If required resources are not available it’s time to fail fast.</p></li>
<li><p>Validate input as early as possible.</p></li>
</ul></li>
<li><p>Handshaking</p>
<p>Can be used to determine if an application can accept additional requests. This does double the number of requests and request-latency. Building in the ability to reject requests directly seems more useful to me.</p></li>
<li><p>Test Harness</p>
<p>A sufficiently evil test harness can test the response of an application to misbehaving integration points. It is the point of this test harness to test failure modes which are not specified. For example misbehaving TCP connections or extremely slow responses can be tested with such a test harness.</p>
<p>Consider the following network failures:</p>
<ul>
<li><p>It can be refused.</p></li>
<li><p>It can sit in a listen queue until the caller times out.</p></li>
<li><p>The remote end can reply with a SYN/ACK and then never send any data.</p></li>
<li><p>The remote end can send nothing but RESET packets.</p></li>
<li><p>The remote end can report a full receive window and never drain the data.</p></li>
<li><p>The connection can be established, but the remote end never sends a byte of data.</p></li>
<li><p>The connection can be established, but packets could be lost causing retransmit delays.</p></li>
<li><p>The connection can be established, but the remote end never acknowledges receiving a packet, causing endless retransmits.</p></li>
<li><p>The service can accept a request, send response headers (supposing HTTP), and never send the response body.</p></li>
<li><p>The service can send one byte of the response every thirty seconds.</p></li>
<li><p>The service can send a response of HTML instead of the expected XML.</p></li>
<li><p>The service can send megabytes when kilobytes are expected.</p></li>
<li><p>The service can refuse all authentication credentials.</p></li>
</ul>
<p>Remember these:</p>
<ul>
<li><p>Emulate out-of-spec failures</p></li>
<li><p>Stress the caller: Slow responses, no responses, garbage responses</p></li>
<li><p>Leverage a killer harness for common failures</p></li>
<li><p>Supplement, don’t replace, other testing methods</p></li>
</ul></li>
<li><p>Decoupling Middleware</p>
<p>Asynchronous middleware (e.g. Pub-Sub or messaging communication solutions) force the programmers with the possibility of not receiving a response right away and thus make systems more resilient. They are more difficult to work with than synchronous middleware (but represent the underlying architecture more correctly).</p>
<ul>
<li><p>Total decoupling can avoid many failure modes.</p></li>
<li><p>Learn many architectures, choose the best one for the job.</p></li>
</ul></li>
</ol>
<h2 id="part-ii-capacity">Part II: Capacity</h2>
<p>Another case study rings in the part on capacity: This one is on an online retailer that re-build their system from scratch over three years. When entering load testing it didn’t meet capacity requirements by a factor of 20, after months of testing this imporoved ten-fold.</p>
<p>It crashed badly when it went live, because all the tests had been simulating <em>nice</em> users: users that used the site how it was meant to. In the real world a lot of bots, search engines and other things used the site in non-anticipated ways which it was not prepared for.</p>
<h3 id="introducing-capacity">Introducing Capacity</h3>
<ol style="list-style-type: decimal">
<li><p>Defining Capacity</p>
<p>Performance: How fast does the system process a single transaction?</p>
<p>Throughput: Number of transactions the system can process in a given timespan.</p>
<p>Scalability: Used to describe either (a) how throughput changes under different loads or (b) modes of scaling supported by the system.</p>
<p>Capacity: maximum throughput a system can sustain while meeting performance criteria (e.g. response time).</p></li>
<li><p>Constraints</p>
<p>Aka bottlenecks. At any given point, there will usually one (or more) things constraining capacity. Improving any other factors will not yield more capacity.</p></li>
<li><p>Interrelations</p>
<p>Things are not independent. Decreased performance in one layer can affect other layers.</p></li>
<li><p>Scalability</p>
<p>Horizontal vs. vertical scaling.</p></li>
<li><p>Myths About Capacity</p>
<p>While hardware as such (compared to programmer time) is cheap, dealing with inefficiencies can become more expensive. Optimization may still make sense. All of CPU, storage and bandwith may be more expensive than it seems at first sight.</p></li>
</ol>
<h3 id="capacity-antipatterns">Capacity Antipatterns</h3>
<ol style="list-style-type: decimal">
<li><p>Resource Pool Contention</p>
<p>Requests waiting for resources to become available are a scalability problem.</p></li>
<li><p>Excessive JSP fragments</p>
<p>Java specific. JSP fragments reside in memory and can constrain application server memory.</p></li>
<li><p>Ajax Overkill</p>
<p>Ajax can be used to hammer a server. Don’t build an essantially static homepage with 100 Ajax requests.</p></li>
<li><p>Overstaying Sessions</p>
<p>Sessions memory and are removed with the timeout after user goes away. Should not be kept longer than necessary. Ideal: Information for user is still available even when session expires.</p></li>
<li><p>Wasted Space in HTML</p>
<p>Can add up.</p></li>
<li><p>The Reload Button</p>
<p>Slow requests increase load by causing users to hammer the reload button.</p></li>
<li><p>Handcrafted SQL</p>
<p>In Java land thy shall not work without an ORM.</p></li>
<li><p>Database Eutrophication</p>
<p>The database becomes bigger over time, so things that were OK at on point might not always be.</p></li>
<li><p>Integration Point Latency</p>
<p>Integration points take time to respond and latency adds up.</p></li>
<li><p>Cookie Monsters</p>
<p>Large cookies must be transfered back and forth a lot. Can’t be trusted.</p></li>
</ol>
<h3 id="capacity-patterns">Capacity Patterns</h3>
<ol style="list-style-type: decimal">
<li><p>Pool Connections</p>
<p>Creating a new connection can take upwards of 250ms. So pooling makes sense. Some considerations:</p>
<ul>
<li><p>connections with an error must be detected and fixed</p></li>
<li><p>for which scope should connections be checked out?</p></li>
</ul></li>
<li><p>Use Caching Carefully</p>
<p>It’s a trade off, caching things that are seldomly used and not expensive to generate doesn’t make sense.</p></li>
<li><p>Precompute Content</p>
<p>When it changes much less frequently than it is requested (and it’s worth the effort).</p></li>
<li><p>Tune the GC</p>
<p>JVM specific. GC should ideally take no more than 2% of time.</p></li>
</ol>
<h2 id="part-iii-general-design-issues">Part III: General Design Issues</h2>
<h3 id="networking">Networking</h3>
<ol style="list-style-type: decimal">
<li><p>Multihomed Servers: Contrary to the setup in dev and QA, servers will listen on multiple IPs, not all of them public. This must be accounted for in development.</p></li>
<li><p>Routing: Different NICs might be on different VLANs, remote backend services might require connection through a VPN. Must pay attention to every integration point.</p></li>
<li><p>Virtual IP Addresses: Cluster servers, some info on how virtual IP addresses can be moved from one NIC to another.</p></li>
</ol>
<h3 id="security">Security</h3>
<ol style="list-style-type: decimal">
<li><p>Principle of Least Privilege: Processes should have as few privledges as possible.</p></li>
<li><p>Configured Passwords: Should be kept separate from other configuration files, core dumps should be disabled for production (trade-offs …).</p></li>
</ol>
<h3 id="availability">Availability</h3>
<ol style="list-style-type: decimal">
<li><p>Gathering Availability Requirements: High availability costs money and the requirements must thus be balanced with the costs. Rule of thumb: Each additional ‘9’ increases the implementation cost by a factor of 10 and the operational cost by a factor of 2.</p></li>
<li><p>Documenting Availability Requirements: Once things go down everyone has a different opinion of what available was defined to mean. Important to really define it. Availability should be defined per feature and not be responsible for remote systems one has no control over. A good definition might answer the following questions:</p></li>
</ol>
<ul>
<li><p>How often will the monitoring device execute its synthetic transaction?</p></li>
<li><p>What is the maximum acceptable response time for each step of the transaction?</p></li>
<li><p>What response codes or text patterns indicate success?</p></li>
<li><p>What response codes or text patterns indicate failure?</p></li>
<li><p>How frequently should the synthetic transaction be executed?</p></li>
<li><p>From how many locations?</p></li>
<li><p>Where will the data be recorded?</p></li>
<li><p>What formula will be used to compute the percentage availability? Based on time or number of samples?</p></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Load Balancing</li>
</ol>
<ul>
<li><p>DNS Round-Robin: Several IPs configured for a domain name, DNS returns a different one each time, thus distributing load over the IPs.</p>
<p>Several problems: server IPs must be public (instead of some proxy), too much control over load balancing in clients hands, workloads might still be unbalanced, no failover in case one server goes down. Url rewriting variant with Apache (www7.example.com) even worse.</p></li>
<li><p>Reverse Proxy: intercepts each requests and multiplexes it onto a number of servrs behind it, can cache static content, examples: Squid, Akamai.</p></li>
<li><p>Hardware Load Balancer: specialized networking gear, expensive, SSL a challenge (terminating SSL at the load balancer puts it under a lot of stress).</p></li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>Clustering: Unlike in load balancing servers are aware of each. Can be used for load balancing (active/active) or failover. Do not scale linearly like load-balanced shared nothing architectures. Nygard considers them a band-aid for applications that don’t do clustering / scaling themselves.</li>
</ol>
<h3 id="administration">Administration</h3>
<p>Easy administration leads to good uptime.</p>
<ol style="list-style-type: decimal">
<li><p>Does QA match Production?</p>
<p>Most often it doesn’t. Differences in topology responsible for many outages. It’s advantageous to maintain a similar topology (e.g. seperation of services through firewalls, same multiplicty of connections) in QA as in production.</p>
<p>The cost of downtime often exceeds the cost of the extra network gear required to run the same setup in QA and in production. Pennywise and pound foolish?</p></li>
<li><p>Configuration Files</p>
<p>Don’t keep configuration settings that must be changed by sys admins next to the essential (hard-wired) configuration for the application.</p>
<p>Name configuration properties according to their function, e.g. ‘authenticationServer’ instead of ‘hostname’.</p></li>
<li><p>Start-up and Shutdown</p>
<p>Applications should start up and shut down cleanly and do some minimal checks that they are configured correctly before accepting work (Fail Fast).</p></li>
<li><p>Administrative Interfaces</p>
<p>GUIs look nice but command line interfaces are essential for automation.</p></li>
</ol>
<h2 id="part-iv-operations">Part IV: Operations</h2>
<h3 id="transparency">Transparency</h3>
<p>Transparency allows to gain an understanding of historical trends, present conditions and future projections. Transparency has four facets: historical trends, predictive forecasting, present status and instantaneous behaviour.</p>
<ol style="list-style-type: decimal">
<li><p>Perspectives</p>
<ul>
<li><p>Historical Trending</p></li>
<li><p>Records have to be stored somewhere -&gt; OpsDB</p></li>
<li><p>Can be used to discover new relationships - should be available through tools such as Excel.</p></li>
<li><p>Forecasts</p></li>
<li><p>What’s the capacity?</p></li>
<li><p>When do we have to buy more servers?</p></li>
<li><p>Present Status</p></li>
<li><p>Memory</p></li>
<li><p>Garbage Collection</p></li>
<li><p>Worker threads for each thread pool</p></li>
<li><p>Database connections, for each pool</p></li>
<li><p>Traffic statistics for each request channel</p></li>
<li><p>Business transactions for each type</p></li>
<li><p>Users: demographics, percentage registered, number of users, usage patterns</p></li>
<li><p>Integration points: current state, times used, latency statistics, error count.</p></li>
<li><p>Circuit breakers: current state, error count, latency statistics, number of state transitions.</p></li>
</ul>
<p>The current state can be displayed on a dashboard, e.g. as a traffic light for the system and each component.</p>
<ul>
<li>Instantaneous Behaviour: WTF is going on???</li>
</ul>
<p>Errors, log file entries, thread dumps, … Can, but may not immediately show up in <em>Present Status</em>.</p></li>
<li><p>Desiging for Transparency</p>
<p>Transparency is hard to add later. Both local and global visibility is necessary.</p></li>
<li><p>Enabling Technologies: White box (visibility into the processes) vs. black box (only externally visible metrics)</p></li>
<li><p>Logging</p>
<ul>
<li>Make log file output easy to scan with the eye (p. 246)</li>
</ul></li>
<li><p>Monitoring Systems</p></li>
<li><p>Standards, De Jure and De Facto</p>
<ul>
<li><p>Simple Network Management Protocol: De Facto standard, ASN.1 a bit awkward.</p></li>
<li><p>JMX (Java Management Extensions) de facto standard in the Java world.</p></li>
</ul></li>
<li><p>Operations Database</p>
<p>Good for historical data, forecasts and current status. Not well suited for instantaneous behavior. Receives reports from applications, servers and batch jobs.</p>
<ul>
<li><p>Applications: status variables, business metrics, internal metrics</p></li>
<li><p>Servers: performance, utilization</p></li>
<li><p>Batch Jobs: start, end, abort, completion status, items processed</p></li>
</ul>
<p>The OpsDB can be used to produce a dashboard, various reports and for planning capacity.</p>
<p>Observations should record their type, the measurement, the event and the status.</p></li>
<li><p>Supporting Processes</p>
<p>Must stay in feedback loop when providing data - automated report that nobody reads are <strong>worse than useless</strong>: The cost time and money to create and maintain and provide a false sense of security, yet nobody reads them.</p></li>
</ol>
<h3 id="adaption">Adaption</h3>
<ol style="list-style-type: decimal">
<li><p>Adaptation Over Time</p></li>
<li><p>Adaptable Software Desgin</p>
<ul>
<li><p>Dependency Injection: enables loose coupling, aids testability</p></li>
<li><p>Object Design: Claim: it exists ;)</p></li>
<li><p>XP Coding Practices: Unit testing</p></li>
<li><p>Agile Databases:</p></li>
<li><p>databases must be able to change</p></li>
</ul></li>
<li><p>Adaptable Enterprise Architecture</p>
<p>Prefer loosely clustered, somewhat independent services that can change independently</p>
<ul>
<li>Dependencies Between Systems: Protocols</li>
</ul>
<p>Simultaneous updates at several endpoints is hard, this can be avoided by speaking multiple protocols (or versions of) for a limited time.</p>
<ul>
<li>Dependencies Between Systems: Databases</li>
</ul>
<p>Don’t share databases between services!!!</p></li>
<li><p>Releases Shouldn’t Hurt</p>
<p>Painful releases mean software is released seldomly, automated, zero downtime releases rock!</p></li>
</ol>
<h2 id="my-takeaway">My Takeaway</h2>
<p>Apart from the title, I really did like this book and enjoyed reading it. I found the chapters on stability (anti-)patterns to be very valuable and enlightening. These are patterns that I will definteley introduce in my daily work and as such, even one successful pattern is worth many times the price of the book.</p>
<p>Almost inevitably, the other parts of the book were not quite able to deliver as much useful insights but many had some interesting tidbits nevertheless. While some chapters are a little light on information (e.g. Security and Networking), others (e.g. Transparency) provide useful ideas that will make you think of practical concerns while designing an application. I have certainly seen a number of systems that failed to deliver on every item discussed in the book.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Some topics are covered on a fairly high level and can thus not provide the nitty-gritty detail needed when dealing with the discussed topics hands on, but this is inevitable when trying to cover such a broad range of topics.</p>
<p>All in all I did enjoy the book and recommend it. If you’re short on time I recommend focussing on the part on stability, particularly chapters 3, 4 and 5 which delivered the most value for me.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Building a perfectly designed application that delivers on all fronts is much more difficult in practice than in theory of course. ;)<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Tue, 13 Jan 2015 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Release-It-Summary-And-Review.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Solving the Expression Problem in Haskell and Java</title>
    <link>http://koerbitz.me/posts/Solving-the-Expression-Problem-in-Haskell-and-Java.html</link>
    <description><![CDATA[<h1 class="title">Solving the Expression Problem in Haskell and Java</h1>

<p class="date">published on June 14, 2014</p>

<p>After my <a href="/posts/Sum-Types-Visitors-and-the-Expression-Problem.html">last post</a> on the expression problem, I thought that I would explore ways to solve it in the next post and that I would write that post shortly after. I knew how the solution worked in Haskell and that solutions existed for OO languages, so that post should not have been terribly hard to write. Well, here we are five months later and I am finally getting around to writing the post ;).</p>
<h2 id="expression-problem-recap">Expression Problem Recap</h2>
<p>The term <em>Expression Problem</em> was coined by Philip Waldler in a <a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">mail</a> to the Java Generics mailing list. The goal is to be able to define datatypes by cases and functions over these datatypes in a way that is extensible: one should be able to add both new cases and new functions without touching or recompiling old code and while maintaining static type safety.</p>
<p>As an example I’ll reuse the simple expression language from the last post. To represent such an expression language we will have a number of variants to capture the different types of expressions, for example literal integers, addition, and multiplication. To work with this representation we will have different functions to transform such expressions, for example evaluating or pretty-printing them.</p>
<p>Once we have defined the cases and functions how difficult will it be to add new cases and new functions? Statically type-checked functional languages make it easy to add new functions (see <a href="/posts/Sum-Types-Visitors-and-the-Expression-Problem.html">last post</a>) while the object oriented languages make it easy to add new cases. The default approach in both languages does not make it easy<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> to either add new cases or new functions. That means that the default approach in both languages does not solve the Expression Problem. However, it turns out that solutions are possible in both types of languages. This post will describe a possible solution in both Haskell and Java.</p>
<h2 id="a-haskell-solution">A Haskell Solution</h2>
<p>The key to solving the Expression Problem in Haskell is to define typeclasses for the desired functions and make the datatypes instances of these typeclasses. We also define the different variants as their own datatypes, though this is not strictly necessary yet. For our expression language the setup looks as follows:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lit</span> <span class="fu">=</span> <span class="dt">Lit</span> <span class="dt">Int</span>
<span class="kw">data</span> <span class="dt">Add</span> l r <span class="fu">=</span> <span class="dt">Add</span> l r

<span class="kw">class</span> <span class="dt">Eval</span> x <span class="kw">where</span>
<span class="ot">  eval ::</span> x <span class="ot">-&gt;</span> <span class="dt">Int</span>

<span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Lit</span> <span class="kw">where</span>
  eval (<span class="dt">Lit</span> x) <span class="fu">=</span> x

<span class="kw">instance</span> (<span class="dt">Eval</span> l, <span class="dt">Eval</span> r) <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">Add</span> l r) <span class="kw">where</span>
  eval (<span class="dt">Add</span> l r) <span class="fu">=</span> eval l <span class="fu">+</span> eval r</code></pre></div>
<p>The extension that is typically easy in functional languages is to add a new function over the datatype. With the setup as above, we now add a new typeclass which contains the function as a method and add instances for each of our datatypes. Compared to the standard approach in functional languages, this requires slightly more code, but is still fairly clear:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">PPrint</span> x <span class="kw">where</span>
<span class="ot">  pprint ::</span> x <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="kw">instance</span> <span class="dt">PPrint</span> <span class="dt">Lit</span> <span class="kw">where</span>
  pprint (<span class="dt">Lit</span> x) <span class="fu">=</span> show x

<span class="kw">instance</span> (<span class="dt">PPrint</span> l, <span class="dt">PPrint</span> r) <span class="ot">=&gt;</span> <span class="dt">PPrint</span> (<span class="dt">Add</span> l r) <span class="kw">where</span>
  pprint (<span class="dt">Add</span> l r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> pprint l <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> pprint r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></code></pre></div>
<p>OK, so adding new functions is still easy, how about adding new cases? Adding a new case is the interesting part, because this is the side of the Expression Problem which the standard approach in Haskell can’t handle. However, with the setup we have introduced above this becomes quite easy: we just add a new datatype and then add instances for each of our typeclasses:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Mult</span> l r <span class="fu">=</span> <span class="dt">Mult</span> l r

<span class="kw">instance</span> (<span class="dt">Eval</span> l, <span class="dt">Eval</span> r) <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">Mult</span> l r) <span class="kw">where</span>
  eval (<span class="dt">Mult</span> l r) <span class="fu">=</span> eval l <span class="fu">*</span> eval r

<span class="kw">instance</span> (<span class="dt">PPrint</span> l, <span class="dt">PPrint</span> r) <span class="ot">=&gt;</span> <span class="dt">PPrint</span> (<span class="dt">Mult</span> l r) <span class="kw">where</span>
  pprint (<span class="dt">Mult</span> l r) <span class="fu">=</span> pprint l <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> pprint r</code></pre></div>
<p>OK, so this approach lets us indeed add new cases and new functions without having to modify existing code. Note that we also have type safety: in the code below both <code>eval</code> and <code>pprint</code> can be called on both <code>threePlus5</code> and <code>threePlus5Times7</code> because these operations are defined on each of the datatypes. Had we forgotten to derive a typeclass instance for one of the cases <code>Lit</code>, <code>Add</code> or <code>Mult</code> the compiler would bark. The full code is available at this <a href="https://gist.github.com/paulkoerbitz/106277417325fd43a64c">gist</a>.</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell">threePlus5 <span class="fu">=</span> <span class="dt">Add</span> (<span class="dt">Lit</span> <span class="dv">3</span>) (<span class="dt">Lit</span> <span class="dv">5</span>)
threePlus5Times7 <span class="fu">=</span> <span class="dt">Mult</span> threePlus5 (<span class="dt">Lit</span> <span class="dv">7</span>)

main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="fu">$</span> pprint threePlus5 <span class="fu">++</span> <span class="st">&quot; = &quot;</span> <span class="fu">++</span> show (eval threePlus5)
  putStrLn <span class="fu">$</span> pprint threePlus5Times7 <span class="fu">++</span> <span class="st">&quot; = &quot;</span> <span class="fu">++</span> show (eval threePlus5Times7)</code></pre></div>
<h2 id="a-java-solution">A Java Solution</h2>
<p>Solving the Expression Problem in classical (statically typed) OO languages is a bit more difficult. The solution I’ll present here is taken from the paper <a href="http://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf">Extensibility for the masses (PDF)</a> which has won the ECOOP 2012 best paper award. The idea is to use <em>object algebras</em> which implement so-called <em>algebraic signatures</em>. We will use the same example as above. The algebraic signature for the expression language looks as follows:<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<pre><code>signature E
    lit:  Int -&gt; E
    add:  E x E -&gt; E</code></pre>
<p>The general idea is this: we will represent the above signature as an interface which is parameterized over <code>E</code>. To actually use objects created with this interface we’ll instantiate <code>E</code> to a concrete interface, for example to <code>Eval</code> and call the operations provided by this interface (<code>eval()</code>). However, code creating objects with the above interface does not need to know what <code>E</code> is and can thus be completely generic.</p>
<p>In case this is a bit confusing (it certainly was to me), let’s look at a piece of code which will hopefully make this idea somwhat clearer:</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> Alg1&lt;E&gt; {
    E <span class="fu">lit</span>(<span class="dt">int</span> x);
    E <span class="fu">add</span>(E l, E r);
}

<span class="kw">class</span> Impl1&lt;E&gt; {
    <span class="kw">public</span> <span class="dt">static</span> &lt;E&gt; E <span class="fu">make3Plus5</span>(Alg1&lt;E&gt; f) {
        <span class="kw">return</span> f.<span class="fu">add</span>(f.<span class="fu">lit</span>(<span class="dv">3</span>), f.<span class="fu">lit</span>(<span class="dv">5</span>));
    }
}

<span class="kw">interface</span> Eval {
    <span class="dt">int</span> <span class="fu">eval</span>();
}

<span class="kw">class</span> ELit <span class="kw">implements</span> Eval {
    <span class="kw">private</span> <span class="dt">int</span> x;
    <span class="kw">public</span> <span class="fu">ELit</span>(<span class="dt">int</span> x) { <span class="kw">this</span>.<span class="fu">x</span> = x; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">eval</span>() { <span class="kw">return</span> x; }
}

<span class="kw">class</span> EAdd <span class="kw">implements</span> Eval {
    <span class="kw">private</span> Eval l, r;
    <span class="kw">public</span> <span class="fu">EAdd</span>(Eval l, Eval r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">eval</span>() { <span class="kw">return</span> l.<span class="fu">eval</span>() + r.<span class="fu">eval</span>(); }
}

<span class="kw">class</span> Alg1EvalFactory <span class="kw">implements</span> Alg1&lt;Eval&gt; {
    <span class="kw">public</span> Eval <span class="fu">lit</span>(<span class="dt">int</span> x) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">ELit</span>(x); }
    <span class="kw">public</span> Eval <span class="fu">add</span>(Eval l, Eval r) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">EAdd</span>(l, r); }
}

<span class="kw">class</span> Impl2 {
    <span class="dt">static</span> <span class="dt">int</span> <span class="fu">eval3Plus5</span>() {
        <span class="kw">return</span> Impl1.<span class="fu">make3Plus5</span>(<span class="kw">new</span> <span class="fu">Alg1EvalFactory</span>()).<span class="fu">eval</span>();
    }
}</code></pre></div>
<p>So we first define a generic interface called <code>Alg1</code> which represents the algebraic signature above.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> Programs such as <code>make3Plus5</code> can use this interface completely generically without needing to know what <code>E</code> acutally is.</p>
<p>Only when we acutally want to use the objects created from the <code>Alg1</code> interface do we need to define a concrete interface such as <code>Eval</code> and classes that implement it. We also need a class that implements <code>Alg1&lt;E&gt;</code>, in the code above this is <code>Alg1EvalFactory</code>. An instance of this factory is passed to the generic program <code>make3Plus5</code> which then produces an object which implements <code>Eval</code> so that we can call the <code>eval()</code> method on it.</p>
<p>Comparing this approach to the Haskell one there are some similarities: The <code>interface Eval</code> here plays the role of the <code>typeclass Eval</code> in the Haskell version and the classes <code>ELit</code> and <code>EAdd</code> correspond to the instance declarations. The piece that is missing from the Haskell version is the <code>Alg1</code> interface and its implementation, but I think there are some similarities to what the Haskell compiler does behind the scenes.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>Now let’s check if we can extend this setup with both new functions and new variants. First, adding new functions is fairly easy: The interface <code>Alg1</code> can stay unchanged, we merely need to create a new interface <code>PPrint</code> which will take the place of <code>Eval</code> and corresponding classes <code>PLit</code> and <code>PAdd</code> that implement this interface. To actually make use of <code>Alg1</code> instantiated to this new interface we also need a new factory.</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> PPrint {
    <span class="kw">public</span> String <span class="fu">pprint</span>();
}

<span class="kw">class</span> PLit <span class="kw">implements</span> PPrint {
    <span class="kw">private</span> <span class="dt">int</span> x;
    <span class="kw">public</span> <span class="fu">PLit</span>(<span class="dt">int</span> x) { <span class="kw">this</span>.<span class="fu">x</span> = x; }
    <span class="kw">public</span> String <span class="fu">pprint</span>() { <span class="kw">return</span> Integer.<span class="fu">valueOf</span>(x).<span class="fu">toString</span>(); }
}

<span class="kw">class</span> PAdd <span class="kw">implements</span> PPrint {
    <span class="kw">private</span> PPrint l, r;
    <span class="kw">public</span> <span class="fu">PAdd</span>(PPrint l, PPrint r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> String <span class="fu">pprint</span>() { <span class="kw">return</span> <span class="st">&quot;(&quot;</span> + l.<span class="fu">pprint</span>() + <span class="st">&quot; + &quot;</span> + r.<span class="fu">pprint</span>() + <span class="st">&quot;)&quot;</span>; }
}

<span class="kw">class</span> Alg1PPrintFactory <span class="kw">implements</span> Alg1&lt;PPrint&gt; {
    <span class="kw">public</span> PPrint <span class="fu">lit</span>(<span class="dt">int</span> x) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">PLit</span>(x); }
    <span class="kw">public</span> PPrint <span class="fu">add</span>(PPrint l, PPrint r) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">PAdd</span>(l, r); }
}

<span class="kw">class</span> Impl3 {
    <span class="dt">static</span> String <span class="fu">pprint3Plus5</span>() {
        <span class="kw">return</span> Impl1.<span class="fu">make3Plus5</span>(<span class="kw">new</span> <span class="fu">Alg1PPrintFactory</span>()).<span class="fu">pprint</span>();
    }
}</code></pre></div>
<p>This may look like a lot of code, but again, this roughly corresponds to the Haskell version. We did not need to duplicate any code (apart from the usual boilerplate that is required by Java). Also note that we were able to reuse <code>make3Plus5</code> from above even though we’re now using a new operation on its result!</p>
<p>So we can add new functions over the datatype cases. To add new cases we need to extend the signature <code>Alg1</code> to <code>Alg2</code> to accomodate the new case. We then need to add classes that implement the concrete interfaces <code>Eval</code> and <code>PPrint</code> for this new cases. Furthermore, we also need new factories which implement the interface <code>Alg2&lt;Eval&gt;</code> and <code>Alg2&lt;PPrint&gt;</code>. Again, this is slightly more code than one would love to write, but it is completely extensible (note for example that we are reusing <code>make3Plus5</code> unchanged with a factory that implements <code>Alg2&lt;E&gt;</code>):</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> Alg2&lt;E&gt; <span class="kw">extends</span> Alg1&lt;E&gt; {
    E <span class="fu">mult</span>(E l, E r);
}

<span class="kw">class</span> EMult <span class="kw">implements</span> Eval {
    <span class="kw">private</span> Eval l, r;
    <span class="kw">public</span> <span class="fu">EMult</span>(Eval l, Eval r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">eval</span>() { <span class="kw">return</span> l.<span class="fu">eval</span>() * r.<span class="fu">eval</span>(); }
}

<span class="kw">class</span> PMult <span class="kw">implements</span> PPrint {
    <span class="kw">private</span> PPrint l, r;
    <span class="kw">public</span> <span class="fu">PMult</span>(PPrint l, PPrint r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> String <span class="fu">pprint</span>() { <span class="kw">return</span> l.<span class="fu">pprint</span>() + <span class="st">&quot; * &quot;</span> + r.<span class="fu">pprint</span>(); }
}

<span class="kw">class</span> Alg2EvalFactory <span class="kw">extends</span> Alg1EvalFactory <span class="kw">implements</span> Alg2&lt;Eval&gt; {
    <span class="kw">public</span> Eval <span class="fu">mult</span>(Eval l, Eval r) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">EMult</span>(l, r); }
}

<span class="kw">class</span> Alg2PPrintFactory <span class="kw">extends</span> Alg1PPrintFactory <span class="kw">implements</span> Alg2&lt;PPrint&gt; {
    <span class="kw">public</span> PPrint <span class="fu">mult</span>(PPrint l, PPrint r) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">PMult</span>(l, r); }
}

<span class="kw">class</span> Impl4&lt;E&gt; {
    <span class="co">// a client program using Alg2 (which uses a function using Alg1!)</span>
    <span class="kw">public</span> <span class="dt">static</span> &lt;E&gt; E <span class="fu">make3Plus5Times7</span>(Alg2&lt;E&gt; f) {
        <span class="kw">return</span> f.<span class="fu">mult</span>(Impl1.<span class="fu">make3Plus5</span>(f), f.<span class="fu">lit</span>(<span class="dv">7</span>));
    }

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">eval3Plus5Times7</span>() {
        <span class="kw">return</span> <span class="fu">make3Plus5Times7</span>(<span class="kw">new</span> <span class="fu">Alg2EvalFactory</span>()).<span class="fu">eval</span>();
    }

    <span class="kw">public</span> <span class="dt">static</span> String <span class="fu">pprint3Plus5Times7</span>() {
        <span class="kw">return</span> <span class="fu">make3Plus5Times7</span>(<span class="kw">new</span> <span class="fu">Alg2PPrintFactory</span>()).<span class="fu">pprint</span>();
    }
}</code></pre></div>
<p>For completeness, here is a main method which uses the above and gives the same output as the Haskell version. The full code can be found at this <a href="https://gist.github.com/paulkoerbitz/106277417325fd43a64c">gist</a>.</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Main {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args)
    {
        System.<span class="fu">out</span>.<span class="fu">println</span>(Impl3.<span class="fu">pprint3Plus5</span>() + <span class="st">&quot; = &quot;</span>
                           + Integer.<span class="fu">valueOf</span>(Impl2.<span class="fu">eval3Plus5</span>()).<span class="fu">toString</span>());
        System.<span class="fu">out</span>.<span class="fu">println</span>(Impl4.<span class="fu">pprint3Plus5Times7</span>() + <span class="st">&quot; = &quot;</span>
                           + Integer.<span class="fu">valueOf</span>(Impl4.<span class="fu">eval3Plus5Times7</span>()).<span class="fu">toString</span>());
    }
}</code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>So this post gave a quick demonstration of how the Expression Problem can be solved both in Haskell and Java. I think it is pretty cool that the Expression Problem is actually solvable in a language like Java because I first thought that that wasn’t the case. On the one hand the Java version seems pretty heavyweight in terms of additional complexity. I therefore doubt that I would reach for this solution in practice unless I was certain in advance that solving the Expression Problem is important for a particular application and that it would justify the conceptual overhead. On the other hand this solution doesn’t feel conceptually much heavier than the visitor pattern and this solution solves both sides of the Expression Problem while the visitor pattern only solves one.</p>
<p>In the end I just wish I could use Haskell ;).</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Easy here means that no code needs to be changed / dublicated and type-safety is maintained.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Note the similarity to type classes!<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The paper calls such interfaces <em>object algebras</em> and goes a bit into the category theoretical motivations for these terms which I’m ignoring here.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Clearly the Haskell code is considerably easier to understand and - I would argue - also more elegant, but let’s not get into that.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Sat, 14 Jun 2014 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Solving-the-Expression-Problem-in-Haskell-and-Java.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Sum Types, Visitors, and the Expression Problem</title>
    <link>http://koerbitz.me/posts/Sum-Types-Visitors-and-the-Expression-Problem.html</link>
    <description><![CDATA[<h1 class="title">Sum Types, Visitors, and the Expression Problem</h1>

<p class="date">published on January 10, 2014</p>

<p>I’ve heard that <em>the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a> is just a poor way of getting the benefit of sum types</em><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> in functional programming circles several times. I must admit that I never had completely thought this through, but I was nevertheless a bit surprised when I saw that walking the AST in Rust was implemented by what looks like a use of the visitor pattern. Languages with sum types usually use pattern matching to achieve the same effect and I had always considered this a superior approach. In this blog post I try to understand the differences and similarities of the two approaches a little better.</p>
<p>To set the stage, both pattern matching and the visitor pattern solve one side of the <a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">expression problem</a>, which is the problem of adding both variants of a data type and functions that act on those variants without changing or recompiling old code and without loosing type safety.</p>
<p>To make this a bit more concrete, consider a very simple expression languages consisting of numbers and addition as an example (no post on this topic can do without one!). We have two variants of expressions, (1) numbers and (2) addition. Let’s assume that we want to compute the values represented by an expression as a first operation.</p>
<p>In Haskell a straightforward way of solving this problem is as follows</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span>

<span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
eval (<span class="dt">Val</span> i)     <span class="fu">=</span> i
eval (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">+</span> eval e2</code></pre></div>
<p>If you’re not familiar with Haskell, the first line defines a data type with two variants, it can either be a <code>Val</code>, which holds an <code>Int</code>, or it is an <code>Add</code> which holds two expressions. <code>Val</code> and <code>Add</code> are called constructors of <code>Expr</code>. The <code>eval</code> function pattern-matches and handles each case.</p>
<p>Now imagine that we do not only want to evaluate expressions but also pretty-print them. Adding operations is easy in Haskell, we just write a new function:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">pprint ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
pprint (<span class="dt">Val</span> i)     <span class="fu">=</span> show i
pprint (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> pprint e1 <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> pprint e2</code></pre></div>
<p>In Java we might achieve something similar by introducing an <code>Expr</code> class:</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> Expr {
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">eval</span>();
}

<span class="kw">class</span> Val <span class="kw">implements</span> Expr {
    <span class="kw">private</span> <span class="dt">final</span> <span class="dt">int</span> v;
    <span class="kw">public</span> <span class="fu">Val</span>(<span class="dt">int</span> v) { <span class="kw">this</span>.<span class="fu">v</span> = v; }
    <span class="kw">public</span> <span class="dt">int</span> eval { <span class="kw">return</span> v; }
}

<span class="kw">class</span> Add <span class="kw">implements</span> Expr {
    <span class="kw">private</span> <span class="dt">final</span> Expr l;
    <span class="kw">private</span> <span class="dt">final</span> Expr r;
    <span class="kw">public</span> <span class="fu">Add</span>(Expr l, Expr r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> <span class="dt">int</span> eval { <span class="kw">return</span> l.<span class="fu">eval</span>() + r.<span class="fu">eval</span>(); }
}</code></pre></div>
<p>But now, if we want to add the <code>pprint</code> operation, we have to touch every class. This is the side of the expression problem that functional languages tend to solve better than object oriented languages. However, the object oriented programming community has devised the visitor pattern as a way to solve this problem:</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> ExprVisitor {
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Val v);
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Add a);
}

<span class="kw">interface</span> Expr {
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">accept</span>(ExprVisitor visitor);
}

<span class="kw">class</span> Val <span class="kw">implements</span> Expr {
    <span class="kw">private</span> <span class="dt">int</span> v;
    <span class="kw">public</span> <span class="fu">Val</span>(<span class="dt">int</span> v) { <span class="kw">this</span>.<span class="fu">v</span> = v; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">val</span>()  { <span class="kw">return</span> v; }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">accept</span>(ExprVisitor visitor) { visitor.<span class="fu">visit</span>(<span class="kw">this</span>); }
}

<span class="kw">class</span> Add : <span class="kw">public</span> Expr {
    <span class="kw">private</span> Expr l;
    <span class="kw">private</span> Expr r;
    <span class="kw">public</span> <span class="fu">Add</span>(Expr l, Expr r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> Expr <span class="fu">l</span>() { <span class="kw">return</span> l; }
    <span class="kw">public</span> Expr <span class="fu">r</span>() { <span class="kw">return</span> r; }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">accept</span>(ExprVisitor visitor) { visitor.<span class="fu">visit</span>(*<span class="kw">this</span>); }
}

<span class="kw">class</span> EvalVisitor <span class="kw">implements</span> ExprVisitor {
   <span class="kw">private</span> <span class="dt">int</span> result = <span class="dv">0</span>;
   <span class="kw">public</span> <span class="dt">int</span> <span class="fu">result</span>() { <span class="kw">return</span> result; }
   <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Val val) { result = val.<span class="fu">val</span>(); }
   <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Add add) {
        add.<span class="fu">l</span>().<span class="fu">accept</span>(<span class="kw">this</span>);
        <span class="dt">int</span> result_l = result;
        add.<span class="fu">r</span>().<span class="fu">accept</span>(<span class="kw">this</span>);
        result += result_l;
    }
}</code></pre></div>
<p>Ok, this is not exactly pretty, but let’s not forget that this is the side of the problem where OO languages are not good at. At least we can pull something of. And now we are in a situation where we can add new operations pretty easily:</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">class</span> PprintVisitor <span class="kw">extends</span> ExprVisitor {
    <span class="kw">private</span> String result = <span class="st">&quot;&quot;</span>;
    <span class="kw">public</span> String <span class="fu">result</span>() { <span class="kw">return</span> result; }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Val val) override { result += val.<span class="fu">val</span>(); }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Add add) override {
        add.<span class="fu">l</span>().<span class="fu">visit</span>(<span class="kw">this</span>);
        result += <span class="st">&quot; + &quot;</span>;
        add.<span class="fu">r</span>().<span class="fu">visit</span>(<span class="kw">this</span>);
    }
}</code></pre></div>
<p>This works, but the Haskell solution is clearly more elegant. Does the visitor pattern have any additional advantages? Well, neither approach solves the expression problem: if we want to add a new variant, say a <code>Mult</code>, then we have to change existing code in both cases.</p>
<p>I can’t really think of an advantage for the visitor pattern. I’ve thought of two possibilities, <em>default implementations</em> and <em>almost-but-not-quite-solving-the-expression-problem</em>. But then I realized that the first problem is also similarly solvable in the pattern matching approach and that the second problem doesn’t work without loosing type safety or duplicating code:<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<ol style="list-style-type: decimal">
<li><p><em>Default implementations</em> are easy to implement with both approaches: in the visitor pattern defaults can be achieved by inherenting from a visitor with default implementations and overriding only certain methods. In the pattern-matching approach we would match all the constructors where we want to override the defaults and insert a wildcard match for the rest and call the default implementaiton on the bound variable.</p></li>
<li><p><em>Almost-but-not-quite-solving-the-expression-problem</em>: I first thought that we could use some inheritance based trickery to solve the expression problem at least for new code. But none of these seems to work: If we add a new variant, say <code>Mult</code>, it can’t derive from <code>Expr</code> because then it would have to implement <code>Expr</code>’s accept method, which it can’t sensibly do (because there is no right <code>visit</code> method in <code>ExprVisitor</code>).</p>
<p>Thus we must introduce a new interface <code>Expr2</code>. <code>Expr2</code> cannot derive from <code>Expr</code>, lest we have the same problem as before. But the old variants don’t derive from <code>Expr2</code>, so this is of limited use. Whichever way we twist or turn it, there is no easy way to solve the expression problem with this pattern.</p></li>
</ol>
<p>So, as it stands, I can’t really come up with an advantage for the visitor pattern over pattern matching. If you work in a language without sum types then it is certainly a great workaround, but in a language that does pattern matching seems much both more concise and more efficient.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>These are also known as disjoint union or variant types.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Both maintaining type safety and not duplicating code are requirements in the expression problem.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Due to the virtual method calls, which prevent inlining, I would expect the visitor pattern to be much slower than a direct function call.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Fri, 10 Jan 2014 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Sum-Types-Visitors-and-the-Expression-Problem.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>

    </channel>
</rss>
