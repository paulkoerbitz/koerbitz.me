<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Types and Tailcalls: Yet Another Programmer's Blog by Paul Koerbitz</title>
        <link>http://koerbitz.me</link>
        <description><![CDATA[Thoughts and ideas about programming, with an eye towards functional programming techniques]]></description>
        <atom:link href="http://koerbitz.me/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 15 Mar 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>A Look at the Idris Internals, Part III: From Parsing to Elaboration</title>
    <link>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-III-From-Parsing-to-Elaboration.html</link>
    <description><![CDATA[<h1 class="title">A Look at the Idris Internals, Part III: From Parsing to Elaboration</h1>

<p class="date">published on March 15, 2016</p>

<p>So after looking at the parser in the <a href="/posts/A-Look-at-the-Idris-Internals-Part-II-Taking-the-Parser-for-a-Spin.html">last post</a>, this post will explore what happens after an Idris has been parsed, namely how it is desugared and elaborated to a TT program.</p>
<p>Looking throught the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L1635"><code>idrisMain</code></a> method in <code>REPL.hs</code>, it seems that code is actually loaded by either the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L1535"><code>loadInputs</code></a> function (also in <code>REPL.hs</code>) or the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L1583"><code>loadModule</code></a> from <code>Parser.hs</code>.</p>
<p><a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L1535"><code>loadInputs</code></a> <em>loads</em> a list of Idris files, meaning that it tries to completely process these files (reading, parsing, elaborating, saving the state in the <code>IState</code>) and all their dependencies. It uses the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Chaser.hs#L116"><code>buildTree</code></a> function from <code>Chaser.hs</code> to retrieve the actual files along with modification times and indicating if a file needs to be re-loaded. It uses the locally defined <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L1599"><code>tryLoad</code></a> function, which uses <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1615"><code>loadFromIFile</code></a> from <code>Parser.hs</code> which either re-loads an existing IBC file or processes a file via the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1639"><code>loadSource</code></a> function. Similarly, the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L1583"><code>loadModule</code></a> function also checks if a module is already loaded, if not either loads it from an up-to-date IBC file or ends up loading it from source via <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1639"><code>loadSource</code></a>. So either way <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1639"><code>loadSource</code></a> seems like an important part of processing and loading source files in Idris ;).</p>
<p><a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1639"><code>loadSource</code></a> does <em>a lot of things</em><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, such as loading all required IBC files for modules required by that file (which presumably must exist at this point), clears the current IBC cache, parses the file with the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#1554"><code>parseProg</code></a> function and then (dam, dam, dam), goes on to elaborate and typecheck the loaded program by calling <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ElabDecls.hs#L148"><code>elabDecls</code></a> on the parsed declarations.</p>
<p>So looking at Idris as a compiler (as opposed to say the REPL functionality), the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ElabDecls.hs#L148"><code>elabDecls</code></a> seems to be the most important entry point into the elaborator. The <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/REPL.hs#L815"><code>process</code></a> function which seems to be processing REPL commands is also an interesting entry point, as it is processing pieces of Idris code in smaller chunks. It ends up making a few calls to the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Elab/Value.hs#L92"><code>elabVal</code></a> and <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Elab/Value.hs#L135"><code>elabREPL</code></a> (which is a wrapper with a catch around <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Elab/Value.hs#L92"><code>elabVal</code></a>) functions.</p>
<!--
In keeping with the spirit of the [last post], let's try to run the
elaborator on a small piece of Idris code to see what it
does. Spinning up a `cabal repl` as in the last post,
-->
<p>All in all, we’ve basically looked a bit more at how the elaborator ends up being invoked, but not at how it really works. Unfortunately, the latter is really a bit beyond of the scope of these blog posts (at least for now), where I try to familiarize myself with the Idris code base bit by bit. The <a href="https://eb.host.cs.st-andrews.ac.uk/drafts/impldtp.pdf"><em>design and implementation paper</em> (PDF)</a> by Edwin Brady goes into some details of how elaboration works, I am not yet confident to explore this topic here.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I must admit I am a bit unhappy with the plethora of 150+ line monadic functions in the Idris source code, but that’s just a newbie complaining….<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Tue, 15 Mar 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-III-From-Parsing-to-Elaboration.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>A Look at the Idris Internals, Part II: Taking the Parser for a Spin</title>
    <link>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-II-Taking-the-Parser-for-a-Spin.html</link>
    <description><![CDATA[<h1 class="title">A Look at the Idris Internals, Part II: Taking the Parser for a Spin</h1>

<p class="date">published on January 17, 2016</p>

<p>After we’ve looked at how the parser ends up being called in the <a href="/posts/A-look-at-the-Idris-Internals-Part-I-Overview-and-Parsing.html">last post</a>, I thought it would be a fun little exercise to spin up the Idris parser on the GHCi REPL to see if we can get some expressions parsed and what kind of AST they produce.</p>
<p>To spin up ghci, we need to go throught the usual <code>cabal configure &amp;&amp; cabal install</code> dance and then run <code>cabal repl</code>. Calling <code>ghci</code> with the desired target file directly (e.g. <code>Parser.hs</code>) won’t work, as Idris generates some files during build time which won’t be available in this case.</p>
<p>As briefly mentioned in the previous post, we can use the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ParseHelpers.hs#L77"><code>runparser</code></a> function to actually run a specific parser, but how do we call it? The type signature looks a bit hairy at first:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">runparser ::</span> <span class="dt">StateT</span> st <span class="dt">IdrisInnerParser</span> res <span class="ot">-&gt;</span> st <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> res</code></pre></div>
<p>but it’s actually quite simple: The <code>StateT st IdrisInnerParser res</code> is the type in which the different building blocks for the parser are defined. In fact, most of the parser building blocks have a type of <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ParseHelpers.hs#L46"><code>IdrisParser</code></a> and this is just defined by <code>type IdrisParser = StateT IState IdrisInnerParser</code>, so <code>st</code> is specialized to <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L178"><code>IState</code></a>, the big state record in Idris. There is an <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L343"><code>idrisInit</code></a> binding, which defines an empty IState, and we’ll just use that for our experiments at the REPL. All that is left is to pick an appropriate parser for us to start the experiments. Looking at the different building blocks of the parsers, we notice that many take an argument of type <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1443"><code>SyntaxInfo</code></a>. Idris parses some parts of its syntax things differently depending on the context (for example if a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1325"><code>DSL</code></a> binding has been defined). We will not burden ourselves with such details right now and use the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1463"><code>defaultSyntax</code></a> defined in <code>AbsSyntaxTree.hs</code> to keep things simple.</p>
<p>Let’s start with a powerful parser which allows us to parse a siginficant part of the source code. The <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L153"><code>prog</code></a> is easily missed, but it actually allows us to parse full Idris programs. Here is a very simple one:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Idris.Parser</span>
ghci<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Idris.AbsSyntaxTree</span>
ghci<span class="fu">&gt;</span> <span class="kw">let</span> myProgram <span class="fu">=</span> <span class="st">&quot;id : a -&gt; a\nid x = x&quot;</span>;
ghci<span class="fu">&gt;</span> putStrLn myProgram
id <span class="fu">:</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t runparser (prog defaultSyntax) idrisInit <span class="st">&quot;(test)&quot;</span> myProgram
runparser (prog defaultSyntax) idrisInit <span class="st">&quot;(test)&quot;</span> myProgram
<span class="ot">  ::</span> <span class="dt">Text.Trifecta.Result.Result</span> [<span class="dt">PDecl</span>]
ghci<span class="fu">&gt;</span> runparser (prog defaultSyntax) idrisInit <span class="st">&quot;(test)&quot;</span> myProgram
<span class="dt">Success</span> [tydecl id <span class="fu">:</span> a <span class="ot">-&gt;</span> a,pat {_2}       id x  <span class="fu">=</span> x <span class="kw">where</span> []]</code></pre></div>
<p>So we see that the result from the parse is wrapped in a <a href="http://hackage.haskell.org/package/trifecta-1.5.2/docs/Text-Trifecta-Result.html"><code>Result</code></a> datatype from the Trifecta library (this can basically be a <code>Success</code> with the result or a <code>Failure</code> with some information on where the parse went wrong and why) and returns a list of <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L637"><code>PDecl</code></a>, which is the datastructure that represents top-level declarations of the idris language. These are defined in <code>AbsSyntaxTree.hs</code>.</p>
<p>We can see that the actual <code>PDecl</code>s are pretty printed, which is too bad, since we wanted to figure out how the parsing result was exactly represented in the datastructure. My standard hacky way to work around this<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> is to simply comment out the existing show instance for these datatypes and derive them instead. To do this we have to comment out the <code>Show</code> instances on lines 1582 to 1592 in <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1582"><code>AbsSyntaxTree.hs</code></a> and add <code>deriving Show</code> clauses to <code>PDecl'</code>, <code>Directive</code>, <code>PClause</code>, <code>PData'</code>, <code>PTerm</code>, <code>PAltTerm</code>, <code>PDo'</code> and <code>PTactic'</code> in the same file. Doing so and running the above commands at the REPL again gives us (slightly reformatted)</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> runparser (prog defaultSyntax) idrisInit <span class="st">&quot;(test)&quot;</span> myProgram
<span class="dt">Success</span> [
    <span class="dt">PTy</span> (<span class="dt">DocString</span> (<span class="dt">Options</span> { sanitize <span class="fu">=</span> <span class="dt">True</span>, allowRawHtml <span class="fu">=</span> <span class="dt">False</span>
                            , preserveHardBreaks <span class="fu">=</span> <span class="dt">True</span>, debug <span class="fu">=</span> <span class="dt">False</span>})
                   (fromList []))
        []
        (<span class="dt">Syn</span> { using <span class="fu">=</span> [], syn_params <span class="fu">=</span> [], syn_namespace <span class="fu">=</span> [], no_imp <span class="fu">=</span> [], imp_methods <span class="fu">=</span> []
             , decoration <span class="fu">=</span> <span class="fu">&lt;&lt;</span>fn<span class="fu">&gt;&gt;</span>, inPattern <span class="fu">=</span> <span class="dt">False</span>, implicitAllowed <span class="fu">=</span> <span class="dt">False</span>
             , maxline <span class="fu">=</span> <span class="dt">Nothing</span>, mut_nesting <span class="fu">=</span> <span class="dv">0</span>
             , dsl_info <span class="fu">=</span> <span class="dt">DSL</span> { dsl_bind <span class="fu">=</span> <span class="dt">PRef</span> (builtin) [] <span class="fu">&gt;&gt;=</span>
                              , dsl_return <span class="fu">=</span> <span class="dt">PRef</span> (builtin) [] return
                              , dsl_apply <span class="fu">=</span> <span class="dt">PRef</span> (builtin) [] <span class="fu">&lt;*&gt;</span>
                              , dsl_pure <span class="fu">=</span> <span class="dt">PRef</span> (builtin) [] pure
                              , dsl_var <span class="fu">=</span> <span class="dt">Nothing</span>
                              , index_first <span class="fu">=</span> <span class="dt">Nothing</span>
                              , index_next <span class="fu">=</span> <span class="dt">Nothing</span>
                              , dsl_lambda <span class="fu">=</span> <span class="dt">Nothing</span>
                              , dsl_let <span class="fu">=</span> <span class="dt">Nothing</span>
                              , dsl_pi <span class="fu">=</span> <span class="dt">Nothing</span>
                              }
             , syn_in_quasiquote <span class="fu">=</span> <span class="dv">0</span>
             })
        (test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">4</span>
        []
        id
        (test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">3</span>
        (<span class="dt">PPi</span> (<span class="dt">Exp</span> {pargopts <span class="fu">=</span> [], pstatic <span class="fu">=</span> <span class="dt">Dynamic</span>, pparam <span class="fu">=</span> <span class="dt">False</span>})
             __pi_arg
             <span class="dt">No</span> location
             (<span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">6</span><span class="fu">-</span><span class="dv">7</span> [(test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">6</span><span class="fu">-</span><span class="dv">7</span>] a)
             (<span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">11</span><span class="fu">-</span><span class="dv">12</span> [(test)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">11</span><span class="fu">-</span><span class="dv">12</span>] a))
  , <span class="dt">PClauses</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span>
             []
             {_2}
             [ <span class="dt">PClause</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">4</span>
                       id
                       (<span class="dt">PApp</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">4</span> (<span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">3</span> [(test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">3</span>] id)
                                              [<span class="dt">PExp</span> { priority <span class="fu">=</span> <span class="dv">1</span>, argopts <span class="fu">=</span> []
                                                    , pname <span class="fu">=</span> {arg0}
                                                    , getTm <span class="fu">=</span> <span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">4</span><span class="fu">-</span><span class="dv">5</span>
                                                                   [(test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">4</span><span class="fu">-</span><span class="dv">5</span>]
                                                                   x
                                                    }])
                       []
                       (<span class="dt">PRef</span> (test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">8</span><span class="fu">-</span><span class="dv">9</span> [(test)<span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">8</span><span class="fu">-</span><span class="dv">9</span>] x)
                       []
             ]
]</code></pre></div>
<p>This is a bit long, but going through it bit by bit and ignoring some parts, we can hopefully make sense of it. First, there are two top-level declarations <code>PTy</code> and <code>PClauses</code>, which are constructors of the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L637"><code>PDecl'</code></a> datatype. The <code>PTy</code> is a type declaration which consists of a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Docstrings.hs#L48"><code>Docstring</code></a>, a list of <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Core/TT.hs#L452"><code>Name</code></a>-<a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Docstrings.hs#L48"><code>Docstring</code></a> tuples (presumably for the parameters), a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L1443"><code>SyntaxInfo</code></a> (briefly touched on before), a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Core/TT.hs#L83"><code>FC</code></a> (which is a source location and here pretty-printed to <code>(test):1:4</code>, I think this is the position of the <code>:</code>), a list of <code>FnOpt</code> (extra info such as if a function is inlinable, total, etc.), a <code>Name</code>, another <code>FC</code> (source location, this is the position of the name) and finally a <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L945"><code>PTerm</code></a>, which is here a <code>PPi</code>, a dependently-typed function type.</p>
<p>The <code>PClauses</code> is a pattern clause, so really the list of pattern matching definitions. It features a source location (<code>FC</code>), a list of function options (<code>FnOpts</code>), a name (this seems to be the <code>{_2}</code> here, indicating that this name was implicitly generated) and a list of <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L751"><code>PClause' PTerm</code></a>, which are the actual clause definitions.</p>
<p>We could drill down further on each of these, and of course there is a ton of details which I blissfully ignore, but I feel like that going this far has given me a fairly good superficial understanding of how parsing works in Idris in the sense that if I needed to find out how something works in detail, I would know where to look and find it fairly quickly. The next post will take a brief look at how the initial parse result is processed further.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If there is a better way, please let me know<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Sun, 17 Jan 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-II-Taking-the-Parser-for-a-Spin.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>A Look at the Idris Internals, Part I: Overview and Parsing</title>
    <link>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-I-Overview-and-Parsing.html</link>
    <description><![CDATA[<h1 class="title">A Look at the Idris Internals, Part I: Overview and Parsing</h1>

<p class="date">published on January 10, 2016</p>

<p><a href="http://idris-lang.org">Idris</a> is a purely functional programming language with full dependent types that I have been interested in for some time. Idris makes some choices that I find very appealing, and so I have been following it and poking around with it every so often. Unfortunately, this interest has so far only resulted in very minor contributions, but that’s not a reason to give up and not try again ;). I have been interested in compilers and code generation in general, and in the Idris backend in particular, so I’m using this new year as an excuse to take another look at the Idris internals. My intention is to write a few posts exploring the Idris compilation process in general and its backend in particular to gain a better understanding of it and hopefully to find a good place to contribute to it.</p>
<p>The goal of this post is to get a fairly high-level overview over how the compilation process works in general and how parsing works in a bit more detail. Future posts will explore the other parts a little deeper. There is a <a href="http://eb.host.cs.st-andrews.ac.uk/drafts/compile-idris.pdf" title="Edwin Brady: Cross-platform compilers for functional languages (PDF)">recent paper</a> by Edwin Brady, the creator of Idris, that explains some aspects of the Idris compilation process. This <a href="http://www.cs.st-andrews.ac.uk/~eb/drafts/impldtp.pdf" title="Edwin Brady: Idris, a General Purpose Dependently Typed Programming Language: Design and Implementation (PDF)">earlier paper</a> focuses more on TT and the type theory, but is of course also very interesting. In comparison to these papers, my goal is to give a more detailed look at the code and possibly also dive a bit deeper into some details that are left out of these papers as they are fairly standard from a research perspective and not that interesting to academics well versed in this topic.</p>
<h2 id="a-high-level-view-of-the-idris-compilation-process">A high-level view of the Idris compilation process</h2>
<p>On a very high level, the Idris compilation process consists of the following steps: First the source code is parsed and an abstract syntax tree (AST) for the high-level Idris language is produced. This language is then slightly desugared, for example by replacing do notation and so on. Then the so-called elaboration process starts, where implicit arguments are infered and the desugared Idris language is converted to the main core language, called TT. In TT all arguments are explicit, yet TT is still a fully dependently typed language. Typechecking occurs at this level. TT is then simplified by converting (possibly dependently-typed) pattern matching into simple case trees, this simplified form of TT is called <em>TT_case</em>. A number of further simplification processes produce successively simpler intermediate languages: <em>IR_case</em> (a first untyped intermediate language), <em>IR_lift</em> where all lambdas have been lifted to the top level, <em>IR_defunc</em> where partially applied functions have been converted to constructors and finally <em>IR_ANF</em> where all function arguments are either constants or variables. These intermediate languages (and some other data) are written to Idris <em>ibc</em> files. Code generators process these files and compile the intermediate languages further to executables.</p>
<h2 id="parsing-and-producing-the-idris-ast">Parsing and producing the Idris AST</h2>
<p>The first step of the compiler is to parse the source code and to produce an AST representing this code. The main file for the <code>idris</code> executable lives in <code>main/Main.hs</code>. This ends up calling the function <code>idrisMain</code> in <code>src/Idris/REPL.hs</code>. This and other functions in that module load code either with the <code>loadFromIFile</code> or <code>loadModule</code> functions, both defined in <code>src/Idris/Parser.hs</code>. This is the main file of the parser, which defines the aformentioned top-level functions for loading code. Other files of interest for the parsing process are <code>ParserExpr.hs</code>, <code>ParserData.hs</code>, <code>ParserOps.hs</code> and <code>ParserHelpers.hs</code>, all of which define different parts of the parser, and, importantly, <code>AbsSyntaxTree.hs</code>, which contains the datatypes for the syntax tree, as well as other important datatypes used in the parsing process.</p>
<p>The function in <code>Parser.hs</code> which actually starts parsing code from is <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L1594"><code>loadSource</code></a>. Interestingly, this function parses a file in two parts, it first parses the imported modules (<a href=""><code>parseImports</code></a>), then proceeds to load these modules and only parses the program afterwards with the <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/Parser.hs#L1509"><code>parseProg</code></a> function.</p>
<p>These functions run in the Idris monad and modify its state, so they’re not just pure parsing functions. The Idris monad is used fairly extensively throughout the compliation process and is a <code>StateT IState</code> on top of <code>ExceptT</code> and <code>IO</code>. <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L178"><code>IState</code></a> is a large record defined in <code>AbsSyntaxTree.hs</code> which mostly lists the known top-level definitions as well as some current state related to elaboration and proving.</p>
<p>Running the parser is accomplished by the aptly-named <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/ParseHelpers.hs#L77"><code>runparser</code></a> function from <code>ParseHelpers.hs</code>. This function takes a <code>StateT st IdrisInnerParser res</code> as input, where <code>IdrisInnerParser</code> is just a <code>newtype</code> around a <code>Parser</code> from the <a href="http://hackage.haskell.org/package/trifecta">Trifecta</a> library. Much of the <code>Parse*.hs</code> files define items for the trifecta parser combinators, and are thus relatively straight forward.</p>
<p>The datatypes that represent the high-level language are defined in defined in <code>src/Idris/AbsSyntaxTree.hs</code>. The datatype for top-level declarations is <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L637"><code>PDecl'</code></a>, which is usually parameterized over <a href="https://github.com/idris-lang/Idris-dev/blob/76257997a9bf03d62e28cefba0d6a7d3d42eca28/src/Idris/AbsSyntaxTree.hs#L944"><code>PTerm</code></a>, the main datastructure defining the high-level language terms.</p>
<p>That’s it for the current post, in the next part I’ll take a very brief look at where desugaring, elaboration and TT, Idris’ core language, live.</p>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Sun, 10 Jan 2016 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-I-Overview-and-Parsing.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Release It - Summary and Review</title>
    <link>http://koerbitz.me/posts/Release-It-Summary-And-Review.html</link>
    <description><![CDATA[<h1 class="title">Release It - Summary and Review</h1>

<p class="date">published on January 13, 2015</p>

<p>So I have finally finished reading Michael Nygard’s terribly named but quite interesting book <em>Release It</em>. It covers stability patterns and anti-patterns and offers some interesting ideas and concepts for improving stability.</p>
<h2 id="part-i-stability">Part I: Stability</h2>
<p>The part on stability starts out with an interesting case study that describes how an uncaught exception in a connection pool caused the flight search application of an airline to hang which in turn caused a failure in all check-in systems. The uncaught exception was a programming error, but some errors will inevitably occur. However, these errors must not bring down the entire IT infrastructure of a company! It is thus critical to identify how small errors can cause entire applications to fail and what can be done to mitigate the spread of such failures. The former is examined in ‘Stability Antipatterns’, the latter in ‘Stability Patterns’.</p>
<h3 id="stability-antipatterns">Stability Antipatterns</h3>
<ol style="list-style-type: decimal">
<li><p>Integration Points</p>
<p>Problems are often caused at integration points b/c the remote application may not always act as specified. There is a huge number of failure modes simply connected to TCP connections that an application must protect against if it integrates other applications.</p>
<ul>
<li><p>Every integration point will eventually fail in some way.</p></li>
<li><p>There are many forms of failure</p></li>
<li><p>Peel back abstractions to discover failure modes</p></li>
<li><p>Failures can propagate quickly - stop them!</p></li>
<li><p>Use stability patterns to mitigate: Timeouts, Circuit Breaker, Decoupling Middleware, Handshaking</p></li>
</ul></li>
<li><p>Chain Reactions</p>
<p>Occur when a failure somewhere makes failures somewhere else more likely, but do not causes this directly. For example when one server dies due to a memory leak and other servers must pick up the extra traffic these servers will be more likely to go down due to the same leak because they now must deal with more traffic.</p>
<ul>
<li><p>One server down jeopardizes the rest</p></li>
<li><p>Hunt for resource leaks &amp; timing bugs</p></li>
<li><p>Defend with bulkheads</p></li>
</ul></li>
<li><p>Cascading Failures</p>
<p>Cascading failures happen when failures are one system can jump to the next system. For example, if a hung server somewhere causes client applications to hang because they wait for responses that never come (While they clearly cannot display a response then they should deal with not receiving one in time).</p>
<ul>
<li><p>Deal with failures in remote systems</p></li>
<li><p>Scrutinize resource pools</p></li>
<li><p>Defend with Timeout and Circuit Breaker</p></li>
</ul></li>
<li><p>Users</p>
<p>This deals with te resources that users use. For example memory used up for a user session.</p>
<ul>
<li><p>Users consume memory</p></li>
<li><p>Users do weird things</p></li>
<li><p>Malicious users are out there</p></li>
<li><p>Users will gang up on you</p></li>
</ul></li>
<li><p>Blocked Threads</p>
<p>Threads waiting for responses or resources to free up which never or are very slow to come or free up can cause the application to hang.</p>
<p>Blocked threads can also be caused by deadlocks resulting from concurrency errors. This is obviously a large and complicated topic.</p>
<ul>
<li><p>Blocked threads are the proximate cause of most system failures</p></li>
<li><p>Scrutinize resource pools</p></li>
<li><p>Use proven concurrency primitives (FP!!!)</p></li>
<li><p>Use Timeouts</p></li>
<li><p>Beware of vendor libraries.</p></li>
</ul></li>
<li><p>Attacks of Self-Denial</p>
<p>E.g. deep-links which require sessions and a lot of internal requests of extremely attractive offers on shopping sites. Educate the marketing department.</p>
<ul>
<li><p>Keep lines of communication open</p></li>
<li><p>Expect rapid redistribution of any valuable offer</p></li>
</ul></li>
<li><p>Scaling Effects</p>
<p>Communication patterns that may have been fine with two servers might not scale (e.g. O(n) or worse connections required).</p>
<ul>
<li><p>Examine production vs QA and dev environment to spot scaling effects.</p></li>
<li><p>Watch out for point-to-point communcation</p></li>
<li><p>Watch out for shared resources</p></li>
</ul></li>
<li><p>Unbalanced Capacities</p>
<p>E.g. larger front-end capacities can overwhelm smaller back-end capacities</p>
<ul>
<li><p>Examine server and thread counts</p></li>
<li><p>Stress both sides of the interface</p></li>
</ul></li>
<li><p>Slow Responses</p>
<p>Extremely slow responses cna prevent timeouts from working yet have much the same effect as not receiving a response.</p>
<ul>
<li><p>Slow responses trigger <em>Cascading Failures</em>: upstream systems also slow down.</p></li>
<li><p>Users will hit the reload button -&gt; more traffic.</p></li>
<li><p>Consider to <em>Fail Fast</em>.</p></li>
<li><p>Hunt for memory leaks and resource contention.</p></li>
</ul></li>
<li><p>SLA Inversion</p>
<p>The availability of a set of system is the product of their availabilities. Thus a system depending on five other systems which each provide a 99% guarantee can only guarantee 99%^5=95.1% availability.</p>
<ul>
<li><p>Examine every dependency: DNS, Email, network equipment, database, …</p></li>
<li><p>Decouple dependencies: Make sure you can maintain service even when dependencies go down.</p></li>
</ul></li>
<li><p>Unbounded Result Sets</p>
<p>Applications should also be more sceptical of their databases and e.g. limit the number of results that they are willing to process.</p>
<ul>
<li><p>Limit to realistic data volumes.</p></li>
<li><p>Don’t rely on the producer, enforce limits yourself.</p></li>
<li><p>Put limits into other application level protocols.</p></li>
</ul></li>
</ol>
<h3 id="stability-patterns">Stability Patterns</h3>
<ol style="list-style-type: decimal">
<li><p>Use Timeouts</p>
<p>Hung threads waiting for responses that may never come or come slowly can lead the entire application to block (all threads in a pool are hung). Use timeouts to report an error when this happens.</p>
<ul>
<li><p>Apply to <em>Integration Points</em>, <em>Blocked Threads</em>, <em>Slow Responses</em>.</p></li>
<li><p>Give up and keep moving: it may not matter if we ge a response eventually, time is of the essence.</p></li>
<li><p>Delay retries: Most timeouts are caused by things that don’t resolve imediately, wait a little before trying again.</p></li>
</ul></li>
<li><p>Circuit Breaker</p>
<p>A circuit breaker detects when there is a problem at an integration point and acts accordingly. A circuit breaker counts the number of failures, if these exceed a sensible threshold it triggers and prevents subsequent calls to talk to the integration point. After a timeout a single / few call(s) may be retried, if they work the circuit breaker goes back to its normal state, if not it stays open.</p>
<ul>
<li><p>If there is a problem with an integration point stop calling it!</p></li>
<li><p>Use together with <em>Timeouts</em>: A <em>Timeout</em> detects the problem, a <em>Circuit Breaker</em> keeps us from retrying too often too soon.</p></li>
<li><p>Make it visible to operations: popping a <em>Circuit Breaker</em> usually indicates a serious problem.</p></li>
</ul></li>
<li><p>Bulkheads</p>
<p>Bulkheads partition the system into independent units. When one unit fails the other units are still operational. There are trade-offs with efficient resource usage.</p>
<ul>
<li>Very important when other applications depend on your system: the largest part should keep functioning when there is some problem.</li>
</ul></li>
<li><p>Steady State</p>
<p>Applications should be able to run indefintely without requireing human interventions. The latter leads to fiddeling, which causes errors. This inlcudes cleaning up log-files and disk space at the same rate that they are produced.</p>
<ul>
<li><p>Avoid human interaction, it causes problems.</p></li>
<li><p>Purge data with application logic (e.g. DB entries).</p></li>
<li><p>Limit caching.</p></li>
<li><p>Roll logs.</p></li>
</ul></li>
<li><p>Fail Fast</p>
<p>This pattern deals with the problems caused by ‘slow responses’. An application should determine as soon as possbile if it can service a request and if not it should fail as quickly as possible. There are some trade offs with maintaining encapsulation here.</p>
<ul>
<li><p>Verify integration points early: If required resources are not available it’s time to fail fast.</p></li>
<li><p>Validate input as early as possible.</p></li>
</ul></li>
<li><p>Handshaking</p>
<p>Can be used to determine if an application can accept additional requests. This does double the number of requests and request-latency. Building in the ability to reject requests directly seems more useful to me.</p></li>
<li><p>Test Harness</p>
<p>A sufficiently evil test harness can test the response of an application to misbehaving integration points. It is the point of this test harness to test failure modes which are not specified. For example misbehaving TCP connections or extremely slow responses can be tested with such a test harness.</p>
<p>Consider the following network failures:</p>
<ul>
<li><p>It can be refused.</p></li>
<li><p>It can sit in a listen queue until the caller times out.</p></li>
<li><p>The remote end can reply with a SYN/ACK and then never send any data.</p></li>
<li><p>The remote end can send nothing but RESET packets.</p></li>
<li><p>The remote end can report a full receive window and never drain the data.</p></li>
<li><p>The connection can be established, but the remote end never sends a byte of data.</p></li>
<li><p>The connection can be established, but packets could be lost causing retransmit delays.</p></li>
<li><p>The connection can be established, but the remote end never acknowledges receiving a packet, causing endless retransmits.</p></li>
<li><p>The service can accept a request, send response headers (supposing HTTP), and never send the response body.</p></li>
<li><p>The service can send one byte of the response every thirty seconds.</p></li>
<li><p>The service can send a response of HTML instead of the expected XML.</p></li>
<li><p>The service can send megabytes when kilobytes are expected.</p></li>
<li><p>The service can refuse all authentication credentials.</p></li>
</ul>
<p>Remember these:</p>
<ul>
<li><p>Emulate out-of-spec failures</p></li>
<li><p>Stress the caller: Slow responses, no responses, garbage responses</p></li>
<li><p>Leverage a killer harness for common failures</p></li>
<li><p>Supplement, don’t replace, other testing methods</p></li>
</ul></li>
<li><p>Decoupling Middleware</p>
<p>Asynchronous middleware (e.g. Pub-Sub or messaging communication solutions) force the programmers with the possibility of not receiving a response right away and thus make systems more resilient. They are more difficult to work with than synchronous middleware (but represent the underlying architecture more correctly).</p>
<ul>
<li><p>Total decoupling can avoid many failure modes.</p></li>
<li><p>Learn many architectures, choose the best one for the job.</p></li>
</ul></li>
</ol>
<h2 id="part-ii-capacity">Part II: Capacity</h2>
<p>Another case study rings in the part on capacity: This one is on an online retailer that re-build their system from scratch over three years. When entering load testing it didn’t meet capacity requirements by a factor of 20, after months of testing this imporoved ten-fold.</p>
<p>It crashed badly when it went live, because all the tests had been simulating <em>nice</em> users: users that used the site how it was meant to. In the real world a lot of bots, search engines and other things used the site in non-anticipated ways which it was not prepared for.</p>
<h3 id="introducing-capacity">Introducing Capacity</h3>
<ol style="list-style-type: decimal">
<li><p>Defining Capacity</p>
<p>Performance: How fast does the system process a single transaction?</p>
<p>Throughput: Number of transactions the system can process in a given timespan.</p>
<p>Scalability: Used to describe either (a) how throughput changes under different loads or (b) modes of scaling supported by the system.</p>
<p>Capacity: maximum throughput a system can sustain while meeting performance criteria (e.g. response time).</p></li>
<li><p>Constraints</p>
<p>Aka bottlenecks. At any given point, there will usually one (or more) things constraining capacity. Improving any other factors will not yield more capacity.</p></li>
<li><p>Interrelations</p>
<p>Things are not independent. Decreased performance in one layer can affect other layers.</p></li>
<li><p>Scalability</p>
<p>Horizontal vs. vertical scaling.</p></li>
<li><p>Myths About Capacity</p>
<p>While hardware as such (compared to programmer time) is cheap, dealing with inefficiencies can become more expensive. Optimization may still make sense. All of CPU, storage and bandwith may be more expensive than it seems at first sight.</p></li>
</ol>
<h3 id="capacity-antipatterns">Capacity Antipatterns</h3>
<ol style="list-style-type: decimal">
<li><p>Resource Pool Contention</p>
<p>Requests waiting for resources to become available are a scalability problem.</p></li>
<li><p>Excessive JSP fragments</p>
<p>Java specific. JSP fragments reside in memory and can constrain application server memory.</p></li>
<li><p>Ajax Overkill</p>
<p>Ajax can be used to hammer a server. Don’t build an essantially static homepage with 100 Ajax requests.</p></li>
<li><p>Overstaying Sessions</p>
<p>Sessions memory and are removed with the timeout after user goes away. Should not be kept longer than necessary. Ideal: Information for user is still available even when session expires.</p></li>
<li><p>Wasted Space in HTML</p>
<p>Can add up.</p></li>
<li><p>The Reload Button</p>
<p>Slow requests increase load by causing users to hammer the reload button.</p></li>
<li><p>Handcrafted SQL</p>
<p>In Java land thy shall not work without an ORM.</p></li>
<li><p>Database Eutrophication</p>
<p>The database becomes bigger over time, so things that were OK at on point might not always be.</p></li>
<li><p>Integration Point Latency</p>
<p>Integration points take time to respond and latency adds up.</p></li>
<li><p>Cookie Monsters</p>
<p>Large cookies must be transfered back and forth a lot. Can’t be trusted.</p></li>
</ol>
<h3 id="capacity-patterns">Capacity Patterns</h3>
<ol style="list-style-type: decimal">
<li><p>Pool Connections</p>
<p>Creating a new connection can take upwards of 250ms. So pooling makes sense. Some considerations:</p>
<ul>
<li><p>connections with an error must be detected and fixed</p></li>
<li><p>for which scope should connections be checked out?</p></li>
</ul></li>
<li><p>Use Caching Carefully</p>
<p>It’s a trade off, caching things that are seldomly used and not expensive to generate doesn’t make sense.</p></li>
<li><p>Precompute Content</p>
<p>When it changes much less frequently than it is requested (and it’s worth the effort).</p></li>
<li><p>Tune the GC</p>
<p>JVM specific. GC should ideally take no more than 2% of time.</p></li>
</ol>
<h2 id="part-iii-general-design-issues">Part III: General Design Issues</h2>
<h3 id="networking">Networking</h3>
<ol style="list-style-type: decimal">
<li><p>Multihomed Servers: Contrary to the setup in dev and QA, servers will listen on multiple IPs, not all of them public. This must be accounted for in development.</p></li>
<li><p>Routing: Different NICs might be on different VLANs, remote backend services might require connection through a VPN. Must pay attention to every integration point.</p></li>
<li><p>Virtual IP Addresses: Cluster servers, some info on how virtual IP addresses can be moved from one NIC to another.</p></li>
</ol>
<h3 id="security">Security</h3>
<ol style="list-style-type: decimal">
<li><p>Principle of Least Privilege: Processes should have as few privledges as possible.</p></li>
<li><p>Configured Passwords: Should be kept separate from other configuration files, core dumps should be disabled for production (trade-offs …).</p></li>
</ol>
<h3 id="availability">Availability</h3>
<ol style="list-style-type: decimal">
<li><p>Gathering Availability Requirements: High availability costs money and the requirements must thus be balanced with the costs. Rule of thumb: Each additional ‘9’ increases the implementation cost by a factor of 10 and the operational cost by a factor of 2.</p></li>
<li><p>Documenting Availability Requirements: Once things go down everyone has a different opinion of what available was defined to mean. Important to really define it. Availability should be defined per feature and not be responsible for remote systems one has no control over. A good definition might answer the following questions:</p></li>
</ol>
<ul>
<li><p>How often will the monitoring device execute its synthetic transaction?</p></li>
<li><p>What is the maximum acceptable response time for each step of the transaction?</p></li>
<li><p>What response codes or text patterns indicate success?</p></li>
<li><p>What response codes or text patterns indicate failure?</p></li>
<li><p>How frequently should the synthetic transaction be executed?</p></li>
<li><p>From how many locations?</p></li>
<li><p>Where will the data be recorded?</p></li>
<li><p>What formula will be used to compute the percentage availability? Based on time or number of samples?</p></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Load Balancing</li>
</ol>
<ul>
<li><p>DNS Round-Robin: Several IPs configured for a domain name, DNS returns a different one each time, thus distributing load over the IPs.</p>
<p>Several problems: server IPs must be public (instead of some proxy), too much control over load balancing in clients hands, workloads might still be unbalanced, no failover in case one server goes down. Url rewriting variant with Apache (www7.example.com) even worse.</p></li>
<li><p>Reverse Proxy: intercepts each requests and multiplexes it onto a number of servrs behind it, can cache static content, examples: Squid, Akamai.</p></li>
<li><p>Hardware Load Balancer: specialized networking gear, expensive, SSL a challenge (terminating SSL at the load balancer puts it under a lot of stress).</p></li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>Clustering: Unlike in load balancing servers are aware of each. Can be used for load balancing (active/active) or failover. Do not scale linearly like load-balanced shared nothing architectures. Nygard considers them a band-aid for applications that don’t do clustering / scaling themselves.</li>
</ol>
<h3 id="administration">Administration</h3>
<p>Easy administration leads to good uptime.</p>
<ol style="list-style-type: decimal">
<li><p>Does QA match Production?</p>
<p>Most often it doesn’t. Differences in topology responsible for many outages. It’s advantageous to maintain a similar topology (e.g. seperation of services through firewalls, same multiplicty of connections) in QA as in production.</p>
<p>The cost of downtime often exceeds the cost of the extra network gear required to run the same setup in QA and in production. Pennywise and pound foolish?</p></li>
<li><p>Configuration Files</p>
<p>Don’t keep configuration settings that must be changed by sys admins next to the essential (hard-wired) configuration for the application.</p>
<p>Name configuration properties according to their function, e.g. ‘authenticationServer’ instead of ‘hostname’.</p></li>
<li><p>Start-up and Shutdown</p>
<p>Applications should start up and shut down cleanly and do some minimal checks that they are configured correctly before accepting work (Fail Fast).</p></li>
<li><p>Administrative Interfaces</p>
<p>GUIs look nice but command line interfaces are essential for automation.</p></li>
</ol>
<h2 id="part-iv-operations">Part IV: Operations</h2>
<h3 id="transparency">Transparency</h3>
<p>Transparency allows to gain an understanding of historical trends, present conditions and future projections. Transparency has four facets: historical trends, predictive forecasting, present status and instantaneous behaviour.</p>
<ol style="list-style-type: decimal">
<li><p>Perspectives</p>
<ul>
<li><p>Historical Trending</p></li>
<li><p>Records have to be stored somewhere -&gt; OpsDB</p></li>
<li><p>Can be used to discover new relationships - should be available through tools such as Excel.</p></li>
<li><p>Forecasts</p></li>
<li><p>What’s the capacity?</p></li>
<li><p>When do we have to buy more servers?</p></li>
<li><p>Present Status</p></li>
<li><p>Memory</p></li>
<li><p>Garbage Collection</p></li>
<li><p>Worker threads for each thread pool</p></li>
<li><p>Database connections, for each pool</p></li>
<li><p>Traffic statistics for each request channel</p></li>
<li><p>Business transactions for each type</p></li>
<li><p>Users: demographics, percentage registered, number of users, usage patterns</p></li>
<li><p>Integration points: current state, times used, latency statistics, error count.</p></li>
<li><p>Circuit breakers: current state, error count, latency statistics, number of state transitions.</p></li>
</ul>
<p>The current state can be displayed on a dashboard, e.g. as a traffic light for the system and each component.</p>
<ul>
<li>Instantaneous Behaviour: WTF is going on???</li>
</ul>
<p>Errors, log file entries, thread dumps, … Can, but may not immediately show up in <em>Present Status</em>.</p></li>
<li><p>Desiging for Transparency</p>
<p>Transparency is hard to add later. Both local and global visibility is necessary.</p></li>
<li><p>Enabling Technologies: White box (visibility into the processes) vs. black box (only externally visible metrics)</p></li>
<li><p>Logging</p>
<ul>
<li>Make log file output easy to scan with the eye (p. 246)</li>
</ul></li>
<li><p>Monitoring Systems</p></li>
<li><p>Standards, De Jure and De Facto</p>
<ul>
<li><p>Simple Network Management Protocol: De Facto standard, ASN.1 a bit awkward.</p></li>
<li><p>JMX (Java Management Extensions) de facto standard in the Java world.</p></li>
</ul></li>
<li><p>Operations Database</p>
<p>Good for historical data, forecasts and current status. Not well suited for instantaneous behavior. Receives reports from applications, servers and batch jobs.</p>
<ul>
<li><p>Applications: status variables, business metrics, internal metrics</p></li>
<li><p>Servers: performance, utilization</p></li>
<li><p>Batch Jobs: start, end, abort, completion status, items processed</p></li>
</ul>
<p>The OpsDB can be used to produce a dashboard, various reports and for planning capacity.</p>
<p>Observations should record their type, the measurement, the event and the status.</p></li>
<li><p>Supporting Processes</p>
<p>Must stay in feedback loop when providing data - automated report that nobody reads are <strong>worse than useless</strong>: The cost time and money to create and maintain and provide a false sense of security, yet nobody reads them.</p></li>
</ol>
<h3 id="adaption">Adaption</h3>
<ol style="list-style-type: decimal">
<li><p>Adaptation Over Time</p></li>
<li><p>Adaptable Software Desgin</p>
<ul>
<li><p>Dependency Injection: enables loose coupling, aids testability</p></li>
<li><p>Object Design: Claim: it exists ;)</p></li>
<li><p>XP Coding Practices: Unit testing</p></li>
<li><p>Agile Databases:</p></li>
<li><p>databases must be able to change</p></li>
</ul></li>
<li><p>Adaptable Enterprise Architecture</p>
<p>Prefer loosely clustered, somewhat independent services that can change independently</p>
<ul>
<li>Dependencies Between Systems: Protocols</li>
</ul>
<p>Simultaneous updates at several endpoints is hard, this can be avoided by speaking multiple protocols (or versions of) for a limited time.</p>
<ul>
<li>Dependencies Between Systems: Databases</li>
</ul>
<p>Don’t share databases between services!!!</p></li>
<li><p>Releases Shouldn’t Hurt</p>
<p>Painful releases mean software is released seldomly, automated, zero downtime releases rock!</p></li>
</ol>
<h2 id="my-takeaway">My Takeaway</h2>
<p>Apart from the title, I really did like this book and enjoyed reading it. I found the chapters on stability (anti-)patterns to be very valuable and enlightening. These are patterns that I will definteley introduce in my daily work and as such, even one successful pattern is worth many times the price of the book.</p>
<p>Almost inevitably, the other parts of the book were not quite able to deliver as much useful insights but many had some interesting tidbits nevertheless. While some chapters are a little light on information (e.g. Security and Networking), others (e.g. Transparency) provide useful ideas that will make you think of practical concerns while designing an application. I have certainly seen a number of systems that failed to deliver on every item discussed in the book.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Some topics are covered on a fairly high level and can thus not provide the nitty-gritty detail needed when dealing with the discussed topics hands on, but this is inevitable when trying to cover such a broad range of topics.</p>
<p>All in all I did enjoy the book and recommend it. If you’re short on time I recommend focussing on the part on stability, particularly chapters 3, 4 and 5 which delivered the most value for me.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Building a perfectly designed application that delivers on all fronts is much more difficult in practice than in theory of course. ;)<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Tue, 13 Jan 2015 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Release-It-Summary-And-Review.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Solving the Expression Problem in Haskell and Java</title>
    <link>http://koerbitz.me/posts/Solving-the-Expression-Problem-in-Haskell-and-Java.html</link>
    <description><![CDATA[<h1 class="title">Solving the Expression Problem in Haskell and Java</h1>

<p class="date">published on June 14, 2014</p>

<p>After my <a href="/posts/Sum-Types-Visitors-and-the-Expression-Problem.html">last post</a> on the expression problem, I thought that I would explore ways to solve it in the next post and that I would write that post shortly after. I knew how the solution worked in Haskell and that solutions existed for OO languages, so that post should not have been terribly hard to write. Well, here we are five months later and I am finally getting around to writing the post ;).</p>
<h2 id="expression-problem-recap">Expression Problem Recap</h2>
<p>The term <em>Expression Problem</em> was coined by Philip Waldler in a <a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">mail</a> to the Java Generics mailing list. The goal is to be able to define datatypes by cases and functions over these datatypes in a way that is extensible: one should be able to add both new cases and new functions without touching or recompiling old code and while maintaining static type safety.</p>
<p>As an example I’ll reuse the simple expression language from the last post. To represent such an expression language we will have a number of variants to capture the different types of expressions, for example literal integers, addition, and multiplication. To work with this representation we will have different functions to transform such expressions, for example evaluating or pretty-printing them.</p>
<p>Once we have defined the cases and functions how difficult will it be to add new cases and new functions? Statically type-checked functional languages make it easy to add new functions (see <a href="/posts/Sum-Types-Visitors-and-the-Expression-Problem.html">last post</a>) while the object oriented languages make it easy to add new cases. The default approach in both languages does not make it easy<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> to either add new cases or new functions. That means that the default approach in both languages does not solve the Expression Problem. However, it turns out that solutions are possible in both types of languages. This post will describe a possible solution in both Haskell and Java.</p>
<h2 id="a-haskell-solution">A Haskell Solution</h2>
<p>The key to solving the Expression Problem in Haskell is to define typeclasses for the desired functions and make the datatypes instances of these typeclasses. We also define the different variants as their own datatypes, though this is not strictly necessary yet. For our expression language the setup looks as follows:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lit</span> <span class="fu">=</span> <span class="dt">Lit</span> <span class="dt">Int</span>
<span class="kw">data</span> <span class="dt">Add</span> l r <span class="fu">=</span> <span class="dt">Add</span> l r

<span class="kw">class</span> <span class="dt">Eval</span> x <span class="kw">where</span>
<span class="ot">  eval ::</span> x <span class="ot">-&gt;</span> <span class="dt">Int</span>

<span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Lit</span> <span class="kw">where</span>
  eval (<span class="dt">Lit</span> x) <span class="fu">=</span> x

<span class="kw">instance</span> (<span class="dt">Eval</span> l, <span class="dt">Eval</span> r) <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">Add</span> l r) <span class="kw">where</span>
  eval (<span class="dt">Add</span> l r) <span class="fu">=</span> eval l <span class="fu">+</span> eval r</code></pre></div>
<p>The extension that is typically easy in functional languages is to add a new function over the datatype. With the setup as above, we now add a new typeclass which contains the function as a method and add instances for each of our datatypes. Compared to the standard approach in functional languages, this requires slightly more code, but is still fairly clear:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">PPrint</span> x <span class="kw">where</span>
<span class="ot">  pprint ::</span> x <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="kw">instance</span> <span class="dt">PPrint</span> <span class="dt">Lit</span> <span class="kw">where</span>
  pprint (<span class="dt">Lit</span> x) <span class="fu">=</span> show x

<span class="kw">instance</span> (<span class="dt">PPrint</span> l, <span class="dt">PPrint</span> r) <span class="ot">=&gt;</span> <span class="dt">PPrint</span> (<span class="dt">Add</span> l r) <span class="kw">where</span>
  pprint (<span class="dt">Add</span> l r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> pprint l <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> pprint r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></code></pre></div>
<p>OK, so adding new functions is still easy, how about adding new cases? Adding a new case is the interesting part, because this is the side of the Expression Problem which the standard approach in Haskell can’t handle. However, with the setup we have introduced above this becomes quite easy: we just add a new datatype and then add instances for each of our typeclasses:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Mult</span> l r <span class="fu">=</span> <span class="dt">Mult</span> l r

<span class="kw">instance</span> (<span class="dt">Eval</span> l, <span class="dt">Eval</span> r) <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">Mult</span> l r) <span class="kw">where</span>
  eval (<span class="dt">Mult</span> l r) <span class="fu">=</span> eval l <span class="fu">*</span> eval r

<span class="kw">instance</span> (<span class="dt">PPrint</span> l, <span class="dt">PPrint</span> r) <span class="ot">=&gt;</span> <span class="dt">PPrint</span> (<span class="dt">Mult</span> l r) <span class="kw">where</span>
  pprint (<span class="dt">Mult</span> l r) <span class="fu">=</span> pprint l <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> pprint r</code></pre></div>
<p>OK, so this approach lets us indeed add new cases and new functions without having to modify existing code. Note that we also have type safety: in the code below both <code>eval</code> and <code>pprint</code> can be called on both <code>threePlus5</code> and <code>threePlus5Times7</code> because these operations are defined on each of the datatypes. Had we forgotten to derive a typeclass instance for one of the cases <code>Lit</code>, <code>Add</code> or <code>Mult</code> the compiler would bark. The full code is available at this <a href="https://gist.github.com/paulkoerbitz/106277417325fd43a64c">gist</a>.</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell">threePlus5 <span class="fu">=</span> <span class="dt">Add</span> (<span class="dt">Lit</span> <span class="dv">3</span>) (<span class="dt">Lit</span> <span class="dv">5</span>)
threePlus5Times7 <span class="fu">=</span> <span class="dt">Mult</span> threePlus5 (<span class="dt">Lit</span> <span class="dv">7</span>)

main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="fu">$</span> pprint threePlus5 <span class="fu">++</span> <span class="st">&quot; = &quot;</span> <span class="fu">++</span> show (eval threePlus5)
  putStrLn <span class="fu">$</span> pprint threePlus5Times7 <span class="fu">++</span> <span class="st">&quot; = &quot;</span> <span class="fu">++</span> show (eval threePlus5Times7)</code></pre></div>
<h2 id="a-java-solution">A Java Solution</h2>
<p>Solving the Expression Problem in classical (statically typed) OO languages is a bit more difficult. The solution I’ll present here is taken from the paper <a href="http://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf">Extensibility for the masses (PDF)</a> which has won the ECOOP 2012 best paper award. The idea is to use <em>object algebras</em> which implement so-called <em>algebraic signatures</em>. We will use the same example as above. The algebraic signature for the expression language looks as follows:<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<pre><code>signature E
    lit:  Int -&gt; E
    add:  E x E -&gt; E</code></pre>
<p>The general idea is this: we will represent the above signature as an interface which is parameterized over <code>E</code>. To actually use objects created with this interface we’ll instantiate <code>E</code> to a concrete interface, for example to <code>Eval</code> and call the operations provided by this interface (<code>eval()</code>). However, code creating objects with the above interface does not need to know what <code>E</code> is and can thus be completely generic.</p>
<p>In case this is a bit confusing (it certainly was to me), let’s look at a piece of code which will hopefully make this idea somwhat clearer:</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> Alg1&lt;E&gt; {
    E <span class="fu">lit</span>(<span class="dt">int</span> x);
    E <span class="fu">add</span>(E l, E r);
}

<span class="kw">class</span> Impl1&lt;E&gt; {
    <span class="kw">public</span> <span class="dt">static</span> &lt;E&gt; E <span class="fu">make3Plus5</span>(Alg1&lt;E&gt; f) {
        <span class="kw">return</span> f.<span class="fu">add</span>(f.<span class="fu">lit</span>(<span class="dv">3</span>), f.<span class="fu">lit</span>(<span class="dv">5</span>));
    }
}

<span class="kw">interface</span> Eval {
    <span class="dt">int</span> <span class="fu">eval</span>();
}

<span class="kw">class</span> ELit <span class="kw">implements</span> Eval {
    <span class="kw">private</span> <span class="dt">int</span> x;
    <span class="kw">public</span> <span class="fu">ELit</span>(<span class="dt">int</span> x) { <span class="kw">this</span>.<span class="fu">x</span> = x; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">eval</span>() { <span class="kw">return</span> x; }
}

<span class="kw">class</span> EAdd <span class="kw">implements</span> Eval {
    <span class="kw">private</span> Eval l, r;
    <span class="kw">public</span> <span class="fu">EAdd</span>(Eval l, Eval r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">eval</span>() { <span class="kw">return</span> l.<span class="fu">eval</span>() + r.<span class="fu">eval</span>(); }
}

<span class="kw">class</span> Alg1EvalFactory <span class="kw">implements</span> Alg1&lt;Eval&gt; {
    <span class="kw">public</span> Eval <span class="fu">lit</span>(<span class="dt">int</span> x) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">ELit</span>(x); }
    <span class="kw">public</span> Eval <span class="fu">add</span>(Eval l, Eval r) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">EAdd</span>(l, r); }
}

<span class="kw">class</span> Impl2 {
    <span class="dt">static</span> <span class="dt">int</span> <span class="fu">eval3Plus5</span>() {
        <span class="kw">return</span> Impl1.<span class="fu">make3Plus5</span>(<span class="kw">new</span> <span class="fu">Alg1EvalFactory</span>()).<span class="fu">eval</span>();
    }
}</code></pre></div>
<p>So we first define a generic interface called <code>Alg1</code> which represents the algebraic signature above.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> Programs such as <code>make3Plus5</code> can use this interface completely generically without needing to know what <code>E</code> acutally is.</p>
<p>Only when we acutally want to use the objects created from the <code>Alg1</code> interface do we need to define a concrete interface such as <code>Eval</code> and classes that implement it. We also need a class that implements <code>Alg1&lt;E&gt;</code>, in the code above this is <code>Alg1EvalFactory</code>. An instance of this factory is passed to the generic program <code>make3Plus5</code> which then produces an object which implements <code>Eval</code> so that we can call the <code>eval()</code> method on it.</p>
<p>Comparing this approach to the Haskell one there are some similarities: The <code>interface Eval</code> here plays the role of the <code>typeclass Eval</code> in the Haskell version and the classes <code>ELit</code> and <code>EAdd</code> correspond to the instance declarations. The piece that is missing from the Haskell version is the <code>Alg1</code> interface and its implementation, but I think there are some similarities to what the Haskell compiler does behind the scenes.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>Now let’s check if we can extend this setup with both new functions and new variants. First, adding new functions is fairly easy: The interface <code>Alg1</code> can stay unchanged, we merely need to create a new interface <code>PPrint</code> which will take the place of <code>Eval</code> and corresponding classes <code>PLit</code> and <code>PAdd</code> that implement this interface. To actually make use of <code>Alg1</code> instantiated to this new interface we also need a new factory.</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> PPrint {
    <span class="kw">public</span> String <span class="fu">pprint</span>();
}

<span class="kw">class</span> PLit <span class="kw">implements</span> PPrint {
    <span class="kw">private</span> <span class="dt">int</span> x;
    <span class="kw">public</span> <span class="fu">PLit</span>(<span class="dt">int</span> x) { <span class="kw">this</span>.<span class="fu">x</span> = x; }
    <span class="kw">public</span> String <span class="fu">pprint</span>() { <span class="kw">return</span> Integer.<span class="fu">valueOf</span>(x).<span class="fu">toString</span>(); }
}

<span class="kw">class</span> PAdd <span class="kw">implements</span> PPrint {
    <span class="kw">private</span> PPrint l, r;
    <span class="kw">public</span> <span class="fu">PAdd</span>(PPrint l, PPrint r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> String <span class="fu">pprint</span>() { <span class="kw">return</span> <span class="st">&quot;(&quot;</span> + l.<span class="fu">pprint</span>() + <span class="st">&quot; + &quot;</span> + r.<span class="fu">pprint</span>() + <span class="st">&quot;)&quot;</span>; }
}

<span class="kw">class</span> Alg1PPrintFactory <span class="kw">implements</span> Alg1&lt;PPrint&gt; {
    <span class="kw">public</span> PPrint <span class="fu">lit</span>(<span class="dt">int</span> x) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">PLit</span>(x); }
    <span class="kw">public</span> PPrint <span class="fu">add</span>(PPrint l, PPrint r) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">PAdd</span>(l, r); }
}

<span class="kw">class</span> Impl3 {
    <span class="dt">static</span> String <span class="fu">pprint3Plus5</span>() {
        <span class="kw">return</span> Impl1.<span class="fu">make3Plus5</span>(<span class="kw">new</span> <span class="fu">Alg1PPrintFactory</span>()).<span class="fu">pprint</span>();
    }
}</code></pre></div>
<p>This may look like a lot of code, but again, this roughly corresponds to the Haskell version. We did not need to duplicate any code (apart from the usual boilerplate that is required by Java). Also note that we were able to reuse <code>make3Plus5</code> from above even though we’re now using a new operation on its result!</p>
<p>So we can add new functions over the datatype cases. To add new cases we need to extend the signature <code>Alg1</code> to <code>Alg2</code> to accomodate the new case. We then need to add classes that implement the concrete interfaces <code>Eval</code> and <code>PPrint</code> for this new cases. Furthermore, we also need new factories which implement the interface <code>Alg2&lt;Eval&gt;</code> and <code>Alg2&lt;PPrint&gt;</code>. Again, this is slightly more code than one would love to write, but it is completely extensible (note for example that we are reusing <code>make3Plus5</code> unchanged with a factory that implements <code>Alg2&lt;E&gt;</code>):</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> Alg2&lt;E&gt; <span class="kw">extends</span> Alg1&lt;E&gt; {
    E <span class="fu">mult</span>(E l, E r);
}

<span class="kw">class</span> EMult <span class="kw">implements</span> Eval {
    <span class="kw">private</span> Eval l, r;
    <span class="kw">public</span> <span class="fu">EMult</span>(Eval l, Eval r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">eval</span>() { <span class="kw">return</span> l.<span class="fu">eval</span>() * r.<span class="fu">eval</span>(); }
}

<span class="kw">class</span> PMult <span class="kw">implements</span> PPrint {
    <span class="kw">private</span> PPrint l, r;
    <span class="kw">public</span> <span class="fu">PMult</span>(PPrint l, PPrint r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> String <span class="fu">pprint</span>() { <span class="kw">return</span> l.<span class="fu">pprint</span>() + <span class="st">&quot; * &quot;</span> + r.<span class="fu">pprint</span>(); }
}

<span class="kw">class</span> Alg2EvalFactory <span class="kw">extends</span> Alg1EvalFactory <span class="kw">implements</span> Alg2&lt;Eval&gt; {
    <span class="kw">public</span> Eval <span class="fu">mult</span>(Eval l, Eval r) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">EMult</span>(l, r); }
}

<span class="kw">class</span> Alg2PPrintFactory <span class="kw">extends</span> Alg1PPrintFactory <span class="kw">implements</span> Alg2&lt;PPrint&gt; {
    <span class="kw">public</span> PPrint <span class="fu">mult</span>(PPrint l, PPrint r) { <span class="kw">return</span> <span class="kw">new</span> <span class="fu">PMult</span>(l, r); }
}

<span class="kw">class</span> Impl4&lt;E&gt; {
    <span class="co">// a client program using Alg2 (which uses a function using Alg1!)</span>
    <span class="kw">public</span> <span class="dt">static</span> &lt;E&gt; E <span class="fu">make3Plus5Times7</span>(Alg2&lt;E&gt; f) {
        <span class="kw">return</span> f.<span class="fu">mult</span>(Impl1.<span class="fu">make3Plus5</span>(f), f.<span class="fu">lit</span>(<span class="dv">7</span>));
    }

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">eval3Plus5Times7</span>() {
        <span class="kw">return</span> <span class="fu">make3Plus5Times7</span>(<span class="kw">new</span> <span class="fu">Alg2EvalFactory</span>()).<span class="fu">eval</span>();
    }

    <span class="kw">public</span> <span class="dt">static</span> String <span class="fu">pprint3Plus5Times7</span>() {
        <span class="kw">return</span> <span class="fu">make3Plus5Times7</span>(<span class="kw">new</span> <span class="fu">Alg2PPrintFactory</span>()).<span class="fu">pprint</span>();
    }
}</code></pre></div>
<p>For completeness, here is a main method which uses the above and gives the same output as the Haskell version. The full code can be found at this <a href="https://gist.github.com/paulkoerbitz/106277417325fd43a64c">gist</a>.</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Main {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args)
    {
        System.<span class="fu">out</span>.<span class="fu">println</span>(Impl3.<span class="fu">pprint3Plus5</span>() + <span class="st">&quot; = &quot;</span>
                           + Integer.<span class="fu">valueOf</span>(Impl2.<span class="fu">eval3Plus5</span>()).<span class="fu">toString</span>());
        System.<span class="fu">out</span>.<span class="fu">println</span>(Impl4.<span class="fu">pprint3Plus5Times7</span>() + <span class="st">&quot; = &quot;</span>
                           + Integer.<span class="fu">valueOf</span>(Impl4.<span class="fu">eval3Plus5Times7</span>()).<span class="fu">toString</span>());
    }
}</code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>So this post gave a quick demonstration of how the Expression Problem can be solved both in Haskell and Java. I think it is pretty cool that the Expression Problem is actually solvable in a language like Java because I first thought that that wasn’t the case. On the one hand the Java version seems pretty heavyweight in terms of additional complexity. I therefore doubt that I would reach for this solution in practice unless I was certain in advance that solving the Expression Problem is important for a particular application and that it would justify the conceptual overhead. On the other hand this solution doesn’t feel conceptually much heavier than the visitor pattern and this solution solves both sides of the Expression Problem while the visitor pattern only solves one.</p>
<p>In the end I just wish I could use Haskell ;).</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Easy here means that no code needs to be changed / dublicated and type-safety is maintained.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Note the similarity to type classes!<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The paper calls such interfaces <em>object algebras</em> and goes a bit into the category theoretical motivations for these terms which I’m ignoring here.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Clearly the Haskell code is considerably easier to understand and - I would argue - also more elegant, but let’s not get into that.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Sat, 14 Jun 2014 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Solving-the-Expression-Problem-in-Haskell-and-Java.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Sum Types, Visitors, and the Expression Problem</title>
    <link>http://koerbitz.me/posts/Sum-Types-Visitors-and-the-Expression-Problem.html</link>
    <description><![CDATA[<h1 class="title">Sum Types, Visitors, and the Expression Problem</h1>

<p class="date">published on January 10, 2014</p>

<p>I’ve heard that <em>the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a> is just a poor way of getting the benefit of sum types</em><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> in functional programming circles several times. I must admit that I never had completely thought this through, but I was nevertheless a bit surprised when I saw that walking the AST in Rust was implemented by what looks like a use of the visitor pattern. Languages with sum types usually use pattern matching to achieve the same effect and I had always considered this a superior approach. In this blog post I try to understand the differences and similarities of the two approaches a little better.</p>
<p>To set the stage, both pattern matching and the visitor pattern solve one side of the <a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">expression problem</a>, which is the problem of adding both variants of a data type and functions that act on those variants without changing or recompiling old code and without loosing type safety.</p>
<p>To make this a bit more concrete, consider a very simple expression languages consisting of numbers and addition as an example (no post on this topic can do without one!). We have two variants of expressions, (1) numbers and (2) addition. Let’s assume that we want to compute the values represented by an expression as a first operation.</p>
<p>In Haskell a straightforward way of solving this problem is as follows</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span>

<span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
eval (<span class="dt">Val</span> i)     <span class="fu">=</span> i
eval (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">+</span> eval e2</code></pre></div>
<p>If you’re not familiar with Haskell, the first line defines a data type with two variants, it can either be a <code>Val</code>, which holds an <code>Int</code>, or it is an <code>Add</code> which holds two expressions. <code>Val</code> and <code>Add</code> are called constructors of <code>Expr</code>. The <code>eval</code> function pattern-matches and handles each case.</p>
<p>Now imagine that we do not only want to evaluate expressions but also pretty-print them. Adding operations is easy in Haskell, we just write a new function:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">pprint ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
pprint (<span class="dt">Val</span> i)     <span class="fu">=</span> show i
pprint (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> pprint e1 <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> pprint e2</code></pre></div>
<p>In Java we might achieve something similar by introducing an <code>Expr</code> class:</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> Expr {
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">eval</span>();
}

<span class="kw">class</span> Val <span class="kw">implements</span> Expr {
    <span class="kw">private</span> <span class="dt">final</span> <span class="dt">int</span> v;
    <span class="kw">public</span> <span class="fu">Val</span>(<span class="dt">int</span> v) { <span class="kw">this</span>.<span class="fu">v</span> = v; }
    <span class="kw">public</span> <span class="dt">int</span> eval { <span class="kw">return</span> v; }
}

<span class="kw">class</span> Add <span class="kw">implements</span> Expr {
    <span class="kw">private</span> <span class="dt">final</span> Expr l;
    <span class="kw">private</span> <span class="dt">final</span> Expr r;
    <span class="kw">public</span> <span class="fu">Add</span>(Expr l, Expr r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> <span class="dt">int</span> eval { <span class="kw">return</span> l.<span class="fu">eval</span>() + r.<span class="fu">eval</span>(); }
}</code></pre></div>
<p>But now, if we want to add the <code>pprint</code> operation, we have to touch every class. This is the side of the expression problem that functional languages tend to solve better than object oriented languages. However, the object oriented programming community has devised the visitor pattern as a way to solve this problem:</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">interface</span> ExprVisitor {
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Val v);
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Add a);
}

<span class="kw">interface</span> Expr {
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">accept</span>(ExprVisitor visitor);
}

<span class="kw">class</span> Val <span class="kw">implements</span> Expr {
    <span class="kw">private</span> <span class="dt">int</span> v;
    <span class="kw">public</span> <span class="fu">Val</span>(<span class="dt">int</span> v) { <span class="kw">this</span>.<span class="fu">v</span> = v; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">val</span>()  { <span class="kw">return</span> v; }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">accept</span>(ExprVisitor visitor) { visitor.<span class="fu">visit</span>(<span class="kw">this</span>); }
}

<span class="kw">class</span> Add : <span class="kw">public</span> Expr {
    <span class="kw">private</span> Expr l;
    <span class="kw">private</span> Expr r;
    <span class="kw">public</span> <span class="fu">Add</span>(Expr l, Expr r) { <span class="kw">this</span>.<span class="fu">l</span> = l; <span class="kw">this</span>.<span class="fu">r</span> = r; }
    <span class="kw">public</span> Expr <span class="fu">l</span>() { <span class="kw">return</span> l; }
    <span class="kw">public</span> Expr <span class="fu">r</span>() { <span class="kw">return</span> r; }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">accept</span>(ExprVisitor visitor) { visitor.<span class="fu">visit</span>(*<span class="kw">this</span>); }
}

<span class="kw">class</span> EvalVisitor <span class="kw">implements</span> ExprVisitor {
   <span class="kw">private</span> <span class="dt">int</span> result = <span class="dv">0</span>;
   <span class="kw">public</span> <span class="dt">int</span> <span class="fu">result</span>() { <span class="kw">return</span> result; }
   <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Val val) { result = val.<span class="fu">val</span>(); }
   <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Add add) {
        add.<span class="fu">l</span>().<span class="fu">accept</span>(<span class="kw">this</span>);
        <span class="dt">int</span> result_l = result;
        add.<span class="fu">r</span>().<span class="fu">accept</span>(<span class="kw">this</span>);
        result += result_l;
    }
}</code></pre></div>
<p>Ok, this is not exactly pretty, but let’s not forget that this is the side of the problem where OO languages are not good at. At least we can pull something of. And now we are in a situation where we can add new operations pretty easily:</p>
<div class="sourceCode"><pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">class</span> PprintVisitor <span class="kw">extends</span> ExprVisitor {
    <span class="kw">private</span> String result = <span class="st">&quot;&quot;</span>;
    <span class="kw">public</span> String <span class="fu">result</span>() { <span class="kw">return</span> result; }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Val val) override { result += val.<span class="fu">val</span>(); }
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">visit</span>(Add add) override {
        add.<span class="fu">l</span>().<span class="fu">visit</span>(<span class="kw">this</span>);
        result += <span class="st">&quot; + &quot;</span>;
        add.<span class="fu">r</span>().<span class="fu">visit</span>(<span class="kw">this</span>);
    }
}</code></pre></div>
<p>This works, but the Haskell solution is clearly more elegant. Does the visitor pattern have any additional advantages? Well, neither approach solves the expression problem: if we want to add a new variant, say a <code>Mult</code>, then we have to change existing code in both cases.</p>
<p>I can’t really think of an advantage for the visitor pattern. I’ve thought of two possibilities, <em>default implementations</em> and <em>almost-but-not-quite-solving-the-expression-problem</em>. But then I realized that the first problem is also similarly solvable in the pattern matching approach and that the second problem doesn’t work without loosing type safety or duplicating code:<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<ol style="list-style-type: decimal">
<li><p><em>Default implementations</em> are easy to implement with both approaches: in the visitor pattern defaults can be achieved by inherenting from a visitor with default implementations and overriding only certain methods. In the pattern-matching approach we would match all the constructors where we want to override the defaults and insert a wildcard match for the rest and call the default implementaiton on the bound variable.</p></li>
<li><p><em>Almost-but-not-quite-solving-the-expression-problem</em>: I first thought that we could use some inheritance based trickery to solve the expression problem at least for new code. But none of these seems to work: If we add a new variant, say <code>Mult</code>, it can’t derive from <code>Expr</code> because then it would have to implement <code>Expr</code>’s accept method, which it can’t sensibly do (because there is no right <code>visit</code> method in <code>ExprVisitor</code>).</p>
<p>Thus we must introduce a new interface <code>Expr2</code>. <code>Expr2</code> cannot derive from <code>Expr</code>, lest we have the same problem as before. But the old variants don’t derive from <code>Expr2</code>, so this is of limited use. Whichever way we twist or turn it, there is no easy way to solve the expression problem with this pattern.</p></li>
</ol>
<p>So, as it stands, I can’t really come up with an advantage for the visitor pattern over pattern matching. If you work in a language without sum types then it is certainly a great workaround, but in a language that does pattern matching seems much both more concise and more efficient.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>These are also known as disjoint union or variant types.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Both maintaining type safety and not duplicating code are requirements in the expression problem.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Due to the virtual method calls, which prevent inlining, I would expect the visitor pattern to be much slower than a direct function call.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Fri, 10 Jan 2014 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Sum-Types-Visitors-and-the-Expression-Problem.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Understanding Pointers, Ownership, and Lifetimes in Rust</title>
    <link>http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</link>
    <description><![CDATA[<h1 class="title">Understanding Pointers, Ownership, and Lifetimes in Rust</h1>

<p class="date">published on December 21, 2013</p>

<hr />
<h2 id="update-2015-03-15">Update 2015-03-15</h2>
<p>I have updated this post to reflect the new syntax for boxes or owned pointers in in rust 1.0.</p>
<hr />
<p>In the last couple of weeks I have been looking into <a href="http://www.rust-lang.org">Rust</a>, a new language developed by the good folks at Mozilla. Rust is fairly unique in that it is aimed at the same space as C++: a systems programming language that gives you full control over memory but also offers high level language features. In the past few years a few languages have come out that claim to target this space, for example <a href="http://www.go-lang.org">Go</a>, <a href="http://www.dlang.org">D</a>, and <a href="http://www.nimrod-lang.org">Nimrod</a>. However, these languages are garbage collected by default and loose their memory safety when memory is managed manually (D, Nimrod) or do not offer this possibility at all (Go). Therefore, these languages are not well equiped for applications which require full control over memory, which is the use case where C++ shines.</p>
<p>I think it’s great that C++ finally gets some real competition. Even among C++ fans, few will deny that compatibility with C, decades of language evolution, and accidental language features have created a very complex language that is extremely difficult to master. I think it is quite sad that for a lot of applications, C++ is still the only sane choice. We need a simpler language that offers more modern language features while targeting the same space. Rust could just be that language.</p>
<p>Ok now, the point of this post is not to argue the case for <a href="http://www.rust-lang.org">Rust</a> nor to heap (well deserved) praise onto the Rust designers and implementers. I want to talk about the ownership semantics in Rust and how they interact with the different type of pointers in Rust.</p>
<h2 id="rusts-guiding-principles">Rust’s Guiding Principles</h2>
<p>To me, understanding something means discovering and understanding the reasons and guiding principles behind the things on the surface. From these, it should be easy to reason about other things and quickly understand why they must be one way and not another. To me the guiding principles of memory managemend in Rust are the following:</p>
<ol style="list-style-type: decimal">
<li><p><strong><strong>Manual memory management</strong></strong>: There must be some way for the programmer to control when an object on the heap will be deleted.</p></li>
<li><p><strong><strong>Memory safety</strong></strong>: Pointers must never point to areas of memory that have been changed or deleted.</p></li>
<li><p><strong><strong>Safe Concurrency</strong></strong>: There should be no dataraces between threads. Multiple threads must not read and modify the same part of memory at the same time.</p></li>
<li><p><strong><strong>Compile time checks</strong></strong>: Ensure correctness at compile time instead of runtime whenever possible.</p></li>
</ol>
<p>This, in conjunction with the features that Rust provides, will give us a good idea why certain things must be the way they are in Rust. This post focuses on exploring the memory management and safety aspects.</p>
<h2 id="safe-manual-memory-management-by-enforcing-ownership">Safe Manual Memory Management by Enforcing Ownership</h2>
<p>The way Rust achieves safe manual memory management is by enforcing sane ownership semantics through a number of different pointers. There are several types of pointers in Rust: the most important are <em>boxes or owned pointers</em> and <em>references or borrowed pointers</em>. There are also different kinds of reference counted pointers, but these are for more complicated situations which I won’t get into in this post. Therefore, this post will focus on owned and borrowed pointers.</p>
<h3 id="boxes-owned-pointers"><em>Boxes</em> / <em>Owned Pointers</em></h3>
<p>A <em>box</em> or <em>owned pointer</em> in Rust has ownership over a certain part of the heap. When it goes out of scope it deletes that part of the heap. This achieves <em>manual memory management</em>: the programmer has control over when memory is released by controlling when an owned pointer goes out of scope. A box is a datatype, parameterized by the type that it boxes, so <code>Box&lt;i32&gt;</code> is the type of an owned pointer to an <code>i32</code> and <code>Box::new(3)</code> is the literal notation for allocating space on the heap for an i32, putting 3 into it and handling back an owned pointer. Like all pointers, boxes are derferenced by prefixing them with <code>*</code>. Here is a bit of a contrived example:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// The type annotations in the let statements in this example</span>
<span class="co">// (e.g. &#39;: Box&lt;int&gt;&#39;) are not necessary and only for clarity</span>

<span class="kw">fn</span> owned_seven() -&gt; <span class="dt">Box</span>&lt;<span class="dt">i32</span>&gt; {
    <span class="co">// Allocate an i32 with value &#39;3&#39; on the heap, &#39;three&#39; points to it</span>
    <span class="kw">let</span> three : <span class="dt">Box</span>&lt;<span class="dt">i32</span>&gt; = <span class="dt">Box</span>::new(<span class="dv">3</span>);
    <span class="co">// The same for four</span>
    <span class="kw">let</span> four : <span class="dt">Box</span>&lt;<span class="dt">i32</span>&gt; = <span class="dt">Box</span>::new(<span class="dv">4</span>);
    <span class="co">// Dereference both &#39;three&#39; and &#39;four&#39;, add them, store the result</span>
    <span class="co">// in a newly allocated variable on the heap</span>
    <span class="dt">Box</span>::new(*three + *four)
}   <span class="co">// &lt;-- &#39;three&#39; and &#39;four&#39; go out of scope, so the memory they own</span>
    <span class="co">//     is released. The memory of the return value is owned by the</span>
    <span class="co">//     return value so it survives the function call.</span>
    <span class="co">// Note: returning a pointer from a function is considered an anti-</span>
    <span class="co">// pattern in rust. It is prefered to return a value so the caller</span>
    <span class="co">// can decide what he wants to do with it. This is done for illustration</span>
    <span class="co">// purposes here.</span>


<span class="kw">fn</span> main() {
    <span class="kw">let</span> seven : <span class="dt">Box</span>&lt;<span class="dt">i32</span>&gt; = owned_seven();
    <span class="pp">println!</span>(<span class="st">&quot;3 + 4 = {}&quot;</span>, *seven);
}   <span class="co">// &lt;-- seven goes out of scope and the memory it points to is</span>
    <span class="co">//     deallocated here</span></code></pre></div>
<h3 id="referneces-borrowed-pointers"><em>Referneces</em> / <em>Borrowed Pointers</em></h3>
<p>Having only owned pointers would make writing many programs difficult: there could only ever be one reference to every <em>thing</em>. Fortunately, Rust offers another type of pointer called a <em>reference</em> or <em>borrowed pointer</em>. References do not imply ownership and they can point to objects both on the heap and the stack, so they are quite flexible. We can create a reference by taking the address of something with the <em>address-of</em> operator <code>&amp;</code>. In a slight abuse of notation, the types of references are also denoted by prefixing the type of the variable it points to by <code>&amp;</code>, so <code>&amp;i32</code> is a borrowed pointer to an <code>i32</code>.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="kw">let</span> three : &amp;<span class="dt">i32</span> = &amp;<span class="dv">3</span>;
    <span class="kw">let</span> four : &amp;<span class="dt">i32</span> = &amp;<span class="dv">4</span>;
    <span class="pp">println!</span>(<span class="st">&quot;3 + 4 = {}&quot;</span>, *three + *four);
}</code></pre></div>
<p>References in Rust are a lot like references and pass-by-reference bound variables in C and C++, but note that unlike C/C++-references borrowed pointers must be dereferenced to get to their values. I think this is really more consistent, because references really hold the address to a memory location, just like other pointes. So it makes sense to treat them similarly in terms of syntax. References in Rust also have a number of safety mechanisms that C/C++ references lack, but more on that later.</p>
<h2 id="move-semantics">Move Semantics</h2>
<p><em>Memory safety</em> implies that owned pointers <em>cannot be copied or cloned</em>. Otherwise, two such pointers could point to the same block of memory and that memory would be deleted twice. Therefore, owned pointers have move semantics:<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> when owned pointer <code>o2</code> is initialized from owned pointer <code>o1</code>, <code>o1</code> is no longer valid. By guiding principle number four, we would perfer to ensure this at compile time, and Rust indeed does this.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
   <span class="kw">let</span> o1 = <span class="dt">Box</span>::new(<span class="st">&quot;world&quot;</span>);
   <span class="kw">let</span> o2 = o1;                <span class="co">// &lt;-- o1 is &#39;moved&#39; into o2 and now invalid</span>
   <span class="pp">println!</span>(<span class="st">&quot;Hello, {}!&quot;</span>, o1); <span class="co">// &lt;-- this is a compile time error</span>
}</code></pre></div>
<p>Indeed the Rust compiler reports:</p>
<pre><code>move.rs:4:27: 4:29 error: use of moved value: `o1`
move.rs:4    println!(&quot;Hello, {}!&quot;, o1); // &lt;-- this is a compile time error
                                    ^~</code></pre>
<h3 id="structs-and-enums">Structs and Enums</h3>
<p>In general Rust has move semantics. When an object is initialized via assignment its memory is moved to the newly assigned variable. However, structs can implement the <code>Copy</code> trait, which means they will have copy semantics instead: When assigned the new object gets a bitwise copy of the object used to assign it.</p>
<p>The <code>Copy</code> trait cannot be implemented when an object contains a box: the box does not implement the copy trait, so we can’t copy it when copying the object containing it. This makes sense because the box has move semantics, the object containing it must also have move semantics, otherwise we would again incur two independent owning copies.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Derive the Copy trait so objects of this type have copy semantics</span>
<span class="at">#[</span>derive<span class="at">(</span>Show<span class="at">,</span><span class="bu">Copy</span><span class="at">)]</span>
<span class="kw">struct</span> Pod {x: <span class="dt">i32</span>, y: <span class="dt">u32</span>}

<span class="co">// Can&#39;t derive the Copy trait because Box&lt;T&gt; does not have the Copy trait</span>
<span class="at">#[</span>derive<span class="at">(</span>Show<span class="at">)]</span>
<span class="kw">struct</span> WithBox {x: <span class="dt">i32</span>, p: <span class="dt">Box</span>&lt;<span class="dt">i32</span>&gt;}

<span class="kw">fn</span> main() {
   <span class="kw">let</span> a1 = Pod {x: <span class="dv">3</span>, y: <span class="dv">4</span>};
   <span class="kw">let</span> a2 = a1;
   <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, a1);                   <span class="co">// &lt;-- OK, a1 has been copied</span>
   <span class="kw">let</span> b1 = WithBox {x: <span class="dv">3</span>, p: <span class="dt">Box</span>::new(<span class="dv">4</span>)};
   <span class="kw">let</span> b2 = b1;
   <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, b1);                   <span class="co">// &lt;-- Compile time error, b1 has been moved</span>
}</code></pre></div>
<p>The same rules apply to enums, but here the error messages can be a bit more confusing.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> MyEnum {
     X(<span class="dt">i32</span>),
     Y(<span class="dt">Box</span>&lt;<span class="dt">i32</span>&gt;)
}

<span class="kw">fn</span> match_and_print(e: &amp;MyEnum) {
    <span class="kw">match</span> e {
        &amp;MyEnum::X(x) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x),  <span class="co">// &lt;-- OK, x can be copied</span>
        &amp;MyEnum::Y(y) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, *y)  <span class="co">// &lt;-- Error, y cannot be moved out of a reference</span>
    }
}

<span class="kw">fn</span> main() {
   <span class="kw">let</span> x = MyEnum::X(<span class="dv">3</span>);
   <span class="kw">let</span> y = MyEnum::Y(<span class="dt">Box</span>::new(<span class="dv">4</span>));
   match_and_print(&amp;x);
   match_and_print(&amp;y);
}</code></pre></div>
<p>In this case the compiler reports</p>
<pre><code>move.rs:9:9: 9:22 error: cannot move out of borrowed content
move.rs:9         &amp;MyEnum::Y(y) =&gt; println!(&quot;{}&quot;, *y)  // &lt;-- Error, y cannot be moved out of a reference
                  ^~~~~~~~~~~~~
move.rs:9:20: 9:21 note: attempting to move value to here
move.rs:9         &amp;MyEnum::Y(y) =&gt; println!(&quot;{}&quot;, *y)  // &lt;-- Error, y cannot be moved out of a reference
                             ^
move.rs:9:20: 9:21 help: to prevent the move, use `ref y` or `ref mut y` to capture value by reference
move.rs:9         &amp;MyEnum::Y(y) =&gt; println!(&quot;{}&quot;, *y)  // &lt;-- Error, y cannot be moved out of a reference
                             ^</code></pre>
<p>Standard pattern matches are pass-by-value, meaning that the contents of the enum is moved. However, this can only be done when we have ownership over the values to be moved. When we apply <code>match</code> to a dereferenced borrowed pointer, we cannot move because we don’t have ownership. Changing the <code>match_and_print</code> function to take a value would work again.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> match_and_print(e: MyEnum) {
    <span class="kw">match</span> e {
        MyEnum::X(x) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x),
        MyEnum::Y(y) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, *y)
    }
}</code></pre></div>
<h3 id="the-ref-keyword">The <code>ref</code> Keyword</h3>
<p>Moving values in pattern matches is not always what we want. Sometimes we just want to take a reference. This way we can pattern match on values which we have obtained via borrowed pointers or we can simply avoid a move. This is where the <code>ref</code> keyword comes into play: It changes the pass-by-value semantics of a pattern match to pass-by-borrowed-pointer semantics:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> match_and_print(e: &amp;MyEnum) {
    <span class="kw">match</span> e {
        &amp;MyEnum::X(x) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x),
        &amp;MyEnum::Y(<span class="kw">ref</span> y) =&gt;                 <span class="co">// OK, y is a borrowed ptr to Box&lt;int&gt;</span>
            <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, **y)     <span class="co">// y has type &amp;Box&lt;int&gt; and must be dereferenced twice</span>
    }
}</code></pre></div>
<p>To bind mutable references there is also the <code>ref mut</code> version which allows modifying:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> match_and_print(e: &amp;<span class="kw">mut</span> MyEnum) {
    <span class="kw">match</span> e {
        &amp;<span class="kw">mut</span> MyEnum::X(x) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x),
        &amp;<span class="kw">mut</span> MyEnum::Y(<span class="kw">ref</span> <span class="kw">mut</span> y) =&gt; {
            **y = <span class="dv">5</span>;
            <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, **y)
        }
    }
}

<span class="kw">fn</span> main() {
   <span class="kw">let</span> <span class="kw">mut</span> x = MyEnum::X(<span class="dv">3</span>);
   <span class="kw">let</span> <span class="kw">mut</span> y = MyEnum::Y(<span class="dt">Box</span>::new(<span class="dv">4</span>));
   match_and_print(&amp;<span class="kw">mut</span> x);
   match_and_print(&amp;<span class="kw">mut</span> y);
}</code></pre></div>
<p>The <code>ref</code> keyword and its <code>ref mut</code> variant also work in <code>let</code> bindings:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
   <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">3</span>;
   <span class="kw">let</span> <span class="kw">ref</span> <span class="kw">mut</span> y = x;
   *y = <span class="dv">4</span>;
   <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, *y);
}</code></pre></div>
<h2 id="lifetimes">Lifetimes</h2>
<p>The difficulty with borrowed pointers is that they themselves cannot ensure that they point to valid memory. What if the thing that owns the memory they point to goes out of scope or is reassigned? Since the borrowed pointer has no ownership that memory would be deleted and possibly reassigned. The borrowed pointer would become a <em>dangling reference</em>, which is precisely what we wanted to avoid per guiding principle number 2: <strong>memory safety</strong>.</p>
<p>Therefore Rust must take a number of precautions to ensure these scenarios do not happen. First, the memory that a borrowed pointer points to must not be freed during that borrowed pointers <strong><strong>lifetime</strong></strong>. Second, this memory <strong><strong>must not change</strong></strong> while it is borrowed.</p>
<p>The first requirement leads us to the concept of <strong><strong>lifetimes</strong></strong>, the amount of time that some object is guaranteed to exist.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> lifetimes1() {
    <span class="kw">let</span> name = <span class="dt">Box</span>::new(<span class="st">&quot;world&quot;</span>);      <span class="co">//                 &lt;--+</span>
    <span class="kw">if</span> <span class="dv">3</span> &lt; <span class="dv">5</span> {                         <span class="co">//                    |</span>
        <span class="kw">let</span> bname = &amp;name;             <span class="co">// &lt;--+               | name&#39;s</span>
        <span class="pp">println!</span>(<span class="st">&quot;Hello, {}!&quot;</span>, name);  <span class="co">//    | bname&#39;s       | lifetime</span>
        <span class="pp">println!</span>(<span class="st">&quot;Hello, {}!&quot;</span>, bname); <span class="co">//    | lifetime      |</span>
    }                                  <span class="co">// &lt;--+               |</span>
}                                      <span class="co">//                 &lt;--+</span></code></pre></div>
<p>In this example, it is quite clear that the lifetime of <code>bname</code> will be shorter than that of <code>name</code> and thus the compiler needs no help in figuring this out. However, things need not always be this simple, consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> lifetimes2() {
    <span class="kw">let</span> <span class="kw">mut</span> x_ref = &amp;<span class="dv">3</span>;       <span class="co">//                 &lt;--+</span>
    <span class="kw">if</span> <span class="cn">true</span> {                 <span class="co">//                    |</span>
        <span class="kw">let</span> <span class="kw">mut</span> y_ref = &amp;<span class="dv">4</span>;   <span class="co">// &lt;--+ y_ref&#39;s       | x_ref&#39;s</span>
        x_ref = y_ref;        <span class="co">//    | lifetime      | lifetime</span>
    }                         <span class="co">// &lt;--+               |</span>
}                             <span class="co">//                 &lt;--+</span></code></pre></div>
<p>Here we have a problem: <code>x_ref</code> is reassigned to point to the same memory location as <code>y_ref</code>, but <code>y_ref</code>’s lifetime is shorter than <code>x_ref</code>’s. To ensure memory safety, the compiler must rejetct this program, which it does:</p>
<pre><code>lifetimes.rs:21:24: 21:26 error: borrowed value does not live long enough
lifetimes.rs:18:16: 24:1 note: borrowed pointer must be valid for the block at 18:16...
lifetimes.rs:20:12: 23:5 note: ...but borrowed value is only valid for the block at 20:12</code></pre>
<p>Things become even more interesting when we work with borrowed pointers inside of a function:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> min_life(x: &amp;<span class="dt">i32</span>, y: &amp;<span class="dt">i32</span>) -&gt; &amp;<span class="dt">i32</span> {
    <span class="kw">if</span> *x &lt; *y {
        x
    } <span class="kw">else</span> {
        y
    }
}</code></pre></div>
<p>Here the lifetime of the result depends on the condition evaluated in the if statement: depending on it the lifetime will either be that of x or that of y. Clearly, the compiler can’t resolve this automatically, it would need to know the values to which x and y point, which may only be known at runtime:</p>
<pre><code>lifetimes.rs:1:33: 1:37 error: missing lifetime specifier [E0106]
lifetimes.rs:1 fn minLife(x: &amp;i32, y: &amp;i32) -&gt; &amp;i32 {
                                               ^~~~
lifetimes.rs:1:33: 1:37 help: this function&#39;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
lifetimes.rs:1 fn minLife(x: &amp;i32, y: &amp;i32) -&gt; &amp;i32 {
                                               ^~~~</code></pre>
<p>Since the compiler can’t infer the lifetimes we must annotate them. Alas, we too would be hard pressed to give the exact lifetime in this example. However, there is a trick by which we can manage this</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> min_life&lt;<span class="ot">&#39;a</span>&gt;(x: &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>, y: &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>) -&gt; &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span> {
    <span class="kw">if</span> *x &lt; *y {
        x
    } <span class="kw">else</span> {
        y
    }
}</code></pre></div>
<p>Here we explictly annotate the lifetime of the parameters and the return value. Lifetime parameters are introduced by a single tick <code>'</code> followed by an identifier. In functions these must be the first template parameters. As you can see we use the same parameter for the lifetime everywhere. If the compiler would take this information too literally, then this function whould be less flexible than we might wish: In this case we could only use it on borrowed pointers which have the exact same lifetime. Fortunately, the compiler interprets the provided lifetimes as a lower bound. Thus <code>'a</code> is the minimum of the lifetimes of <code>x</code> and <code>y</code>. There is one special lifetime, which is called <code>'static</code> and is for objects which are allocated for the entire life of the program.</p>
<h2 id="freezing">Freezing</h2>
<p>Another problem with borrowed pointers is that the memory must not be modified while it has been borrowed out. This is achieved by freezing the original object when a borrowed pointer to it exists:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> freeze() {
    <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">3</span>;
    {
        <span class="kw">let</span> <span class="kw">mut</span> y = &amp;x;
        x = <span class="dv">4</span>;       <span class="co">// &lt;-- Error: x has been borrowed and is thus `frozen`</span>
    }
    x = <span class="dv">4</span>;           <span class="co">// OK</span>
}</code></pre></div>
<p>In the block we cannot modify <code>x</code> because it is borrowed:</p>
<pre><code>freeze.rs:5:9: 5:14 error: cannot assign to `x` because it is borrowed
freeze.rs:5         x = 4;       // &lt;-- Error: x has been borrowed and is thus `frozen`
                    ^~~~~
freeze.rs:4:22: 4:23 note: borrow of `x` occurs here
freeze.rs:4         let mut y = &amp;x;
                                 ^</code></pre>
<p>Note that this restriction is irrespective of whether the borrowed pointer is mutable or not.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The other alternative would be that owned pointers can never be reassigned, they would be non-copiable and non-moveable. This seems pretty cumbersome, fortunately Rust’s owned pointers have move semantics.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Ensuring the validity of owned pointers at compile time is much better than the alternatives: If it was assured at runtime, there would be fewer correctness guarantees about the program and the check would have to be performed every time a pointer is dereferenced. Checking the validity of pointers at compile time is a major achievement of the Rust language: tracking such moves at compile time requires an advanced type-system feature called <a href="http://en.wikipedia.org/wiki/Type_system">affine types</a>. As far as I know Rust is the only mainstreamy language which has such a feature.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Sat, 21 Dec 2013 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Certified Red-Black Trees in Coq -- Part 0</title>
    <link>http://koerbitz.me/posts/Red-Black-Trees-In-Coq-Part-0.html</link>
    <description><![CDATA[<h1 class="title">Certified Red-Black Trees in Coq -- Part 0</h1>

<p class="date">published on October 24, 2013</p>

<p>Now that I’ve learned about Coq <a href="/notes/Software-Foundations.html">for a while</a>, I’ve wondered if I could actually used it to prove something useful yet. One thing I thought would be interesting but not to hard was to prove that insert and delete operations on red-black trees are sound.</p>
<p>Alas, I’ve discovered that comming up with structures and proves myself was a lot harder than just doing the exercises in software foundations. But I’ve kept at it and I now sort-a kind-a proved that the insert operations maintains the order of a red-black tree, one of its three defining properties (the others are perfect black balance, and non-consequitive left-leaning red nodes).</p>
<p>The proofs are still full of holes, but they are holes that I am confident I can fix given a little more time (they should not be complicated). It ain’t pretty, but I am glad I got this far:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">
<span class="dt">Require</span> <span class="dt">Export</span> SfLib<span class="kw">.</span>
<span class="dt">Module</span> RbTrees<span class="kw">.</span>

<span class="dt">Inductive</span> <span class="dt">RbColor</span> : <span class="dt">Type</span> :=
  | <span class="dt">RbRed</span>
  | RbBlack<span class="kw">.</span>

<span class="dt">Definition</span> flipColor (c:<span class="dt">RbColor</span>) : <span class="dt">RbColor</span> :=
  <span class="kw">match</span> c <span class="kw">with</span>
    | <span class="dt">RbRed</span> =&gt; <span class="dt">RbBlack</span>
    | <span class="dt">RbBlack</span> =&gt; <span class="dt">RbRed</span>
  end.

<span class="dt">Inductive</span> <span class="dt">RbTree</span> : <span class="dt">Type</span> :=
  | tip : <span class="dt">RbTree</span>
  | node : <span class="dt">RbColor</span> -&gt; nat -&gt; <span class="dt">RbTree</span> -&gt; <span class="dt">RbTree</span> -&gt; RbTree<span class="kw">.</span>

<span class="dt">Fixpoint</span> rotLeft (t:<span class="dt">RbTree</span>) : <span class="dt">RbTree</span> :=
  <span class="kw">match</span> t <span class="kw">with</span>
    | tip =&gt; tip
    | node c n l r =&gt;
      <span class="kw">match</span> r <span class="kw">with</span>
        | tip =&gt; node c n l r
        | node rc rn rl rr =&gt; node rc rn (node <span class="dt">RbRed</span> n l rl) rr
      end
  end.

<span class="dt">Fixpoint</span> rotRight (t:<span class="dt">RbTree</span>) : <span class="dt">RbTree</span> :=
  <span class="kw">match</span> t <span class="kw">with</span>
    | tip =&gt; tip
    | node c n l r =&gt;
      <span class="kw">match</span> l <span class="kw">with</span>
        | tip =&gt; node c n l r
        | node lc ln ll lr =&gt; node lc ln ll (node <span class="dt">RbRed</span> n lr r)
      end
  end.

<span class="dt">Definition</span> rightIsRed (t:<span class="dt">RbTree</span>) : <span class="dt">bool</span> :=
  <span class="kw">match</span> t <span class="kw">with</span>
    | node _ _ _ (node <span class="dt">RbRed</span> _ _ _) =&gt; <span class="kw">true</span>
    | _ =&gt; <span class="kw">false</span>
  end.

<span class="dt">Definition</span> twoRedsOnLeft (t:<span class="dt">RbTree</span>) : <span class="dt">bool</span> :=
  <span class="kw">match</span> t <span class="kw">with</span>
    | node _ _ (node <span class="dt">RbRed</span> _ (node <span class="dt">RbRed</span> _ _ _) _) _ =&gt; <span class="kw">true</span>
    | _ =&gt; <span class="kw">false</span>
  end.

<span class="dt">Definition</span> balanceR (t:<span class="dt">RbTree</span>) : <span class="dt">RbTree</span> :=
  <span class="kw">if</span> twoRedsOnLeft t <span class="kw">then</span> rotRight t <span class="kw">else</span> t.

<span class="dt">Definition</span> balanceL (t:<span class="dt">RbTree</span>) : <span class="dt">RbTree</span> :=
  <span class="kw">if</span> rightIsRed t <span class="kw">then</span> rotLeft t <span class="kw">else</span> t.

<span class="dt">Definition</span> bothLeftAndRightAreRed (t:<span class="dt">RbTree</span>) : <span class="dt">bool</span> :=
  <span class="kw">match</span> t <span class="kw">with</span>
    | node _ _ (node <span class="dt">RbRed</span> _ _ _) (node <span class="dt">RbRed</span> _ _ _) =&gt; <span class="kw">true</span>
    | _ =&gt; <span class="kw">false</span>
  end.

<span class="co">(* these evidence carrying booleans would be nice here *)</span>
<span class="dt">Definition</span> flipColors (t:<span class="dt">RbTree</span>) : <span class="dt">RbTree</span> :=
  <span class="kw">match</span> t <span class="kw">with</span>
    | node <span class="dt">RbBlack</span> n (node <span class="dt">RbRed</span> ln ll lr) (node <span class="dt">RbRed</span> rn rl rr) =&gt; node <span class="dt">RbRed</span> n (node <span class="dt">RbBlack</span> ln ll lr) (node <span class="dt">RbBlack</span> rn rl rr)
    | _ =&gt; t
  end.

<span class="dt">Inductive</span> flipable : <span class="dt">RbTree</span> -&gt; <span class="dt">Prop</span> :=
  | flip_intro : forall (n ln rn:nat) (ll lr rl rr : <span class="dt">RbTree</span>),
                   flipable (node <span class="dt">RbBlack</span> n (node <span class="dt">RbRed</span> ln ll lr) (node <span class="dt">RbRed</span> rn rl rr)).

<span class="dt">Inductive</span> <span class="dt">Cmp</span> : <span class="dt">Type</span> :=
  | <span class="dt">LT</span>
  | <span class="dt">EQ</span>
  | GT<span class="kw">.</span>

<span class="dt">Fixpoint</span> cmp (n m:nat) : <span class="dt">Cmp</span> :=
  <span class="kw">if</span> beq_nat n m <span class="kw">then</span> <span class="dt">EQ</span> <span class="kw">else</span>
    <span class="kw">if</span> ble_nat n m <span class="kw">then</span> <span class="dt">LT</span> <span class="kw">else</span> GT<span class="kw">.</span>

<span class="dt">Fixpoint</span> insert (nn:nat) (t:<span class="dt">RbTree</span>) : <span class="dt">RbTree</span> :=
  <span class="kw">match</span> t <span class="kw">with</span>
    | tip =&gt; node <span class="dt">RbBlack</span> nn tip tip
    | node c n l r =&gt;
      <span class="kw">match</span> cmp nn n <span class="kw">with</span>
        | <span class="dt">EQ</span> =&gt; t
        | <span class="dt">LT</span> =&gt; flipColors (balanceR (node c n (insert nn l) r))
        | <span class="dt">GT</span> =&gt; flipColors (balanceL (node c n l (insert nn r)))
      end
  end.

<span class="dt">Fixpoint</span> blt_nat (n m:nat) : <span class="dt">bool</span> :=
  <span class="kw">match</span> n <span class="kw">with</span>
    | <span class="dt">O</span>      =&gt; <span class="kw">match</span> m <span class="kw">with</span>
                  | <span class="dt">O</span> =&gt; <span class="kw">false</span>
                  | <span class="dt">S</span> m&#39; =&gt; <span class="kw">true</span>
                end
    | (<span class="dt">S</span> n&#39;) =&gt; ble_nat n&#39; m
  end.

<span class="dt">Definition</span> bgt_nat (n m:nat) : <span class="dt">bool</span> :=
  blt_nat m n.

<span class="dt">Fixpoint</span> rbForall (f : nat -&gt; <span class="dt">bool</span>) (t : <span class="dt">RbTree</span>) : <span class="dt">bool</span> :=
  <span class="kw">match</span> t <span class="kw">with</span>
    | tip =&gt; <span class="kw">true</span>
    | node _ n l r =&gt; andb (andb (rbForall f l) (f n)) (rbForall f r)
  end.

<span class="dt">Definition</span> gtTree (t:<span class="dt">RbTree</span>) (m:nat)  : <span class="dt">bool</span> :=
  rbForall (bgt_nat m) t.

<span class="dt">Definition</span> ltTree (t:<span class="dt">RbTree</span>) (m:nat) : <span class="dt">bool</span> :=
  rbForall (blt_nat m) t.

<span class="dt">Theorem</span> excluded_middle :
  forall <span class="dt">P</span>:<span class="dt">Prop</span>, <span class="dt">P</span> \/ ~ P<span class="kw">.</span>
Proof<span class="kw">.</span>
Admitted<span class="kw">.</span>

<span class="dt">Lemma</span> unflipable : forall (t:<span class="dt">RbTree</span>),
  ~flipable t -&gt; flipColors t = t.
Proof<span class="kw">.</span>
  intros.
  destruct t.
  simpl. reflexivity.
  destruct r. simpl. reflexivity.
  destruct t1. simpl. reflexivity.
  destruct r.
  destruct t2. simpl. reflexivity.
  destruct r. unfold not <span class="kw">in</span> H<span class="kw">.</span>
  <span class="kw">assert</span> (flipable (node <span class="dt">RbBlack</span> n (node <span class="dt">RbRed</span> n0 t1_1 t1_2) (node <span class="dt">RbRed</span> n1 t2_1 t2_2))).
  apply flip_intro. apply <span class="dt">H</span> <span class="kw">in</span> H0<span class="kw">.</span> inversion H0<span class="kw">.</span>
  simpl. reflexivity.
  simpl. reflexivity.
Qed<span class="kw">.</span>

<span class="dt">Lemma</span> rbForall_flipColors : forall (f : nat -&gt; <span class="dt">bool</span>) (t:<span class="dt">RbTree</span>),
  rbForall f t = <span class="kw">true</span> -&gt; rbForall f (flipColors t) = <span class="kw">true</span>.
Proof<span class="kw">.</span>
  intros. induction t.
  <span class="dt">Case</span> <span class="st">&quot;t=tip&quot;</span>. simpl. assumption.
  <span class="dt">Case</span> <span class="st">&quot;t=cons&quot;</span>.  remember (node r n t1 t2) <span class="kw">as</span> t.
    <span class="kw">assert</span> (flipable t \/ ~ (flipable t)). apply excluded_middle.
    inversion H0<span class="kw">.</span> destruct H1<span class="kw">.</span> simpl. simpl <span class="kw">in</span> H<span class="kw">.</span> apply H<span class="kw">.</span> <span class="kw">assert</span> (flipColors t = t).
    apply unflipable. apply H1<span class="kw">.</span> rewrite H2<span class="kw">.</span> apply H<span class="kw">.</span>
Qed<span class="kw">.</span>

<span class="dt">Lemma</span> rbForall_balanceR : forall (f : nat -&gt; <span class="dt">bool</span>) (t:<span class="dt">RbTree</span>),
  rbForall f t = <span class="kw">true</span> -&gt; rbForall f (balanceR t) = <span class="kw">true</span>.
Proof<span class="kw">.</span>
Admitted<span class="kw">.</span>

<span class="dt">Lemma</span> rbForall_balanceL : forall (f : nat -&gt; <span class="dt">bool</span>) (t:<span class="dt">RbTree</span>),
  rbForall f t = <span class="kw">true</span> -&gt; rbForall f (balanceL t) = <span class="kw">true</span>.
Proof<span class="kw">.</span>
Admitted<span class="kw">.</span>

<span class="dt">Lemma</span> rbForall_insert : forall (n m:nat) (f : nat -&gt; nat -&gt; <span class="dt">bool</span>) (t:<span class="dt">RbTree</span>),
  rbForall (f n) t = <span class="kw">true</span> -&gt; f n m = <span class="kw">true</span> -&gt; rbForall (f n) (insert m t) = <span class="kw">true</span>.
Proof<span class="kw">.</span>
  intros. induction t.
  <span class="dt">Case</span> <span class="st">&quot;t=tip&quot;</span>. simpl. unfold rbForall. unfold rbfold. rewrite H0<span class="kw">.</span> simpl. reflexivity.
  <span class="dt">Case</span> <span class="st">&quot;t=cons&quot;</span>. remember (cmp m n0) <span class="kw">as</span> cmpEq. destruct cmpEq.
    <span class="dt">SCase</span> <span class="st">&quot;m &lt; n0&quot;</span>. simpl. rewrite &lt;- HeqcmpEq<span class="kw">.</span> apply rbForall_flipColors. apply rbForall_balanceR. admit.
    <span class="dt">SCase</span> <span class="st">&quot;m = n0&quot;</span>. simpl. rewrite &lt;- HeqcmpEq<span class="kw">.</span> assumption.
    <span class="dt">SCase</span> <span class="st">&quot;m &gt; n0&quot;</span>. simpl. rewrite &lt;- HeqcmpEq<span class="kw">.</span> apply rbForall_flipColors. apply rbForall_balanceL. admit.
Qed<span class="kw">.</span>

<span class="dt">Inductive</span> rbOrdered : <span class="dt">RbTree</span> -&gt; <span class="dt">Prop</span> :=
  | <span class="dt">O_Tip</span> : rbOrdered tip
  | <span class="dt">O_Cons</span> : forall (n:nat) (c : <span class="dt">RbColor</span>) (l r : <span class="dt">RbTree</span>),
               rbOrdered l -&gt; rbOrdered r -&gt;
               gtTree l n = <span class="kw">true</span> -&gt; ltTree r n = <span class="kw">true</span> -&gt;
               rbOrdered (node c n l r).

<span class="dt">Lemma</span> flipColor_keeps_order : forall (n:nat) (c:<span class="dt">RbColor</span>) (l r : <span class="dt">RbTree</span>),
  rbOrdered (node c n l r) -&gt; rbOrdered (node (flipColor c) n l r).
Proof<span class="kw">.</span>
  intros. inversion H<span class="kw">.</span> apply O_Cons<span class="kw">.</span> assumption. assumption. assumption. assumption.
Qed<span class="kw">.</span>

<span class="dt">Lemma</span> flipColors_keeps_order : forall (t : <span class="dt">RbTree</span>),
  rbOrdered t -&gt; rbOrdered (flipColors t).
Proof<span class="kw">.</span>
  intros. remember t <span class="kw">as</span> tt. induction H<span class="kw">.</span>
  <span class="dt">Case</span> <span class="st">&quot;t = tip&quot;</span>.
    simpl. apply O_Tip<span class="kw">.</span>
  <span class="dt">Case</span> <span class="st">&quot;t = node ...&quot;</span>.
    <span class="kw">assert</span> (flipable t \/ ~ (flipable t)). apply excluded_middle.
    inversion H3<span class="kw">.</span> rewrite &lt;- <span class="dt">Heqtt</span> <span class="kw">in</span> H4<span class="kw">.</span> inversion H4<span class="kw">.</span> simpl.
    constructor.
    rewrite &lt;- <span class="dt">H8</span> <span class="kw">in</span> H<span class="kw">.</span> apply flipColor_keeps_order <span class="kw">in</span> H<span class="kw">.</span> simpl <span class="kw">in</span> H<span class="kw">.</span> apply H<span class="kw">.</span>
    rewrite &lt;- <span class="dt">H9</span> <span class="kw">in</span> H0<span class="kw">.</span> apply flipColor_keeps_order <span class="kw">in</span> H0<span class="kw">.</span> simpl <span class="kw">in</span> H0<span class="kw">.</span> apply H0<span class="kw">.</span>
    rewrite &lt;- <span class="dt">H8</span> <span class="kw">in</span> H1<span class="kw">.</span> unfold gtTree <span class="kw">in</span> H1<span class="kw">.</span> simpl <span class="kw">in</span> H1<span class="kw">.</span> unfold gtTree. simpl. apply H1<span class="kw">.</span>
    rewrite &lt;- <span class="dt">H9</span> <span class="kw">in</span> H2<span class="kw">.</span> unfold ltTree <span class="kw">in</span> H2<span class="kw">.</span> simpl <span class="kw">in</span> H2<span class="kw">.</span> unfold ltTree. simpl. apply H2<span class="kw">.</span>
    <span class="kw">assert</span> (flipColors t = t). apply unflipable. apply H4<span class="kw">.</span>
    rewrite Heqtt<span class="kw">.</span> rewrite H5<span class="kw">.</span> rewrite &lt;- Heqtt<span class="kw">.</span> constructor; assumption.
Qed<span class="kw">.</span>

<span class="dt">Lemma</span> balanceL_keeps_order : forall (t : <span class="dt">RbTree</span>),
  rbOrdered t -&gt; rbOrdered (balanceL t).
Proof<span class="kw">.</span>
Admitted<span class="kw">.</span>

<span class="dt">Lemma</span> balanceR_keeps_order : forall (t : <span class="dt">RbTree</span>),
  rbOrdered t -&gt; rbOrdered (balanceR t).
Proof<span class="kw">.</span>
Admitted<span class="kw">.</span>

<span class="dt">Theorem</span> insert_keeps_order : forall (n:nat) (t : <span class="dt">RbTree</span>),
  rbOrdered t -&gt; rbOrdered (insert n t).
Proof<span class="kw">.</span>
  intros. induction H<span class="kw">.</span>
  <span class="dt">Case</span> <span class="st">&quot;O_Tip&quot;</span>. simpl. repeat constructor.
  <span class="dt">Case</span> <span class="st">&quot;O_Cons&quot;</span>.
    remember (cmp n n0) <span class="kw">as</span> Hcmp<span class="kw">.</span>
    destruct Hcmp<span class="kw">.</span>
    <span class="dt">SCase</span> <span class="st">&quot;n &lt; n0&quot;</span>.
      simpl. rewrite &lt;- HeqHcmp<span class="kw">.</span>
      apply flipColors_keeps_order. apply balanceR_keeps_order. constructor. assumption. assumption.
      unfold gtTree.
      <span class="co">(*   rbForall (f n) t = true -&gt; f n m = true -&gt; rbForall (f n) (insert m t) = true. *)</span>
      apply rbForall_insert. apply H1<span class="kw">.</span>
      <span class="co">(* cmp n n0 = LT -&gt; bgt_nat n0 n = true *)</span> admit.
      assumption.
    <span class="dt">SCase</span> <span class="st">&quot;n = n0&quot;</span>. simpl. rewrite &lt;- HeqHcmp<span class="kw">.</span> apply <span class="dt">O_Cons</span>; assumption.
    <span class="dt">SCase</span> <span class="st">&quot;n &gt; n0&quot;</span>.
      simpl. rewrite &lt;- HeqHcmp<span class="kw">.</span>
      apply flipColors_keeps_order. apply balanceL_keeps_order. apply O_Cons<span class="kw">.</span> assumption. assumption. assumption.
      unfold ltTree. apply rbForall_insert. apply H2<span class="kw">.</span>
      <span class="co">(* cmp n n0 = GT -&gt; blt_nat n0 n = true *)</span> admit.
Qed<span class="kw">.</span></code></pre></div>
<p>This is all quite rough of course, I think I can learn a lot but iterating upon it until I have a nice solution. Dependent types are not easy!</p>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Thu, 24 Oct 2013 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Red-Black-Trees-In-Coq-Part-0.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Efficient Quicksort in Haskell</title>
    <link>http://koerbitz.me/posts/Efficient-Quicksort-in-Haskell.html</link>
    <description><![CDATA[<h1 class="title">Efficient Quicksort in Haskell</h1>

<p class="date">published on September  9, 2013</p>

<p>The Haskell wiki gives as one of the examples of the elegance of Haskell the following as a quicksort implementation in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">qsort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
qsort []    <span class="fu">=</span> []
qsort (h<span class="fu">:</span>t) <span class="fu">=</span> qsort (filter (<span class="fu">&lt;=</span> h) t) <span class="fu">++</span> [h] <span class="fu">++</span> qsort (filter (<span class="fu">&gt;</span> h) t)</code></pre></div>
<p>In terms of elegance, this solution is indeed hard to beat. It is as close to Wikipedia’s description of the essence of quicksort as code can get:<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<blockquote>
<p>Quicksort first divides a large list into two smaller sub-lists: the low elements and the high elements. Quicksort can then recursively sort the sub-lists.</p>
</blockquote>
<p>However, <a href="http://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html">you can argue</a> that this is not the <em>real</em> quicksort, because the beauty of quicksort is that it works in-place and does not require O(n) extra space as the version given above does. Therefore, the question is sometimes raised how the <em>real quicksort</em> would look in Haskell, given that it generally eschews mutuability and in-place update. There are of course various implementations floating around on the interwebs, but I wanted to see how an implementation using unboxed vectors looks like and how that compares in performance to a version in C++’s.</p>
<h2 id="a-haskell-implementation">A Haskell Implementation</h2>
<p>An efficient Quicksort implementation consists of two parts, the <em>partition</em> function, which rearranges the elements of an array so that the left part is less-or-equal to the pivot and the right part is greater and the main function which does the recursive calls on the sub-parts. Here is my Haskell version:</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns, ScopedTypeVariables #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="kw">import           </span><span class="dt">Control.Monad.Primitive</span>
<span class="kw">import           </span><span class="dt">Control.Applicative</span> ((&lt;$&gt;))
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Unboxed.Mutable</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import           </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import           </span><span class="dt">System.Clock</span>
<span class="kw">import           </span><span class="dt">System.Exit</span> (exitFailure, exitSuccess)
<span class="kw">import           </span><span class="dt">Control.DeepSeq</span> (deepseq)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">BS</span>
<span class="kw">import           </span><span class="dt">Data.ByteString.Char8</span> (readInt)

<span class="ot">partition ::</span> (<span class="dt">PrimMonad</span> m, <span class="dt">Ord</span> a, <span class="dt">M.Unbox</span> a) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">M.MVector</span> (<span class="dt">PrimState</span> m) a <span class="ot">-&gt;</span> m <span class="dt">Int</span>
partition <span class="fu">!</span>pi <span class="fu">!</span>v <span class="fu">=</span> <span class="kw">do</span>
    pv <span class="ot">&lt;-</span> M.unsafeRead v pi
    M.unsafeSwap v pi lastIdx
    pi&#39; <span class="ot">&lt;-</span> go pv <span class="dv">0</span> <span class="dv">0</span>
    M.unsafeSwap v pi&#39; lastIdx
    return pi&#39;
  <span class="kw">where</span>
    <span class="fu">!</span>lastIdx <span class="fu">=</span> M.length v <span class="fu">-</span> <span class="dv">1</span>

    go <span class="fu">!</span>pv i <span class="fu">!</span>si <span class="fu">|</span> i <span class="fu">&lt;</span> lastIdx <span class="fu">=</span>
       <span class="kw">do</span> iv <span class="ot">&lt;-</span> M.unsafeRead v i
          <span class="kw">if</span> iv <span class="fu">&lt;</span> pv
            <span class="kw">then</span> M.unsafeSwap v i si <span class="fu">&gt;&gt;</span> go pv (i<span class="fu">+</span><span class="dv">1</span>) (si<span class="fu">+</span><span class="dv">1</span>)
            <span class="kw">else</span> go pv (i<span class="fu">+</span><span class="dv">1</span>) si
    go _   _ <span class="fu">!</span>si                <span class="fu">=</span> return si

<span class="ot">qsort ::</span> (<span class="dt">PrimMonad</span> m, <span class="dt">Ord</span> a, <span class="dt">M.Unbox</span> a) <span class="ot">=&gt;</span> <span class="dt">M.MVector</span> (<span class="dt">PrimState</span> m) a <span class="ot">-&gt;</span> m ()
qsort v <span class="fu">|</span> M.length v <span class="fu">&lt;</span> <span class="dv">2</span> <span class="fu">=</span> return ()
qsort v                    <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> <span class="fu">!</span>pi <span class="fu">=</span> M.length v <span class="ot">`div`</span> <span class="dv">2</span>
    pi&#39; <span class="ot">&lt;-</span> partition pi v
    qsort (M.unsafeSlice <span class="dv">0</span> pi&#39; v)
    qsort (M.unsafeSlice (pi&#39;<span class="fu">+</span><span class="dv">1</span>) (M.length v <span class="fu">-</span> (pi&#39;<span class="fu">+</span><span class="dv">1</span>)) v)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    <span class="kw">if</span> length args <span class="fu">&lt;</span> <span class="dv">2</span>
      <span class="kw">then</span> putStrLn <span class="st">&quot;Usage: qsort RUNS FILENAME&quot;</span> <span class="fu">&gt;&gt;</span> exitFailure
      <span class="kw">else</span> return ()
    <span class="kw">let</span> (<span class="ot">nRuns::</span><span class="dt">Int</span>) <span class="fu">=</span> read (args <span class="fu">!!</span> <span class="dv">0</span>)
    nums <span class="ot">&lt;-</span> V.unfoldr (\s <span class="ot">-&gt;</span> readInt <span class="fu">$</span> BS.dropWhile isWs s) <span class="fu">&lt;$&gt;</span> BS.readFile (args <span class="fu">!!</span> <span class="dv">1</span>)
    loop nRuns (<span class="kw">do</span> nums&#39; <span class="ot">&lt;-</span> V.thaw nums
                   start <span class="ot">&lt;-</span> getTime <span class="dt">ProcessCPUTime</span>
                   qsort nums&#39;
                   time <span class="ot">&lt;-</span> getTime <span class="dt">ProcessCPUTime</span> <span class="fu">-</span> start
                   putStrLn <span class="fu">$</span> show <span class="fu">$</span> fromIntegral (sec time) <span class="fu">+</span>
                                     ((fromIntegral <span class="fu">$</span> nsec time) <span class="fu">/</span> <span class="dv">1000000000</span>))
    exitSuccess
  <span class="kw">where</span>
    loop <span class="dv">0</span> _ <span class="fu">=</span> return ()
    loop n a <span class="fu">=</span> a <span class="fu">&gt;&gt;</span> loop (n<span class="fu">-</span><span class="dv">1</span>) a

    isWs <span class="fu">!</span>c <span class="fu">=</span> c <span class="fu">==</span> <span class="dv">10</span> <span class="fu">||</span> c <span class="fu">==</span> <span class="dv">20</span> <span class="fu">||</span> c <span class="fu">==</span> <span class="dv">9</span></code></pre></div>
<p>All in all I’d say this is a pretty direct translation from the imperative version. For comparison, here is an implementation in C++:</p>
<div class="sourceCode"><pre class="sourceCode Cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;fstream&gt;</span>

<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="dt">void</span> swap(std::vector&lt;T&gt;&amp; arr, size_t i1, size_t i2)
{
  T buff = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = buff;
}

<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
size_t partition(std::vector&lt;T&gt;&amp; arr, size_t lo, size_t hi, size_t pi)
{
  swap(arr, pi, hi);
  T pv = arr[hi];
  size_t si=lo;
  <span class="kw">for</span> (size_t i=lo; i&lt;hi; ++i) {
    <span class="kw">if</span> (arr[i] &lt; pv) {
      swap(arr, i, si++);
    }
  }
  swap(arr, si, hi);
  <span class="kw">return</span> si;
}

<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="dt">void</span> qsort(std::vector&lt;T&gt;&amp; arr, size_t lo, size_t hi)
{
  size_t n = hi-lo<span class="dv">+1</span>;
  <span class="kw">if</span> (n &lt; <span class="dv">2</span>)
    <span class="kw">return</span>;
  size_t pi = partition(arr, lo, hi, lo + (hi-lo)/<span class="dv">2</span>);
  qsort(arr, lo,   pi<span class="dv">-1</span>);
  qsort(arr, pi<span class="dv">+1</span>, hi);
}

<span class="dt">int</span> main(<span class="dt">int</span> ac, <span class="dt">char</span>** av)
{
  <span class="kw">if</span> (ac &lt;= <span class="dv">2</span>)
  {
    std::cerr &lt;&lt; <span class="st">&quot;Usage: qsort RUNS FILENAME&quot;</span> &lt;&lt; std::endl;
    exit(<span class="dv">1</span>);
  }
  <span class="dt">int</span> nRuns = atoi(av[<span class="dv">1</span>]);

  std::ifstream infile(av[<span class="dv">2</span>]);
  <span class="kw">if</span> (!infile.good())
  {
    std::cerr &lt;&lt; <span class="st">&quot;Can&#39;t open file: &quot;</span> &lt;&lt; av[<span class="dv">2</span>] &lt;&lt; std::endl;
    exit(<span class="dv">1</span>);
  }

  std::vector&lt;<span class="dt">int</span>&gt; input;
  <span class="kw">while</span> (infile.good())
  {
    <span class="dt">int</span> i;
    infile &gt;&gt; i;
    input.push_back(i);
  }

  <span class="kw">for</span> (<span class="dt">int</span> n=<span class="dv">0</span>; n &lt; nRuns; ++n)
  {
    std::vector&lt;<span class="dt">int</span>&gt; unsorted(input);
    <span class="kw">auto</span> start = clock();
    qsort(unsorted, <span class="dv">0</span>, unsorted.size()<span class="dv">-1</span>);
    <span class="kw">auto</span> end = clock();
    printf(<span class="st">&quot;</span><span class="ch">%11.9f\n</span><span class="st">&quot;</span>, ((<span class="dt">double</span>) (end-start)) / CLOCKS_PER_SEC);
  }
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Let’s see how the two versions compare in terms of performance. For the comparison I generated 10.000.000 random integers, and measured the time it takes to sort them 50 times. The C++ version averages about 0.87 seconds while the Haskell version takes about 1.3 seconds. Not a bad result, but of course I would like the Haskell version to be just as fast. However, with my limited optimization skills I wasn’t able to eek out any more performance of the Haskell version.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://en.wikipedia.org/wiki/Quicksort">Wikipedia article on quicksort</a>.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Mon, 09 Sep 2013 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Efficient-Quicksort-in-Haskell.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>
<item>
    <title>Let Your Prompt Tell You When To Pull</title>
    <link>http://koerbitz.me/posts/Let-Your-Prompt-Tell-You-When-To-Pull.html</link>
    <description><![CDATA[<h1 class="title">Let Your Prompt Tell You When To Pull</h1>

<p class="date">published on August 20, 2013</p>

<p>During the last weeks, I have on numerous occasions simply forgotten to check repositories for updates. I have then often re-implemented functionality (after swearing that whoever was responsible for it hadn’t done it yet) that was in fact already implemented in the remote repository.</p>
<p>This is of course quite terrible, mostly because it makes me feel like an absolute idiot (rightly so?) and because it makes me waste time (admittedly the functionality had been quite small, otherwise I probably would have pulled, but still). So I set out to modify my <a href="http://www.yawl.org/" title="Yet Another Workflow Language">zsh</a> prompt so that it will inform me when the remote repository is ahead of my local repository. The solution turned out to be quite simple, I just had to add</p>
<pre><code>ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE=&quot;%{$fg_bold[red]%}↓↓↓%{$reset_color%}&quot;
ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE=&quot;%{$fg_bold[red]%}↑↑↑%{$reset_color%}&quot;
ZSH_THEME_GIT_PROMPT_DIVERGED_REMOTE=&quot;%{$fg_bold[red]%}↕↕↕%{$reset_color%}&quot;</code></pre>
<p>to my current zsh scheme.</p>
<p>Now, whenever a remote repository that I am tracking has new functionality my prompt informs me by showing me something along these lines:</p>
<div class="figure">
<img src="/images/zsh_screenshot.png" title="My zsh prompt" />

</div>
<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'paulkoerbitz';
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
]]></description>
    <pubDate>Tue, 20 Aug 2013 00:00:00 UT</pubDate>
    <guid>http://koerbitz.me/posts/Let-Your-Prompt-Tell-You-When-To-Pull.html</guid>
    <dc:creator>Paul Koerbitz</dc:creator>
</item>

    </channel>
</rss>
